<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=Edge"><meta http-equiv=permissions-policy content="interest-cohort=()"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#2b7bb5"><meta name=copyright content="Copyright (c)2022 Erik McClure"><meta name=keywords content="games,music,code,erik mcclure,erikmcclure,aurora theory,sweetie bot,discord,feathergui,black sphere studios,tinyoal,upatch"><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"><meta name=google-site-verification content="Oxb2ia8HjcHLXlvstA8xPpQO3BO_y15Ds2Ia-feq1MQ"><meta name=generator content="Hugo 0.62.2"><link rel=canonical href=https://erikmcclure.com/blog/7-problems-raytracing-doesnt-solve/><link rel=apple-touch-icon href=https://erikmcclure.com/favicon.ico><link rel="shortcut icon" type=image/x-icon href=https://erikmcclure.com/favicon.ico><link rel=stylesheet href=https://erikmcclure.com/css/main.css><link rel=stylesheet href=https://erikmcclure.com/css/prism.css rel=stylesheet><link rel=stylesheet href=https://erikmcclure.com/css/katex.min.css rel=stylesheet><link rel=stylesheet href=https://erikmcclure.com/css/font-awesome.min.css><link rel=alternate type=application/rss+xml title="Erik McClure - RSS" href=https://erikmcclure.com/index.xml><meta property="og:type" content="article"><title>7 Problems Raytracing Doesn't Solve</title><meta property="og:title" content="7 Problems Raytracing Doesn't Solve"><meta name=twitter:title content="7 Problems Raytracing Doesn't Solve"><meta itemprop=name content="7 Problems Raytracing Doesn't Solve"><meta name=description content="I see a lot of people get excited about extreme concurrency in modern hardware bringing us closer to the magical holy grail of raytracing. It seems that everyone thinks that once we have raytracing, we can fully simulate entire digital worlds, everything will be photorealistic, and graphics will become a &ldquo;solved problem&rdquo;. This simply isn't true, and in fact highlights several fundamental misconceptions about the problems faced by modern games and other interactive media."><meta property="og:description" content="I see a lot of people get excited about extreme concurrency in modern hardware bringing us closer to the magical holy grail of raytracing. It seems that everyone thinks that once we have raytracing, we can fully simulate entire digital worlds, everything will be photorealistic, and graphics will become a &ldquo;solved problem&rdquo;. This simply isn't true, and in fact highlights several fundamental misconceptions about the problems faced by modern games and other interactive media."><meta name=twitter:description content="I see a lot of people get excited about extreme concurrency in modern hardware bringing us closer to the magical holy grail of raytracing. It seems that everyone thinks that once we have raytracing, we can fully simulate entire digital worlds, everything will be photorealistic, and graphics will become a &ldquo;solved problem&rdquo;. This simply isn't true, and in fact highlights several fundamental misconceptions about the problems faced by modern games and other interactive media."><meta itemprop=description content="I see a lot of people get excited about extreme concurrency in modern hardware bringing us closer to the magical holy grail of raytracing. It seems that everyone thinks that once we have raytracing, we can fully simulate entire digital worlds, everything will be photorealistic, and graphics will become a &ldquo;solved problem&rdquo;. This simply isn't true, and in fact highlights several fundamental misconceptions about the problems faced by modern games and other interactive media."><meta property="og:url" content="https://erikmcclure.com/"><meta property="og:site_name" content="Erik McClure"><meta property="og:image" content="https://erikmcclure.com/img/avatar.png"><meta property="og:locale" content="en-US"><meta property="article:author" content="Erik McClure"><meta name=twitter:card content="summary"><meta name=twitter:site content="@erikmcclure0173"><meta name=twitter:creator content="@erikmcclure0173"><meta name=twitter:image content="https://erikmcclure.com/img/avatar.png"><meta name=twitter:dnt content="on"><link href=https://plus.google.com/104896885003230920472 rel=publisher><meta itemprop=image content="https://erikmcclure.com/img/avatar.png"><meta name=last-updated content="20120927-04:13:00.000"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-63026815-3"></script><script defer src=https://erikmcclure.com/syntax-prism.js></script><script defer src=https://erikmcclure.com/katex.min.js></script><script defer src=https://erikmcclure.com/mathtex-script-type.min.js></script><script defer src=https://erikmcclure.com/auto-render.min.js></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-63026815-3');</script></head><body><div id=container><header><nav><ul><li><a href=/blog/ title=Blog><i class="fa fa-book fa-fw fa-lg"></i>&nbsp;<p>Blog</p></a></li><li><a href=/projects/ title=Projects><i class="fa fa-briefcase fa-fw fa-lg"></i>&nbsp;<p>Projects</p></a></li><li><a href=https://erikmcclure.bandcamp.com title=Bandcamp><i class="fa fa-bandcamp fa-fw fa-lg"></i>&nbsp;<p>Bandcamp</p></a></li><li><a href=https://github.com/erikmcclure title=Github><i class="fa fa-github fa-fw fa-lg"></i>&nbsp;<p>Github</p></a></li><li><a href=https://twitter.com/erikmcclure0173 title=Twitter><i class="fa fa-twitter fa-fw fa-lg"></i>&nbsp;<p>Twitter</p></a></li><li><a href=/web/ title=Websites><i class="fa fa-globe fa-fw fa-lg"></i>&nbsp;<p>Websites</p></a></li></ul></nav><div class=dim><h1>Erik McClure</h1></div></header><main class=blog><section><meta itemprop=mainEntityOfPage itemtype=https://schema.org/WebPage content="https://erikmcclure.com/"><meta itemprop=dateModified content="2012-09-27T04:13:00+00:00"><meta itemprop=headline content="7 Problems Raytracing Doesn't Solve"><meta itemprop=description content="I see a lot of people get excited about extreme concurrency in modern hardware bringing us closer to the magical holy grail of raytracing. It seems that everyone thinks that once we have raytracing, we can fully simulate entire digital worlds, everything will be photorealistic, and graphics will become a &ldquo;solved problem&rdquo;. This simply isn't true, and in fact highlights several fundamental misconceptions about the problems faced by modern games and other interactive media."><meta itemprop=url content="https://erikmcclure.com/blog/7-problems-raytracing-doesnt-solve/"><div itemprop=publisher itemscope itemtype=https://schema.org/Organization><div itemprop=logo itemscope itemtype=https://schema.org/ImageObject><meta itemprop=url content="https://erikmcclure.com/img/avatar.png"><meta itemprop=width content="140"><meta itemprop=height content="140"></div><meta itemprop=name content="Erik McClure"></div><div itemprop=author itemscope itemtype=https://schema.org/Person><meta itemprop=name content="Erik McClure"></div><article><h4>7 Problems Raytracing Doesn't Solve</h4><hr><div class=padding><p>I see a lot of people get excited about extreme concurrency in modern hardware bringing us closer to the magical holy grail of <em>raytracing</em>. It seems that everyone thinks that once we have raytracing, we can fully simulate entire digital worlds, everything will be photorealistic, and graphics will become a &ldquo;solved problem&rdquo;. This simply isn't true, and in fact highlights several fundamental misconceptions about the problems faced by modern games and other interactive media.</p><p>For those unfamiliar with the term, <em>raytracing</em> is the process of rendering a 3D scene by tracing the path of a beam of light after it is emitted from a light source, calculating its properties as it bounces off various objects in the world until it finally hits the virtual camera. At least, you hope it hits the camera. You see, to be perfectly accurate, you have to cast a bajillion rays of light out from the light sources and then see which ones end up hitting the camera at some point. This is obviously a problem, because most of the rays don't actually hit the camera, and are simply wasted. Because this brute force method is so incredibly inefficient, many complex algorithms (such as <a href=http://en.wikipedia.org/wiki/Photon_mapping>photon-mapping</a> and <a href=http://en.wikipedia.org/wiki/Metropolis_light_transport>Metropolis light transport</a>) have been developed to yield approximations that are thousands of times more efficient. These techniques are almost always focused on attempting to find paths from the light source to the camera, so rays can be cast in the reverse direction. Some early approximations actually cast rays out from the camera until they hit an object, then calculated the lighting information from the distance and angle, disregarding other objects in the scene. While highly efficient, this method produced extremely inaccurate results.</p><p>It is with a certain irony that raytracing is touted as being a precise, super-accurate rendering method when all raytracing is actually done via approximations in the first place. Pixar uses photon-mapping for its movies. Most raytracers operate on stochastic sampling approximations. We can already do raytracing in realtime, if we get approximate enough, it just looks <a href="http://www.youtube.com/watch?v=h5mRRElXy-w&t=0m50s">boring</a> and is extremely limited. Graphics development doesn't just stop when someone develops realtime raytracing, because there will always be room for a better approximation.</p><h5 id=1-photorealism>1. Photorealism</h5><p>The meaning of <em>photorealism</em> is difficult to pin down, in part because the term is inherently subjective. If you define photorealism as being able to render a virtual scene such that it precisely matches a photo, then it is almost impossible to achieve in any sort of natural environment where the slightest wind can push a tree branch out of alignment.</p><p>This quickly gives rise to defining photorealism as rendering a virtual scene such that it is indistinguishable from a photograph of a similar scene, even if they aren't exactly the same. This, however, raises the issue of just how indistinguishable it needs to be. This seems like a bizarre concept, but there are different degrees of &ldquo;indistinguishable&rdquo; due to the differences between people's observational capacities. Many people will never notice a slightly misaligned shadow or a reflection that's a tad too bright. For others, they will stand out like sore thumbs and completely destroy their suspension of disbelief.</p><p>We have yet another problem in that the entire concept of &ldquo;photorealism&rdquo; has nothing to do with how humans see the world in the first place. Photos are inherently linear, while human experience a much more dynamic, log-based lighting scale. This gives rise to <a href=http://en.wikipedia.org/wiki/High_dynamic_range_imaging>HDR photography</a>, which actually has almost nothing to do with the HDR implemented in games. Games simply change the brightness of the entire scene, instead of combining the brightness of multiple exposures to brighten some areas and darken others in the <a href=http://en.wikipedia.org/wiki/File:BrnoSunsetHDRExampleByIgor.jpg>same photo</a>. If all photos are not created equal, then exactly which photo are we talking about when we say &ldquo;photorealistic&rdquo;?</p><h5 id=2-complexity>2. Complexity</h5><p>Raytracing is often cited as allowing an order of magnitude more detail in models by being able to efficiently process many more polygons. This is only sort of true in that raytracing is not subject to the same computational constraints that rasterization is. Rasterization must render every single triangle in the scene, whereas raytracing is only interested in whether or not a ray hits a triangle. Unfortunately, it still has to navigate through the scene representation. Even if a raytracer could handle a scene with a billion polygons efficiently, this raises completely unrelated problems involving RAM access times and cache pollution that suddenly become actual performance bottlenecks instead of micro-optimizations.</p><p>In addition, raytracing approximation algorithms almost always take advantage of rays that degrade quickly, such that they can only bounce 10-15 times before becoming irrelevant. This is fine and dandy for walking around in a city or a forest, but what about a kitchen? Even though raytracing is much better at handling reflections accurately, highly reflective materials cripple the raytracer, because now rays are bouncing hundreds of times off a myriad of surfaces instead of just 10. If not handled properly, it can absolutely devastate performance, which is catastrophic for game engines that must maintain constant render times.</p><h5 id=3-scale>3. Scale</h5><p>How do you raytrace stars? Do you simply wrap a sphere around the sky and give it a &ldquo;star&rdquo; material? Do you make them all point sources infinitely far away? How does this work in a space game, where half the stars you see can actually be visited, and the other half are entire galaxies? How do you accurately simulate an entire solar system down to the surface of a planet, as the <a href=http://kerbalspaceprogram.com/forum/entry.php/54-Scaled-Space-Now-with-100-more-Floating-Origin%21>Kerbal Space Program developers</a> had to? Trying to figure out how to represent that kind of information in a meaningful form with only 64 bits of precision, if you are lucky, is a problem completely separate from raytracing, yet of increasingly relevant concern as games continue to expand their horizons more and more. How do we simulate an entire galaxy? How can we maintain meaningful precision when faced with astronomical scales, and how does this factor in to our rendering pipeline? These are problems that arise in any rendering pipeline, regardless of what techniques it uses, due to fundamental limitations in our representations of numbers.</p><h5 id=4-materials>4. Materials</h5><p>Do you know what methane clouds look like? What about writing an <a href=http://en.wikipedia.org/wiki/File:Aerogel_nasa.jpg>aerogel</a> shader? Raytracing, by itself, doesn't simply figure out how a given material works, you have to tell it how each material behaves, and its accuracy is wholly dependent on how accurate your description of the material is. This isn't easy, either, it requires advanced mathematical models and heaps of data collection. In many places we're actually <a href=http://blog.selfshadow.com/publications/s2012-shading-course/>still trying to figure out</a> how to build physically correct material equations in the first place. Did you know that Dreamworks had to rewrite part of their cloud shader<sup><a href=#r1>1</a></sup> for How To Train Your Dragon? It turns out that getting clouds to look good when your character is flying directly beneath them with a hand raised is <em>really hard</em>.</p><p>This is just for <em>common lighting phenomena!</em> How are you going to write shaders for things like pools of magic water and birefringent <a href=http://en.wikipedia.org/wiki/Birefringence>calcite crystals</a>? How about trying to accurately simulate <a href=http://en.wikipedia.org/wiki/File:CircularPolarizer.jpg>circular polarizers</a> when most raytracers don't even know what polarization is? Does being photorealistic require you to simulate the <a href=http://en.wikipedia.org/wiki/Tyndall_effect>Tyndall Effect</a> for caustics in <a href=http://en.wikipedia.org/wiki/File:Why_is_the_sky_blue.jpg>crystals</a> and <a href=http://en.wikipedia.org/wiki/File:WaterAndFlourSuspensionLiquid.jpg>particulate matter</a>? There are <em>so many tiny little details</em> all around us that affect everything from the <a href=http://en.wikipedia.org/wiki/Tyndall_scattering#Blue_irises>color of our iris</a> to the <a href=http://en.wikipedia.org/wiki/Rainbow#Number_of_colours_in_spectrum_or_rainbow>creation of rainbows</a>. Just how much does our raytracer need to simulate in order to be photorealistic?</p><h5 id=5-physics>5. Physics</h5><p>What if we ignored the first four problems and simply assumed we had managed to make a perfect, magical photorealistic raytracer. Congratulations, you've managed to co-opt the entirety of your CPU for the task of rendering a static 3D scene, leaving nothing left for the physics. All we've managed to accomplish is taking the &ldquo;interactive&rdquo; out of &ldquo;interactive media&rdquo;. Being able to influence the world around us is a key ingredient to immersion in games, and this requires more and more accurate physics, which are arguably just as difficult to calculate as raytracing is. The most advanced real-time physics engine to-date is the <a href=http://www.gameranx.com/updates/id/707/article/mind-blowing-physics-engine-demonstration/>Lagoa Multiphysics</a>, and it can only just <em>barely</em> simulate a tiny scene in a well-controlled environment before it completely decimates a modern CPU. This is without any complex rendering at all. Now try doing that for a scene with a radius of several miles. Oh, and remember our <a href=#h3>issue with scaling</a>? This applies to physics too! Except with physics, its an <em>order of magnitude even more difficult</em>.</p><h5 id=6-content>6. Content</h5><p>As many developers have been discovering, procedural generation is not magic pixie dust you can sprinkle on problems to make them go away. Yet, without advances in content generation, we are forced to hire armies of artists to create the absurd amounts of detail required by modern games. Raytracing doesn't solve this problem, it makes it <em>worse</em>. In any given square mile of a human settlement, there are <em>billions</em> of individual objects, ranging from pine cones, to rocks, to TV sets, to <em>crumbs</em>, all of which technically have physics, and must be kept track of, and rendered, and even more importantly, <em>modeled</em>.</p><p>Despite <a href=http://en.wikipedia.org/wiki/Spore>multiple attempts</a> at leveraging procedural generation, the content problem has simply refused to go away. Until we can effectively harness the power of procedural generation, augmented artistic tools, and automatic design morphing, the advent of fully photorealistic raytracing will be useless. The best graphics engine in the world is nothing without art.</p><h5 id=7-ai>7. AI</h5><p><div style=margin-left:3em>&lt;Patrician|Away> what does your robot do, sam
&lt;bovril> it collects data about the surrounding environment, then discards it and drives into walls
â€” <i>Bash.org quote [#240849](http://bash.org/?240849)</i></div>Of course, while we're busy desperately trying to raytrace supercomplex scenes with advanced physics, we haven't even left any CPU time to calculate the AI! The AI in games is so consistently terrible its turned into <a href=http://tvtropes.org/pmwiki/pmwiki.php/Main/ArtificialStupidity>its own trope</a>. The game industry spends all its computational time trying to render a scene, leaving almost nothing left for the AI routines, forcing them to rely on <a href=http://en.wikipedia.org/wiki/A*_search_algorithm>techniques from 1968</a>. Think about that - we are approaching the point where AI in games comes down to a 50-year old technique that was considered hopelessly outdated before I was even born. Oh, and I should also point out that Graphics, Physics, Art, and AI are all completely separate fields with fundamentally different requirements that all have to work together in a coherent manner just so you can shoot headshots in Call of Duty 22.</p><p>I know that raytracing is exciting, sometimes simply as a demonstration of raw computational power. But it always disheartens me when people fantasize about playing amazingly detailed games indistinguishable from real life when that simply isn't going to happen, even with the inevitable development<sup>2</sup> of realtime raytracing. By the time it becomes commercially viable, it will simply be yet another incremental step in our eternal quest for infinite realism. It is an important step, and one we should strive for, but it alone is not sufficient to spark a revolution.</p><span style=font-size:80%><br><sup><a name=r1>1</a></sup> Found on the special features section of the How To Train Your Dragon DVD.<br><sup>2</sup> Disclaimer: I've been trying to develop an efficient raytracing algorithm for ages and haven't had much luck. <a href=http://www.tml.tkk.fi/~samuli/publications/lehtinen2012siggraph_paper.pdf>These guys are faring much better</a>.</span></div><hr><time itemprop=datePublished pubdate=pubdate datetime=2012-09-27T04:13:00+00:00><i class="fa fa-clock-o fa-fw"></i>&nbsp;Published on <a href=https://erikmcclure.com/blog/7-problems-raytracing-doesnt-solve/>September 27, 2012 at 4:13am</a></time><aside><i class="fa fa-share-square-o fa-fw"></i>&nbsp;share:<ul><li><a href="javascript:window.open('https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ferikmcclure.com%2fblog%2f7-problems-raytracing-doesnt-solve%2f','popup','width=600,height=400');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" d="M16.75 9H13.5V7a1 1 0 011-1h2V3H14a4 4 0 00-4 4V9H8v3h2v9h3.5V12H16z"/></svg></a><li><a href="javascript:window.open('https://twitter.com/intent/tweet?text=7%20Problems%20Raytracing%20Doesn%27t%20Solve&url=https%3a%2f%2ferikmcclure.com%2fblog%2f7-problems-raytracing-doesnt-solve%2f','popup','width=600,height=256');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" opacity="0" d="M0 0h24v24H0z"/><path class="st0" d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572.0-4.658 2.086-4.658 4.66.0.364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342.0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3.0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376.0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57.0 13.255-7.098 13.255-13.254.0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg></a></li><li><a href="javascript:window.open('https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2ferikmcclure.com%2fblog%2f7-problems-raytracing-doesnt-solve%2f','popup','width=700,height=380');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><rect class="st0" height="11" width="4" x="3" y="9"/><circle class="st0" cx="5" cy="5" r="2"/><path class="st0" d="M16.5 8.25A4.47251 4.47251.0 0013 9.95343V9H9V20h4V13a2 2 0 014 0v7h4V12.75a4.5 4.5.0 00-4.5-4.5z"/></svg></a></li><li><a href="javascript:window.open('https://plus.google.com/share?app=110&url=https%3a%2f%2ferikmcclure.com%2fblog%2f7-problems-raytracing-doesnt-solve%2f','popup','width=400,height=380');"><svg xmlns="http://www.w3.org/2000/svg" viewBox="4 2 52.6934 50.6934" class="icon-img" height="24"><style>.st0{fill:#666}</style><g><path class="st0" d="M19.6671 25.7867c-.0075 1.7935.0 3.5869.0076 5.3803 3.0067.098 6.0208.0527 9.0275.098-1.3262 6.6689-10.3989 8.8315-15.199 4.4761C8.5674 31.9206 8.801 23.5412 13.9327 19.992c3.5869-2.8635 8.6884-2.1552 12.2752.324 1.4092-1.3036 2.7278-2.6977 4.0013-4.1445-2.984-2.3812-6.6462-4.0767-10.5421-3.8958-8.1307-.2713-15.6059 6.8497-15.7415 14.9805-.52 6.6462 3.8506 13.1644 10.0222 15.5155 6.1489 2.3661 14.031.7535 17.957-4.77 2.5922-3.4889 3.1498-7.98 2.8484-12.1999C29.7194 25.7641 24.6933 25.7716 19.6671 25.7867z"/><path class="st0" d="M49.0704 25.7641c-.0151-1.4996-.0226-3.0067-.0301-4.5062-1.4996.0-2.9916.0-4.4836.0-.0151 1.4996-.0301 2.9991-.0377 4.5062-1.5071.0075-3.0067.0151-4.5062.0302.0 1.4995.0 2.9915.0 4.4836 1.4995.0151 3.0066.0302 4.5062.0452.0151 1.4996.0151 2.9991.0302 4.4987 1.4996.0 2.9916.0 4.4911.0.0075-1.4996.015-2.9991.0301-4.5062 1.5071-.0151 3.0067-.0226 4.5062-.0377.0-1.4921.0-2.9916.0-4.4836C52.0771 25.7792 50.57 25.7792 49.0704 25.7641z"/></g></svg></a></li></ul></aside></article><article><a name=comments><h4>Comments</h4></a><hr><div class=comments><div id=c5724529338739166429><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src="//lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35" alt>
<b>John Haugeland</b><p>Oh look, a rendering method doesn't "solve" an ill-defined term which means "looks substantially better than today," it doesn't unlock rendering at the galactic scale, and it doesn't solve five topics that have nothing to do with graphics.<br><br>It is difficult to waste space on blogspot, but...</p></div><hr><div class=reply id=c8284068625616148706><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>Congratulations, you don't suffer from the delusions of my target audience!</p></div><hr><div id=c8924993513741312312><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh3.googleusercontent.com/-cxsfGIqSvoM/AAAAAAAAAAI/AAAAAAAAAM4/yBS1gAYEdEQ/s32-c/photo.jpg alt>
<b>Magnus Kromann-Larsen</b><p>Isn't "How To Train Your Dragon" produced by DreamWorks Animation?</p></div><hr><div class=reply id=c6470718047697616286><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>Wow, you're right, I'm an idiot, fixed.</p></div><hr><div id=c9204810339490398875><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh6.googleusercontent.com/-vtEhrww0yd8/AAAAAAAAAAI/AAAAAAAAACY/DfNFIjfkwrI/s32-c/photo.jpg alt>
<b>Thomas Mansencal</b><p>You should know that most VFX productions nowadays are using raytracing because it helps achieving photorealism.<br><br>PRMan, Pixar's renderer is progressively increasing its raytracing capabilities especially since Prman 16 and 16.<br><br>Arnold is getting used more and more, and guess what it's a raytracer.<br><br>Mental Ray which is an hybrid renderer like PRMan has an enphasis on raytracing.<br><br>VRay which is heavily used in commercial is a raytracer.<br><br>Well in fact pretty much every renderer used in production is a raytracer, or hybrid in a few case.<br><br>KS</p></div><hr><div class=reply id=c7414944870868395340><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>Of course. Raytracing is required to achieve photorealism, but it doesn't simply magically create it out of thin air, which is my entire point.</p></div><hr><div id=c5352857446628514826><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh6.googleusercontent.com/-vtEhrww0yd8/AAAAAAAAAAI/AAAAAAAAACY/DfNFIjfkwrI/s32-c/photo.jpg alt>
<b>Thomas Mansencal</b><p>Of course nothing is coming from thin air but then what's the purpose of your first point?</p></div><hr><div class=reply id=c6372441327080006819><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>My point is that its not instant photorealism, it is approaching photorealism. The entire point is to address the perception of the public that raytracing is equal to photorealism. Raytracing is a STEP towards photorealism, which is obvious to anyone who knows what they're talking about, but not the general public. You can have raytracing and not actually have very good photorealism.</p></div><hr><div class=reply id=c2087919240148957917><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh6.googleusercontent.com/-vtEhrww0yd8/AAAAAAAAAAI/AAAAAAAAACY/DfNFIjfkwrI/s32-c/photo.jpg alt>
<b>Thomas Mansencal</b><p>This comment has been removed by the author.</p></div><hr><div id=c3501579533292216857><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh6.googleusercontent.com/-vtEhrww0yd8/AAAAAAAAAAI/AAAAAAAAACY/DfNFIjfkwrI/s32-c/photo.jpg alt>
<b>Thomas Mansencal</b><p>Just reposted the deleted comment properly formatted.<br><br>I think it really depends what you call raytracing, renderers like Arnold or Maxwell using Bidirectional Path Tracing ( Which is raytracing )achieve easily a picture quality where you cannot distinguish the generated from the real.<br><br>I guess your definition of raytracing is very restrictive.<br><br>You should talk about a specific implementation instead of speaking about raytracing in general because for instance Photon Mapping is based on raytracing.</p></div><hr><div class=reply id=c3035604299124887329><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>But I just mentioned a bidirectional approximation algorithm in the second paragraph!</p></div><hr><div class=reply id=c351291171547838895><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh6.googleusercontent.com/-vtEhrww0yd8/AAAAAAAAAAI/AAAAAAAAACY/DfNFIjfkwrI/s32-c/photo.jpg alt>
<b>Thomas Mansencal</b><p>Yeah but this is raytracing, an implementation of it, and it does produce photorealistic results ( Along with other implementations ), that's why I don't get the "7 Problems Raytracing Doesn't Solve: 1) Photorealism".</p></div><hr><div class=reply id=c2804579119682011905><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>It only produces photorealistic results if you have photorealistic materials and your approximation isn't too approximate.</p></div><hr><div id=c4416375733763293959><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//bp0.blogger.com/_Ds0G6RJcbN4/R2CWvVlVkNI/AAAAAAAAACY/dgQ9h29TBFI/S220-s32/Olivier_by_Sandra.jpg alt>
<b>Olivier Bruchez</b><p>"For those unfamiliar with the term, raytracing is the process of rendering a 3D scene by tracing the path of a beam of light after it is emitted from a light source, calculating its properties as it bounces off various objects in the world until it finally hits the virtual camera. At least, you hope it hits the camera. You see, to be perfectly accurate, you have to cast a bajillion rays of light out from the light sources and then see which ones end up hitting the camera at some point."<br><br>I thought it was the other way around, i.e. raytracers cast rays from the virtual camera through the scene all the way back to the lights?</p></div><hr><div class=reply id=c2652336205000516070><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>The approximation algorithms work that way, which is why they are faster.</p></div><hr><div class=reply id=c1677002934142461327><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src="//lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35" alt>
<b>Stefan Lang</b><p>Olivier is correct. Please check wikipedia: http://en.wikipedia.org/wiki/Ray_tracing_%28graphics%29<br><br>Early raytracers were in fact ray*casters*, i. e. they stopped the trace when hitting an object, and used that info just to calculate shading, assuming no obstructions of light sources (that is, no shadows). You could call that an approximation, but it is not not the kind of ray tracing Pixar does or ever did.<br><br>Check http://en.wikipedia.org/wiki/Ray_casting</p></div><hr><div class=reply id=c7495107059338942213><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>Yes, that is simply another approximation. I never implied Pixar used that kind of raytracing, or raycasting, whatever you want to call it.</p></div><hr><div class=reply id=c3784345854311631631><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src="//lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35" alt>
<b>Stefan Lang</b><p>Sorry, I wasn't clear. What I meant is that your article implies (whether you meant to or not) that Pixar used 'approximative algorithms' - which they didn't. I mentioned ray-casting only because it was the most common algorithm originally used to approximate ray-tracing.<br><br>Your article isn't clear about that, but Photon-mapping is not an approximation, nor an alternate algorithm - it is a refinement of one of the aspects of the ray-tracing model.</p></div><hr><div id=c4278587866319617739><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src="//lh3.googleusercontent.com/Rw_wdkZHfDXh8tDEBFF1Q3aSS_nDE-gMVWNfOHb7a2nIp2XuWAmJyGISHv9akZE=s35" alt>
<b>eccentricorbit0</b><p>Nice blog, btw.<br><br>As an engineer, what really caught my attention was the fluid behavior in that demonstration. What exactly is going on under the hood of that? It did *look* incredibly realistic.<br><br>I've worked with actual simulations of fluid dynamics via the physics-based Navier Stokes equations, over finite volume grids and other discretization schemes, and doing that requires insane amounts of number crunching *for each timestep*.<br><br>And yet, I've seen fluid-ish fluid-like behavior produced via things like a bunch of squishy particles, etc. I'm wondering if, even if it's not possible to tie it back to the physics, if for whatever reason the approximations you graphics guys are using capture enough of the right behavior to do things like lift/drag prediction far faster than the normal means of crunching PDEs.<br><br>Anyway, just thinking out loud.</p></div><hr><div class=reply id=c6578755781474209154><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>I've seen many different ways of simulating fluids, but most of them are using various particle methods. I'd bet what they're doing there basically amounts to a whole bunch of tiny particles, plus some optimizations so that they can increase effective particle size for parts of the water that aren't moving much. Keep in mind that looking realistic and being realistic are vastly different things. There is no way they were actually calculating any PDEs or anything close to it, they're just treating it as an nbody problem.</p></div><hr><div id=c630005678471881659><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src="//lh3.googleusercontent.com/Rw_wdkZHfDXh8tDEBFF1Q3aSS_nDE-gMVWNfOHb7a2nIp2XuWAmJyGISHv9akZE=s35" alt>
<b>eccentricorbit0</b><p>PS - I checked out your newgrounds page. Your music rocks. :-P<br><br></p></div><hr><div class=reply id=c2620401055370429922><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>Why thank you, I really need to finish my WIPs xD</p></div><hr><div id=c1359343772970521671><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh6.googleusercontent.com/-XJ5Inr15xQY/AAAAAAAAAAI/AAAAAAAAAAc/5FgNHLygsN4/s32-c/photo.jpg alt>
<b>Alan Witmer</b><p>Great article! Your point about physics reminded me of what might eventually be recognized as another limitation in current rendering technology: the physics of photons themselves, such as interference patterns. Modeling the optical behaviors of, say a several-micron-thick oil sheen on a puddle isn't just about statistical reflecting properties of surfaces, it's also about the colors produced when the photons reflected from the surface itself interfere positively and negatively with those reflected from the oil/water interface producing vivid color. And I think this is not just a "photo-realism" nit, but a whole different aspect of the physics of light that might become important with simulations and machine sensing.</p></div><hr><div class=reply id=c4023027040052919938><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>I thought about that myself, actually, since, for example, the polarization of the light is what can cause the Newton's rings phenomenon due to microscopic separations of two materials.</p></div><hr><div id=c6496606234821686303><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src="//lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35" alt>
<b>Stefan Lang</b><p>Sorry, but none of these problems are really at the doorstep of ray-tracing. These are common problems of game design and visualization. And you as a game designer have the choice to use one or another algorithm, depending on which solves your problems, or doesn't.<br><br>Ray Tracing is an algorithm that constructs images based on a scientific model of cameras, lighting, a scene, and the optics involved. Depending on complexity of that model, Ray Tracing takes a very long time to compute, and modern hardware so far has been incapable to master that complexity in a sufficient degree to create real-time animations. That's all there is to say about it.<br><br>That said, while ray tracing is horribly complex to compute, saying that "ray tracing will never solve the problem of this complexity" is just as silly as blaming the physicists for the complexity of quantum physics. It is what it is. If you cannot afford the complexity, go find another solution.<br><br>I'd suggest to check out Ray *casting*, and Octree, if simple polygonal rendering is not sufficient for you. But then I haven't been working in this area for 20 years, my advice may be outdated.</p></div><hr><div class=reply id=c3002407857882844374><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>Where did I say "never"? I simply said that raytracing itself does not intrinsically solve photorealism. It CAN solve photorealism, but only if you are using an approximation that is sufficiently accurate. Please stop reading your own opinions into my text.</p></div><hr><div class=reply id=c3409572046122385370><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src="//lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35" alt>
<b>Stefan Lang</b><p>Well, your headline says "raytracing doesn't solve". I may be reading too much into it, but as a mathematician I consider "doesn't solve" a pretty unambiguous and final statement. For me, this implies "cannot be solved, ever", which equates to "never". It is certainly not *my* opinion, just what I interpreted from your statements. Maybe I was wrong.<br><br>In any case, IMHO you're extending the term photo-realism way too far. It only means an image that is sufficiently detailed that an uninformed observer couldn't tell if it's a photo or not. Pixar pretty much achieved this 20 years ago, or maybe 10, depending on the sharpness of the observer.<br><br>The HDR is a problem of photos, not of ray-tracing.<br><br>After reading Nathans comment below I have to agree: you're going into way too much detail for any practical purposes, and not for any good reason. Any object not in the focus of the viewer or too far away to be seen clearly can be handled with a simplified model of physics and graphics (and AI, if applicable). You can't simulate the entire unverse. Compromise!<br></p></div><hr><div class=reply id=c740196668655005971><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>By "doesn't solve" I meant that raytracing, BY ITSELF, does NOT solve photorealism - and it doesn't, you need better materials no matter how fast your raytracing is, and if you consider better materials as part of raytracing, you are over-extending the term "raytracing". Of course, you the proceed to say that *I* am overextending the word "photorealistic", but what I'm trying to do is point out that "photorealism" is actually *more* subjective than most people think. If you don't think this, good for you.<br><br>If you think I am going into too much detail you simply don't realize how much those details contribute to the experience. I'm sure someone would have said the same thing about parallax mapping and relief mapping years ago.</p></div><hr><div class=reply id=c6257095173140315398><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src="//lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35" alt>
<b>Stefan Lang</b><p>Well, 'by itself', ray tracing is just a rendering algorithm, and it is well known what it solves: the mathematically exact rendering of complex geometrical bodies with nonplanar surfaces, including hidden-surface problem, reflections and transparency. That's about it. Like you said it doesn't solve materials. And it doesn't solve shading, or highlighting. It doesn't care about movement, animation, or any kind of physics. Nor AI.<br><br>Nor photo-realism! Ray tracing is no more about that than one artificial sweetener is about tasting the same as another artificial sweetener - the point is to emulate the real thing, not another artififcial one!<br><br>Mapping is about glossing over the details. It can turn a smooth surface into an apparently gravelly path. Would you prefer to simulate each individual gravel stone? IMHO that is just a waste of effort, unless there is a very good reason why the players attention is even turned to that path (e. g. trying to follow a trace of footsteps, or digging in the dirt). It would be easier to just have a hailstorm and let each hail stone jump in random directions upon hitting the path, to give the impression of an uneven surface.</p></div><hr><div class=reply id=c2491215427314745379><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>Mapping is simply one way of solving a problem. It is not the only way. If we are going to increase the amount of detail in games, we must stop thinking only in terms of techniques that have been around for ages and start thinking outside the box. Simply coming up with progressively clever ways to map something is not the only possible direction, or even the most correct - it is simply the one that's the most popular.<br><br>I am convinced there are better ways to do this that do not involve impossible amounts of information or processing power.</p></div><hr><div id=c8613956414443496038><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh3.googleusercontent.com/-855M2nuh64M/AAAAAAAAAAI/AAAAAAAALTo/sFC1HNIEn0c/s32-c/photo.jpg alt>
<b>Nathan Warden</b><p>I agree with a lot of the points in this article such as the increase it the complexity of the content, but also disagree about several things. Personally, I believe we can achieve very close to photo-realism using our current rasterization methods while incurring a relatively low-cost. That would obviously exclude things like real-time reflections on non-planar objects.<br><br>First off, almost every visual effects shot you've ever seen, and didn't realize you saw it, came from ray-tracing. You probably see hundreds of them every day and don't even notice it, so obviously the inaccuracies are not all that inaccurate.<br><br>Some things I disagree with in your article are things like were you make it seem like physics and AI having to suffer because of ray-tracing. I have been professionally working on games and other interactive media for several years now and worked professionally in the digital animation and visual effects field for a few years prior to that. Physics and AI have never put much burden on my CPU except when I was intentionally trying to push it to it's limit. These two things hardly put a burden on the CPU in most games. Why? Because, I can shut off physics and AI calculations for objects beyond a reasonable distance from my camera's position and turn them back on when I'm getting close to visible distance. Let's say I have a fairly dense urban level, no photo-realism has to suffer if I decide anything beyond (let's just say) 1500 meters isn't going to be seen anyway, so why compute the physics and AI on it?<br><br>You said, "In any given square mile of a human settlement, there are billions of individual objects, ranging from pine cones, to rocks, to TV sets, to crumbs, all of which technically have physics, and must be kept track of, and rendered, and even more importantly, modeled."<br><br>This is true, but...<br><br>1) In most cases, they actually don't have to be rendered after a certain distance of the camera because you wouldn't gain anything even in ray-tracing after a certain distance and is completely negligible. They could at some distance be completely removed from the render solution.<br><br>2) You can still use LODs for both materials and models. So you can replace a fully reflective material with a specular or cubemapped reflection at a distance where the player won't notice.<br><br>3) You don't have to model each individual rock, pine cone, etc... this is what instances and procedural textures are for (and possibly procedural displacement?) You can model a handful of these items and then place/paint them into your scene.<br><br>4) You don't have to have physics on every object, only for those objects that actually need it, IE background items don't need physics. Small rocks and other debris don't need physics. Let's say you have a chain link fence which apparently has a ton of polygons, you still only need a primitive box collider on it which computes very quickly.<br><br>5) AI for any actor only needs to be computed when that actor is within a certain distance. And things like paths don't need to be computed every frame.<br><br>6) Occlusion culling techniques can still be employed. Albeit, it would be a take a little longer for the developer to run the calculation on due to the recursion of reflections and such, but, it would make it run way faster on the gamer's end.<br><br>7) You can still use things like lightmapping if your lighting is consistent.<br><br>...) I could probably go on but, people should get the point.<br><br><br>Again, I'm perfectly happy with the rasterization methods we use now and don't think we're ready for ray-tracing quite yet, but with the advent of many-core CPUs that have already come and are coming into the market, sparing 4 or 5 cores for my physics and AI, while using a large chunk of them to do the rendering, and a few others for whatever other logic, animation, scene management, cleanup, etc, doesn't really sound all that unreasonable to me.</p></div><hr><div class=reply id=c3177621636660316889><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>Physics has always been a problem for me. You can't just shut off physics for objects beyond a certain distance because you can often still see the objects in question. You can reduce the load, but again that requires a specialized physics solution that, AFAIK, does not currently exist. AI is only not a problem because the techniques we are using deliberately don't use very much CPU. You are making rash assumptions about the fundamental complexity of a given calculations based entirely off current approximations that seem "good enough".<br><br>I am specifically interested in trying to push the boundaries of what really is "good enough", and these almost invariably require massive increases in the computational complexity for physics. AI I do not know enough about to comment.<br><br>1. Doesn't matter. The problem is not rendering speed, its information.<br><br>2. Gives minimal benefit to raytracing.<br><br>3. Actually, you do. I have specifically noticed the flat, boring, obviously fake textures used by modern games on the ground. While this is fine for most cases, the ground right next to the character needs to be fully modeled and interacted with, which is doable in terms of rendering, but introduces massive problems in terms of information storage and physics. This problem has not yet been solved by procedural generation in a satisfactory way, which is why we need to work on it more.<br><br>4. Very, very wrong. The entire fact that background objects "don't need" physics is what makes most games seem boring as shit, because nothing in the background ever moves. This is a PROBLEM, not a solution. You are free to not believe me simply because no one has managed to do this yet because its too expensive, but I promise I will simply prove you wrong in another 5 years.<br><br>5. Completely wrong. Try simulating an entire global economy with millions of interacting NPCs in a space MMO like EVE. Have fun!<br><br>6. This doesn't work for raytracing, or not in any real way that wouldn't be absorbed into the approximation algorithm itself.<br><br>7. If your lighting is consistent, your game is boring.<br><br>I personally believe many of these problems can be solved by rasterization, and that's one of the reasons I wrote the article, but you are looking at this from the perspective of the current game industry and what is currently accepted as "good enough". It won't be good enough when someone else makes something better.</p></div><hr><div class=reply id=c7177716200687004451><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src="//lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35" alt>
<b>Stefan Lang</b><p>I agree that "good enough" is relative. But I've never heard a player complain about a game being boring because 'nothing is happening in the distance'. They do complain however if not enough is happening in their immediate vicinity! Your time and effort would be better spent in distracting the player from the fact that distant objects are mostly uninteresting.<br><br>Make the near view graphics better and noone will care whether the distant background is unicolor grey or a complex particle system simulation of volcanic eruptions viewed through clouds of haze and ash. Well, ok, maybe not unicolor, but it's infinitely less expensive to just project a prerecorded movie of said simulation on the background...</p></div><hr><div class=reply id=c7550107290841279535><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>You do realize that the most difficult and rewarding problems to solve are problems that people don't realize are actually problems?<br><br>You can tell me I'm wasting my time, but I'm sure someone told Steve Jobs he was wasting his time too.</p></div><hr><div class=reply id=c1000716346256795819><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src="//lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35" alt>
<b>Stefan Lang</b><p>No I don't realize that, and if you're of that opinion, then mine differs. There are lots of known problems that would be rewarding to solve. I'm sure there are lots of unknown ones that would be rewarding to solve too, but I doubt they're as numerous, or, in general, equally rewarding.<br><br>Steve Jobs had the rare quality of recognizing such problems and the courage to invest into them. I do not. If you you feel you're up to something then I wish you the best of luck in your project. I've shared my piece of advice already. Maybe I'm wrong and you're right to ignore it.</p></div><hr><div class=reply id=c4843744478368400447><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>At this point I'm already ignoring almost everything anyone's said about this blog. So obviously either I'm on to something, or I'm just crazy.</p></div><hr><div class=reply id=c8796749154946674684><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src="//lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35" alt>
<b>Stefan Lang</b><p>I'm sorry, I was paying too much attention to your suggested solutions rather than the problem at hand: improving (game) graphics. You said it yourself: ray tracing doesn't solve it. So you need different solutions, and rather than critizize your ideas I should have suggested other options.<br><br>In any case, your observations are correct: there is definitely room for improvement. I've had similar ideas myself over the past 3 decades. But so far I've never managed to come up with an original idea that hadn't been invented and implemented already. Maybe you can be more successful than that.<br><br>3D gaming is quite old now. The first game presenting pseudo-realistic graphics was released almost 20 years ago (check out "The 7th guest"). And when I look at todays graphics, little has changed since then, at least on first glance.<br><br>When I compare my memories of that game to todays' games I realize I was wrong in some of my earlier statements: The only things that notably changed are the improved physics, and increased number and detail of objects. And it sure looks better! But look at the cost: our computers are a thousandfold more powerful than those of 1993, and still the animations appear to be lacking.<br><br>Yes, more details would improve the graphics, but that's what has been done for 20 years, and it comes at the cost of computing power. If you want something game-changing (literally), you should either think of some alternate algortihms that don't cost as much as the current ones, or find other aspects of the game (graphics or other) that would be worth improving.<br><br>It may be worth checking out current developments at Pixar: they're working on an incredibly complex physical model of curly hair in 'Brave'. If you can think of something simpler that could be introduced in real time graphics for gaming that would be something! It *is* about details too, just not the far off ones that Nathan and I suggested can be ignored for the most part. Instead it's the detail right in front of your camera.</p></div><hr><div class=reply id=c7645237522918213111><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>The key is not coming up with an idea that has not been invented already, its making the idea work. This is the underlying insight that I am relying on for my 2D graphics engine. What I'm doing with it has been done before, but it has never been *practical*. I figured out a way to take several existing ideas and combine them to make it practical.</p></div><hr><div id=c1803681051684268790><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src="//lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35" alt>
<b>Cracky</b><p>A little slow on this one, 3 months down the line though, but I had to reply:<br><br>I was actually looking for an article I read on how rasterization (and various "faking it" shaders) is(are) effectively indistinguishable from raytracing when I came across this. Put in that light, I'd say your points about not being able to trace to very deep depths, perfectly simulate the effects of distant stars, and provide adequade material descriptions are moot.<br><br>But really, it seems to me when you wrote that you were just warming up, and the point you are trying to push home is something along the lines of "rendering isn't everything". A point which I wholeheartedly agree on. I would love to see proper physicaly simulated materials in game, not just ghetto-destruction-algorithms [more accurate non-real time algorithms do exist, which excite me about future possibilities] but also chemical interaction. I want to see wood walls burn, and see acid eat through metal floors [i guess this would require voxel based rendering though?]<br><br>What really made me want to reply though, was your point on game AI. IO think when you wrote "rely on techniques from 1968" you meant "rely on A*" because to see ANY other algorithm, even a dated one, is an absolute blessing. Not that i'm knocking on A*, it's a great solution to path-finding, but it's roles are limited. I would LOVE to see more use of proper AI, machine learning, neural networks, computer vision (kinect was a godsend here). It seems every (nearly, there are exceptions) game "AI" I see though, is nothing but a simple precompiled script of "actions to take". Not something that even deserves the title of "AI".</p></div><hr><div class=reply id=c4427490156681693766><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src="//lh3.googleusercontent.com/Rw_wdkZHfDXh8tDEBFF1Q3aSS_nDE-gMVWNfOHb7a2nIp2XuWAmJyGISHv9akZE=s35" alt>
<b>zianchoy</b><p>>rendering isn't everything<br><br>I got that sense too. It seems that the thesis of this blog post is that raytracing only helps do a few things, it presents its own computational and design challenges, and doesn't save the software designers from having to create actual content.</p></div></div><div class=comments></div><hr><div class=wrapcommento><div id=commento></div><script src=https://cdn.commento.io/js/commento.js></script></div></form></article></section><section class=archive><article><img src=https://erikmcclure.com/img/avatar.th.png alt=Avatar width=180 height=180><h2>Archive</h2><ol><li><details><summary>2022</summary><ul><li><a href=/blog/camp-vista/>Camp Vista - Growing Up Next To Microsoft</a></li></ul></details></li><li><details><summary>2021</summary><ul><li><a href=/blog/blockchain-new-javascript/>Blockchain Is The New JavaScript</a></li><li><a href=/blog/cpp-constructors-memory-and-lifetimes/>C++ Constructors, Memory, and Lifetimes</a></li><li><a href=/blog/factorio-is-best-interview-we-have/>Factorio Is The Best Technical Interview We Have</a></li></ul></details></li><li><details><summary>2020</summary><ul><li><a href=/blog/why-you-cant-use-prebuilt-llvm-with-cpp17/>Why You Can't Use Prebuilt LLVM 10.0 with C++17</a></li><li><a href=/blog/someone-is-stealing-tracker-songs/>Someone Is Stealing Tracker Songs And Selling Them</a></li><li><a href=/blog/pressure-based-anti-spam-for-discord-bots/>Pressure Based Anti-Spam for Discord Bots</a></li></ul></details></li><li><details><summary>2019</summary><ul><li><a href=/blog/name-shadowing-should-be-an-operator/>Name Shadowing Should Be An Operator</a></li><li><a href=/blog/a-rant-on-terra/>A Rant On Terra</a></li><li><a href=/blog/risc-is-fundamentally-unscalable/>RISC Is Fundamentally Unscalable</a></li></ul></details></li><li><details><summary>2018</summary><ul><li><a href=/blog/software-engineering-is-bad-but-it-s-not-that-bad/>Software Engineering Is Bad, But That's Not Why</a></li><li><a href=/blog/why-do-people-use-the-wrong-email-/>Why Do People Use The Wrong Email?</a></li><li><a href=/blog/software-optimizes-to-single-points-of-failure/>Software Optimizes to Single Points of Failure</a></li><li><a href=/blog/migrating-to-static-blog/>Migrating To A Static Blog</a></li><li><a href=/blog/how-to-avoid-memorizing-times-tables/>How To Avoid Memorizing Times Tables</a></li></ul></details></li><li><details><summary>2017</summary><ul><li><a href=/blog/ignoring-outliers-creates-racist/>Ignoring Outliers Creates Racist Algorithms</a></li><li><a href=/blog/i-used-to-want-to-work-for-google/>I Used To Want To Work For Google</a></li><li><a href=/blog/sexist-programmers-are-awful-engineers/>Sexist Programmers Are Awful Engineers</a></li><li><a href=/blog/why-i-never-built-my-soundcloud-killer/>Why I Never Built My SoundCloud Killer</a></li><li><a href=/blog/integrating-luajit-and-autogenerating-c/>Integrating LuaJIT and Autogenerating C Bindings In Visual Studio</a></li><li><a href=/blog/discord-rise-of-bot-wars/>Discord: Rise Of The Bot Wars</a></li><li><a href=/blog/programmers-should-take-linguistics/>Programmers Should Take Linguistics</a></li><li><a href=/blog/companies-cant-be-apolitical/>Companies Can't Be Apolitical</a></li><li><a href=/blog/i-cant-hear-anything-below-80-hz/>I Can't Hear Anything Below 80 Hz*</a></li><li><a href=/blog/windows-wont-let-my-program-crash/>Windows Won't Let My Program Crash</a></li><li><a href=/blog/directx-is-terrifying/>DirectX Is Terrifying</a></li><li><a href=/blog/our-software-is-beacon-of-hope/>Our Software Is a Beacon of Hope</a></li></ul></details></li><li><details><summary>2016</summary><ul><li><a href=/blog/everyone-does-srgb-wrong-because/>Everyone Does sRGB Wrong Because Everyone Else Does sRGB Wrong</a></li><li><a href=/blog/mathematical-notation-is-awful/>Mathematical Notation Is Awful</a></li><li><a href=/blog/the-gpl-is-usually-overkill/>The GPL Is Usually Overkill</a></li><li><a href=/blog/the-right-to-ignore-difference-between/>The Right To Ignore: The Difference Between Free Speech And Harassment</a></li></ul></details></li><li><details><summary>2015</summary><ul><li><a href=/blog/there-will-never-be-one-true/>There Will Never Be One True Programming Language</a></li><li><a href=/blog/abortion-has-no-moral-high-ground/>Abortion Has No Moral High Ground</a></li><li><a href=/blog/i-tried-to-install-linux-and-now-i/>I Tried To Install Linux And Now I Regret Everything</a></li><li><a href=/blog/you-arent-designing-software-for-robots/>We Aren't Designing Software For Robots</a></li><li><a href=/blog/using-data-to-balance-your-game-pony/>Using Data To Balance Your Game: Pony Clicker Analysis</a></li><li><a href=/blog/is-there-commercial-open-source-license/>Is There A Commercial Open Source License?</a></li><li><a href=/blog/does-anyone-actually-want-good-software/>Does Anyone Actually Want Good Software?</a></li><li><a href=/blog/why-dont-you-just-fire-them/>Why Don't You Just Fire Them?</a></li></ul></details></li><li><details><summary>2014</summary><ul><li><a href=/blog/how-not-to-sell-software/>How Not To Install Software</a></li><li><a href=/blog/not-reinventing-wheel-is-anticompetitive/>Never Reinventing The Wheel Is Anticompetitive</a></li><li><a href=/blog/everyone-can-be-above-average/>Everyone Can Be Above Average</a></li><li><a href=/blog/can-we-choose-what-we-enjoy/>Can We Choose What We Enjoy?</a></li><li><a href=/blog/how-to-make-your-profiler-10x-faster/>How To Make Your Profiler 10x Faster</a></li><li><a href=/blog/the-problem-with-photorealism/>The Problem With Photorealism</a></li><li><a href=/blog/success-is-relative/>Success Is Relative</a></li></ul></details></li><li><details><summary>2013</summary><ul><li><a href=/blog/googles-decline-really-bugs-me/>Google's Decline Really Bugs Me</a></li><li><a href=/blog/the-educational-imbroglio/>The Educational Imbroglio</a></li><li><a href=/blog/the-ladder-climbing-generation/>The Ladder-Climbing Generation</a></li><li><a href=/blog/the-microsoft-word-problem/>The Microsoft Word Problem</a></li><li><a href=/blog/write-less-code/>Write Less Code</a></li><li><a href=/blog/most-people-have-shitty-computers/>Most People Have Shitty Computers</a></li><li><a href=/blog/leap-motion-impressions-input/>Leap Motion Impressions, Input Sanitation, and 3D Gesture Ideas</a></li><li><a href=/blog/aurora-theory-released/>Aurora Theory Released!</a></li><li><a href=/blog/what-i-learned-in-college/>What I Learned In College</a></li><li><a href=/blog/how-to-complain-about-men-and-be-sexist/>How To Complain About Men And Be Sexist At The Same Time</a></li><li><a href=/blog/course-notes/>Course Notes</a></li><li><a href=/blog/contact/>Contact</a></li><li><a href=/blog/the-dark-side-of-htmlcss/>The Dark Side of Web Development</a></li><li><a href=/blog/windows-breaks-assert-inside/>Windows Breaks assert() Inside WM_CANCELMODE</a></li><li><a href=/blog/dreams-are-worth-fighting-for/>Dreams Are Worth Fighting For</a></li><li><a href=/blog/the-productivity-fallacy/>The Productivity Fallacy</a></li><li><a href=/blog/the-earbud-loudness-wars/>The Earbud Loudness Wars</a></li></ul></details></li><li><details><summary>2012</summary><ul><li><a href=/blog/giant-list-of-free-samples/>Giant List of FREE SAMPLES</a></li><li><a href=/blog/the-weekend-apelsin-got-lost-all-time/>The Weekend I Got Lost All The Time</a></li><li><a href=/blog/c-to-c-tutorial-part-4-operator-overload/>C# to C++ Tutorial - Part 4: Operator Overload</a></li><li><a href=/blog/7-problems-raytracing-doesnt-solve/>7 Problems Raytracing Doesn't Solve</a></li><li><a href=/blog/teenage-rebellion-as-failure-of-society/>Teenage Rebellion as a Failure of Society</a></li><li><a href=/blog/analyzing-xkcd-click-and-drag/>Analyzing XKCD: Click and Drag</a></li><li><a href=/blog/what-is-right-answer/>What Is A Right Answer?</a></li><li><a href=/blog/coordinate-systems-and-cascading/>Coordinate Systems And Cascading Stupidity</a></li><li><a href=/blog/how-joysticks-ruined-my-graphics-engine/>How Joysticks Ruined My Graphics Engine</a></li><li><a href=/blog/properly-dreaming-about-success/>Properly Dreaming About Success</a></li><li><a href=/blog/multithreading-problems-in-game-design/>Multithreading Problems In Game Design</a></li><li><a href=/blog/ip-law-makes-you-asshole/>IP Law Makes You an Asshole</a></li><li><a href=/blog/stop-following-rules/>Stop Following The Rules</a></li><li><a href=/blog/standards-problem/>The Standards Problem</a></li><li><a href=/blog/an-evidence-based-refutation-of-the-project-glass-parodies/>An evidence-based refutation of the Project Glass parodies</a></li><li><a href=/blog/language-wars-are-pointless/>Language Wars Are Pointless</a></li><li><a href=/blog/why-windows-8-does-right-thing-wrong/>Why Windows 8 Does The Right Thing The Wrong Way</a></li><li><a href=/blog/well-that-was-interesting/>Well That Was Interesting</a></li><li><a href=/blog/visual-studio-broke-my-computer/>Visual Studio Broke My Computer</a></li><li><a href=/blog/hiring-wrong-people/>Hiring the Wrong People</a></li><li><a href=/blog/chill-out/>Chill Out</a></li><li><a href=/blog/implicit-ui-design/>Implicit UI Design</a></li><li><a href=/blog/linux-mint-12-kde/>Linux Mint 12 KDE</a></li><li><a href=/blog/new-post/>'Programmer' is an Overgeneralization</a></li><li><a href=/blog/wikipedias-identity-crisis/>Wikipedia's Identity Crisis</a></li></ul></details></li><li><details><summary>2011</summary><ul><li><a href=/blog/your-esoteric-language-is-useless/>Your Esoteric Language is Useless</a></li><li><a href=/blog/great-mystery-of-linear-gradient/>The Great Mystery of Linear Gradient Lighting</a></li><li><a href=/blog/signed-integers-considered-stupid-like/>Signed Integers Considered Stupid (Like This Title)</a></li><li><a href=/blog/why-kids-hate-math/>Why Kids Hate Math</a></li><li><a href=/blog/importance-of-importance/>Don't Work on Someone Else's Dream</a></li><li><a href=/blog/c-to-c-tutorial-part-3-classes-and/>C# to C++ Tutorial - Part 3: Classes and Structs and Inheritance (OH MY!)</a></li><li><a href=/blog/problem-of-vsync/>The Problem of Vsync</a></li><li><a href=/blog/musical-genres/>Musical Genres</a></li><li><a href=/blog/c-to-c-tutorial-part-2-pointers/>C# to C++ Tutorial - Part 2: Pointers Everywhere!</a></li><li><a href=/blog/radians-explanation/>Radians: An explanation</a></li><li><a href=/blog/c-to-c-tutorial-part-1-basics-of-syntax/>C# to C++ Tutorial - Part 1: Basics of Syntax</a></li><li><a href=/blog/on-hackers/>On Hacking (or Why We Need Security Ratings)</a></li><li><a href=/blog/my-mom-had-heart-attack/>My Mom Had a Heart Attack</a></li><li><a href=/blog/religion-problem-perspectives/>The Religion Problem: Perspectives</a></li><li><a href=/blog/ninth-circle-of-bugs/>The Ninth Circle of Bugs</a></li><li><a href=/blog/save-rss/>Save RSS</a></li><li><a href=/blog/college-is-broken/>College Is Broken</a></li><li><a href=/blog/outside-perspective-on-psn-fiasco/>An Outside Perspective on the PSN Fiasco</a></li><li><a href=/blog/future-predictions/>Future Predictions</a></li><li><a href=/blog/investigating-low-level-cpu-performance/>Investigating Low-level CPU Performance</a></li><li><a href=/blog/bullying-never-stops/>The Bullying Never Stops</a></li></ul></details></li><li><details><summary>2010</summary><ul><li><a href=/blog/aquaria-hints/>Aquaria Hints</a></li><li><a href=/blog/im-failure/>The IM Failure</a></li><li><a href=/blog/how-to-train-your-dragon/>How To Train Your Dragon</a></li><li><a href=/blog/album-for-sale-renascent/>Album For Sale! [Renascent]</a></li><li><a href=/blog/wavsaver/>WavSaver</a></li><li><a href=/blog/pixel-perfect-hit-testing/>Pixel Perfect Hit Testing</a></li><li><a href=/blog/fractal-cycle-screensaver/>Fractal Cycle Screensaver</a></li><li><a href=/blog/8-bit-color-cycling/>8-bit color cycling</a></li><li><a href=/blog/physics-networking/>Physics Networking</a></li><li><a href=/blog/assembly-cas-implementation/>Assembly CAS implementation</a></li><li><a href=/blog/function-pointer-speed/>Function Pointer Speed</a></li><li><a href=/blog/most-bizarre-error-ever/>Most Bizarre Error Ever</a></li><li><a href=/blog/floating-point-preformance/>Floating Point Preformance</a></li><li><a href=/blog/watch-this-now/>Watch This Now</a></li></ul></details></li><li><details><summary>2009</summary><ul><li><a href=/blog/physics-oriented-network-interpolation/>Physics-oriented Network Interpolation</a></li><li><a href=/blog/proving-strong-ai/>Proving Strong AI</a></li><li><a href=/blog/i-now-have-lj/>I now have an LJ</a></li></ul></details></li></ol></article></section></main><footer><p><span>Copyright &copy;2022 Erik McClure</span> <a href=https://erikmcclure.com/sitemap.xml>Sitemap</a> | <a href=https://erikmcclure.com/blog/index.xml>RSS Feed</a></p></footer></div><script>"use strict";window.onload=function(){var t=document.getElementsByClassName('math');for(var i=0,len=t.length;i<len;i++){renderMathInElement(t[i],{delimiters:[{left:"$$",right:"$$",display:false},{left:"\\[",right:"\\]",display:true}]});}}</script></body></html>