<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=Edge"><meta http-equiv=permissions-policy content="interest-cohort=()"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#2b7bb5"><meta name=copyright content="Copyright (c)2025 Erik McClure"><meta name=keywords content="games,music,code,erik mcclure,erikmcclure,aurora theory,sweetie bot,discord,feathergui,fading light,tinyoal,cloud hop"><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"><meta name=google-site-verification content="Oxb2ia8HjcHLXlvstA8xPpQO3BO_y15Ds2Ia-feq1MQ"><meta name=generator content="Hugo 0.119.0"><link rel=me href=https://equestria.social/@cloudhop><link rel=canonical href=https://erikmcclure.com/blog/c-to-c-tutorial-part-2-pointers/><link rel=apple-touch-icon href=https://erikmcclure.com/favicon.ico><link rel="shortcut icon" type=image/x-icon href=https://erikmcclure.com/favicon.ico><link rel=stylesheet href=https://erikmcclure.com/css/main.css><link rel=stylesheet href=https://erikmcclure.com/css/prism.css rel=stylesheet><link rel=stylesheet href=https://erikmcclure.com/css/katex.min.css rel=stylesheet><link rel=stylesheet href=https://erikmcclure.com/css/fontawesome.min.css><link rel=stylesheet href=https://erikmcclure.com/css/regular.min.css><link rel=stylesheet href=https://erikmcclure.com/css/brands.min.css><link rel=stylesheet href=https://erikmcclure.com/css/solid.min.css><link rel=alternate type=application/rss+xml title="Erik McClure - RSS" href=https://erikmcclure.com/blog/index.xml><meta property="og:type" content="article"><title>C# to C++ Tutorial - Part 2: Pointers Everywhere!</title><meta property="og:title" content="C# to C++ Tutorial - Part 2: Pointers Everywhere!"><meta name=twitter:title content="C# to C++ Tutorial - Part 2: Pointers Everywhere!"><meta itemprop=name content="C# to C++ Tutorial - Part 2: Pointers Everywhere!"><meta name=description content="[ 1 · 2 · 3 · 4 · 5 · 6 · 7 ]
We still have a lot of ground to cover on pointers, but before we do, we need to address certain conceptual frameworks missing from C# that one must be intimately familiar with when moving to C++.
Specifically, in C# you mostly work with the Heap. The heap is not difficult to understand - its a giant lump of memory that you take chunks out of to allocate space for your classes."><meta property="og:description" content="[ 1 · 2 · 3 · 4 · 5 · 6 · 7 ]
We still have a lot of ground to cover on pointers, but before we do, we need to address certain conceptual frameworks missing from C# that one must be intimately familiar with when moving to C++.
Specifically, in C# you mostly work with the Heap. The heap is not difficult to understand - its a giant lump of memory that you take chunks out of to allocate space for your classes."><meta name=twitter:description content="[ 1 · 2 · 3 · 4 · 5 · 6 · 7 ]
We still have a lot of ground to cover on pointers, but before we do, we need to address certain conceptual frameworks missing from C# that one must be intimately familiar with when moving to C++.
Specifically, in C# you mostly work with the Heap. The heap is not difficult to understand - its a giant lump of memory that you take chunks out of to allocate space for your classes."><meta itemprop=description content="[ 1 · 2 · 3 · 4 · 5 · 6 · 7 ]
We still have a lot of ground to cover on pointers, but before we do, we need to address certain conceptual frameworks missing from C# that one must be intimately familiar with when moving to C++.
Specifically, in C# you mostly work with the Heap. The heap is not difficult to understand - its a giant lump of memory that you take chunks out of to allocate space for your classes."><meta property="og:url" content="https://erikmcclure.com/"><meta property="og:site_name" content="Erik McClure"><meta property="og:image" content="https://erikmcclure.com/img/avatar.png"><meta property="og:locale" content="en-US"><meta property="article:author" content="Erik McClure"><meta name=twitter:card content="summary"><meta name=twitter:site content="@erikmcclure0173"><meta name=twitter:creator content="@erikmcclure0173"><meta name=twitter:image content="https://erikmcclure.com/img/avatar.png"><meta name=twitter:dnt content="on"><link href=https://plus.google.com/104896885003230920472 rel=publisher><meta itemprop=image content="https://erikmcclure.com/img/avatar.png"><meta name=last-updated content="20110721-19:35:00.000"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-63026815-3"></script>
<script defer src=https://erikmcclure.com/syntax-prism.js></script>
<script defer src=https://erikmcclure.com/katex.min.js></script>
<script defer src=https://erikmcclure.com/mathtex-script-type.min.js></script>
<script defer src=https://erikmcclure.com/auto-render.min.js></script>
<script defer src=https://cdn.commento.io/js/count.js></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-63026815-3")</script></head><body><div id=container><header><nav><ul><li><a href=/blog/ title=Blog><i class="fa-solid fa-book fa-fw fa-lg"></i>&nbsp;<p>Blog</p></a></li><li><a href=/projects/ title=Projects><i class="fa-solid fa-briefcase fa-fw fa-lg"></i>&nbsp;<p>Projects</p></a></li><li><a href=https://erikmcclure.bandcamp.com title=Bandcamp><i class="fa-brands fa-bandcamp fa-fw fa-lg"></i>&nbsp;<p>Bandcamp</p></a></li><li><a href=https://github.com/erikmcclure title=Github><i class="fa-brands fa-github fa-fw fa-lg"></i>&nbsp;<p>Github</p></a></li><li><a href=/web/ title=Websites><i class="fa-solid fa-globe fa-fw fa-lg"></i>&nbsp;<p>Websites</p></a></li></ul></nav><div class=dim><h1>Erik McClure</h1></div></header><main class=blog><section><meta itemprop=mainEntityOfPage itemtype=https://schema.org/WebPage content="https://erikmcclure.com/"><meta itemprop=dateModified content="2011-07-21T19:35:00+00:00"><meta itemprop=headline content="C# to C++ Tutorial - Part 2: Pointers Everywhere!"><meta itemprop=description content="[ 1 · 2 · 3 · 4 · 5 · 6 · 7 ]
We still have a lot of ground to cover on pointers, but before we do, we need to address certain conceptual frameworks missing from C# that one must be intimately familiar with when moving to C++.
Specifically, in C# you mostly work with the Heap. The heap is not difficult to understand - its a giant lump of memory that you take chunks out of to allocate space for your classes."><meta itemprop=url content="https://erikmcclure.com/blog/c-to-c-tutorial-part-2-pointers/"><div itemprop=publisher itemscope itemtype=https://schema.org/Organization><div itemprop=logo itemscope itemtype=https://schema.org/ImageObject><meta itemprop=url content="https://erikmcclure.com/img/avatar.png"><meta itemprop=width content="140"><meta itemprop=height content="140"></div><meta itemprop=name content="Erik McClure"></div><div itemprop=author itemscope itemtype=https://schema.org/Person><meta itemprop=name content="Erik McClure"></div><article><h4>C# to C++ Tutorial - Part 2: Pointers Everywhere!</h4><hr><div class=padding><p>[ <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-1-basics-of-syntax/>1</a> · <strong>2</strong> · <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-3-classes-and/>3</a> · <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-4-operator-overload/>4</a> <span style=color:#aaa>· 5 · 6 · 7</span> ]</p><p>We still have a lot of ground to cover on pointers, but before we do, we need to address certain conceptual frameworks missing from C# that one must be intimately familiar with when moving to C++.</p><p>Specifically, in C# you mostly work with the <strong>Heap</strong>. The heap is not difficult to understand - its a giant lump of memory that you take chunks out of to allocate space for your classes. Anything using the <code>new</code> keyword is allocated on the heap, which ends up being almost everything in a C# program. However, the heap isn&rsquo;t the only source of memory - there is also the <strong>Stack</strong>. The Stack is best described as what your program lives inside of. I&rsquo;ve said before that everything takes up memory, and yes, that includes your program. The thing is that the Heap is inherently dynamic, while the Stack is inherently <em>fixed</em>. Both can be re-purposed to do the opposite, but trying to get the Stack to do dynamic allocation is extremely dangerous and is almost guaranteed to open up a mile-wide security hole.</p><p>I&rsquo;m going to assume that a C# programmer knows what a <a href=http://en.wikipedia.org/wiki/Stack_(data_structure)>stack</a> is. All you need to understand is that absolutely every single piece of data that isn&rsquo;t allocated on the heap is pushed or popped off your program&rsquo;s stack. That&rsquo;s why most debuggers have a &ldquo;stack&rdquo; of functions that you can go up and down. Understanding the stack in terms of how many functions you&rsquo;re inside of is ok, but in reality, there are also variables declared on the stack, including every single parameter passed to a function. It is important that you understand how variable scope works so you can take advantage of declaring things on the stack, and know when your stack variables will simply vanish into nothingness. This is where <code>{</code> and <code>}</code> come in.</p><p><pre class=language-cpp><code>int main(int argc, char *argv[])
{
  int bunny = 1;
  
  {
    int carrot=3;
    int lettuce=8;
    bunny = 2; // Legal
  }

  //carrot=2; //Compiler error: carrot does not exist
  int carrot = 3; //Legal, since the other carrot no longer exists
  
  {
    int lettuce = 0;

    { 
       //int carrot = 1; //Compiler error: carrot already defined
       int grass = 9;
       
       bunny = grass; //Still legal
       bunny = carrot; // Also legal
    }
    
    //bunny = grass; //Illegal
    bunny = lettuce; //Legal
  }
  
  //bunny = lettuce; //Illegal
}
</code></pre><code>{</code> and <code>}</code> define <strong>scope</strong>. Anything declared inside of them ceases to exist outside, but is still accessible to any additional layers of scope declared inside of them. This is a way to see your program&rsquo;s stack in action. When <code>bunny</code> is declared, its pushed on to the stack. Then we enter our first scope area, where we push <code>carrot</code> and <code>lettuce</code> on to the stack and set <code>bunny</code> to 2, which is legal because <code>bunny</code> is still on the stack. When the scope is then closed, however, anything declared inside the scope is popped from the stack <em>in the exact opposite order it was pushed on</em>. Unfortunately, compiler optimization might change that order behind the scenes, so <strong>don&rsquo;t rely on it</strong>, but it should be fairly consistent in debug builds. First <code>lettuce</code> is de-allocated (and its destructor called, if it has one), then <code>carrot</code> is de-allocated. Consequently, trying to set <code>carrot</code> to 2 outside of the scope will result in a compiler error, because it doesn&rsquo;t exist anymore. This means we can now declare an entirely new integer variable that is also called <code>carrot</code>, without causing an error. If we visualize this as a stack, that means <code>carrot</code> is now directly above <code>bunny</code>. As we enter a new scope area, <code>lettuce</code> is then put on top of <code>carrot</code>, and then <code>grass</code> is put on top of <code>lettuce</code>. We can still assign either <code>lettuce</code> or <code>carrot</code> to <code>bunny</code>, since they are all on the stack, but once we leave this inner scope, <code>grass</code> is popped off the stack and no longer exists, so any attempt to use it causes an error. <code>lettuce</code>, however, is still there, so we can assign <code>lettuce</code> to <code>bunny</code> before the scope closes, which pops <code>lettuce</code> off the stack.</p><p>Now the only things on the stack are <code>bunny</code> and <code>carrot</code>, in that order (if the compiler hasn&rsquo;t moved things around). We are about to leave the function, and the function is also surrounded by <code>{</code> and <code>}</code>. This is because a function is, itself, a scope, so that means all variables declared inside of that scope are also destroyed in the order they were declared in. First <code>carrot</code> is destroyed, then <code>bunny</code> is destroyed, and then the function&rsquo;s parameters <code>argc</code> and <code>argv</code> are destroyed (however the compiler can push those on to the stack in whatever order it wants, so we don&rsquo;t know the order they get popped off), until finally the <em>function itself</em> is popped off the stack, which returns program flow to whatever called it. In this case, the function was <code>main</code>, so program flow is returned to the parent operating system, which does cleanup and terminates the process.</p><p>You can declare anything that has a size determined at compile time on the stack. This means if you have an array that has a constant size, you can declare it on the stack:</p><p><pre class=language-cpp><code>int array[5]; //Array elements are not initialized and therefore are undefined!
int array[5] = {0,0,0,0,0}; //Elements all initialized to 0
//int array[5] = {0}; // Compiler error - your initialization must match the array size
</code></pre>You can also let the compiler infer the size of the array:</p><p><pre class=language-cpp><code>int array[] = {1,2,3,4}; //Declares an array of 4 ints on the stack initialized to 1,2,3,4
</code></pre>Not only that, but you can declare class instances and other objects on the stack.</p><p><pre class=language-cpp><code>Class instance(arg1, arg2); //Calls a constructor with 2 arguments
Class instance; //Used if there are no arguments for the constructor
//Class instance(); //Causes a compiler error! The compiler will think its a function.
</code></pre><a id=struct-init>In fact</a>, if you have a very simple data structure that uses only default constructors, you can use a shortcut for initializing its members. I haven&rsquo;t gone over classes and structs in C++ yet (See <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-3-classes-and/>Part 3</a>), but here is the syntax anyway:</p><p><pre class=language-cpp><code>struct Simple
{
  int a;
  int b;
  const char* str;
};

Simple instance = { 4, 5, &#34;Sparkles&#34; };
//instance.a is now 4
//instance.b is now 5
//instance.str is now &#34;Sparkles&#34;
</code></pre>All of these declare variables on the stack. C# actually does this with trivial datatypes like <code>int</code> and <code>double</code> that don&rsquo;t require a <code>new</code> statement to allocate, but otherwise forces you to use the Heap so its garbage collector can do the work.</p><p>Wait a minute, stack variables automatically destroy themselves when they go out-of-scope, but how do you delete variables allocated from the Heap? In C#, you didn&rsquo;t need to worry about this because of Garbage Collection, which everyone likes because it reduces memory leaks (but even I have still managed to cause a memory leak in C#). In C++, you must explicitly delete all your variables declared with the <code>new</code> keyword, and you must keep in mind which variables were declared as arrays and which ones weren&rsquo;t. In both C# and C++, there are two uses of the <code>new</code> keyword - instantiating a single object, and instantiating an array. In C++, there are also two uses of the <code>delete</code> keyword - deleting a single object and deleting an array. <strong>You cannot mix up <code>delete</code> statements!</strong></p><p><pre class=language-cpp><code>int* Fluffershy = new int();
int* ponies = new int[10];

delete Fluffershy; // Correct
//delete ponies; // WRONG, we should be using delete [] for ponies
delete [] ponies; // Just like this
//delete [] Fluffershy; // WRONG, we can&#39;t use delete [] on Fluffershy because we didn&#39;t
                        // allocate it as an array.

int* one = new int[1];

//delete one; // WRONG, just because an array only has one element doesn&#39;t mean you can
              // use the normal delete!
delete [] one; // You still must use delete [] because you used new [] to allocate it.
</code></pre>As you can see, it is much easier to deal with stack allocations, because they are automatically deallocated, even when the function terminates unexpectedly. <code>[std::auto_ptr](http://www.cplusplus.com/reference/std/memory/auto_ptr/)</code> takes advantage of this by taking ownership of a pointer and automatically deleting it when it is destroyed, so you can allocate the <code>auto_ptr</code> on the stack and benefit from the automatic destruction. However, in <code>C++0x</code>, this has been superseded by <code>[std::unique_ptr](http://msdn.microsoft.com/en-us/library/ee410601.aspx)</code>, which operates in a similar manner but uses some complex move semantics introduced in the new standard. I won&rsquo;t go into detail about how to use these here as its out of the scope of this tutorial. Har har har.</p><p>For those of you who like throwing exceptions, I should point out common causes of memory leaks. The most common is obviously just flat out forgetting to delete something, which is usually easily fixed. However, consider the following scenario:</p><p><pre class=language-cpp><code>void Kenny()
{
  int* kenny = new int();
  throw &#34;BLARG&#34;;
  delete kenny; // Even if the above exception is caught, this line of code is never reached.
}

int main(int argc, char* argv[])
{
  try {
  Kenny();
  } catch(char * str) { 
    //Gotta catch&#39;em all.
  }
  return 0; //We&#39;re leaking Kenny! o.O
}
</code></pre>Even this is fairly common:</p><p><pre class=language-cpp><code>int main(int argc, char* argv[])
{
  int* kitty = new int();

  *kitty=rand();
  if(*kitty==0)
    return 0; //LEAK
  
  delete kitty;
  return 0;
}
</code></pre>These situations <em>seem</em> obvious, but they will happen to you once the code becomes enormous. This is one reason you have to be careful when inside functions that are very large, because losing track of <code>if</code> statements may result in you forgetting what to delete. A good rule of thumb is to make sure you delete everything whenever you have a return statement. However, the opposite can also happen. If you are too vigilant about deleting everything, you might delete something you never allocated, which is just as bad:</p><p><pre class=language-cpp><code>int main(int argc, char* argv[])
{
  int* rarity = new int();
  int* spike;

  if(rarity==NULL)
  {
    spike=new int();
  }
  else
  {
    delete rarity;
    delete spike; // Suddenly, in an alternate dimension, earth ceased to exist
    return 0;
  }
  
  delete rarity; // Since this only happens if the allocation failed and returned a NULL
                 // pointer, this will also blow up.
  delete spike;
  return 0;
}
</code></pre>Clearly, one must be careful when dealing with allocating and destroying memory in C++. Its usually best to encapsulate as much as possible in classes that automate such things. But wait, what about that <code>NULL</code> pointer up there? Now that we&rsquo;re familiar with memory management, we&rsquo;re going to dig into pointers again, starting with the <code>NULL</code> pointer.</p><p>Since a pointer points to a piece of memory that&rsquo;s somewhere between 0 and 4294967295, what happens if its pointing at 0? Any pointer to memory location 0 <strong>is always invalid</strong>. All you need to know is that the operating system does some magic voodoo to ensure that any attempted access of memory location 0 will always throw an error, no matter what. 1, 2, 3, and any other double or single digit low numbers are also always invalid. <code>0xfdfdfdfd</code> is what the VC++ debugger sets uninitialized memory to, so that pointer location is also always invalid. A pointer set to 0 is called a <strong>Null Pointer</strong>, and is usually used to signify that a pointer is empty. Consequently if an allocation function fails, it tends to return a null pointer. Null pointers are returned when the operation failed and a valid pointer cannot be returned. Consequently, you may see this:</p><p><pre class=language-cpp><code>int main(int argc, char* argv[])
{
  int* blink = new int();
  if(blink!=0) delete blink;
  blink=0;
  return 0;
}
</code></pre>This is known as a <strong>safe deletion</strong>. It ensures that you only delete a pointer if it is valid, and once you delete the pointer you set the pointer to 0 to signify that it is invalid. Note that <code>NULL</code> is defined as 0 in the standard library, so you could also say <code>blink = NULL</code>.</p><p>Since pointers are just integers, we can do <strong>pointer arithmetic</strong>. What happens if you add 1 to a pointer? If you think of pointers as just integers, one would assume it would simply move the pointer forward a single byte.</p><div class=imgwrap style=max-width:486px><a href=/img/tut2.png target=_blank><img src=/img/tut2.png alt="Moving a Pointer 1 byte" width=100%></a></div><p>This isn&rsquo;t what happens. Adding 1 to a pointer of type <code>integer</code> results in the pointer moving forward 4 bytes.</p><div class=imgwrap style=max-width:486px><a href=/img/tut3.png target=_blank><img src=/img/tut3.png alt="Moving a Pointer 4 bytes" width=100%></a></div><p><strong>Adding or subtracting an integer $i$ from a pointer moves that pointer $i\cdot n$ bytes, where $n$ is the size, in bytes, of the pointer&rsquo;s type</strong>. This results in an interesting parallel - adding or subtracting from a pointer is the same as treating the pointer as an array and accessing it via an index.</p><p><pre class=language-cpp><code>int main(int argc, char* argv[])
{
  int* kitties = new int[14];
  int* a = &amp;kitties[7];
  int* b = kitties+7; //b is now the same as a
  int* c = &amp;a[4];
  int* d = b+4; //d is now the same as c
  int* e = &amp;kitties[11];
  int* f = kitties+11; 
  //c,d,e, and f now all point to the same location
}
</code></pre>So pointer arithmetic is identical to accessing a given index and taking the address. But what happens when you try to add two pointers together? Adding two pointers together is undefined because it tends to produce total nonsense. <em>Subtracting</em> two pointers, however, is defined, provided you subtract a smaller pointer from a larger one. The reason this is allowed is so you can do this:</p><p><pre class=language-cpp><code>int main(int argc, char* argv[])
{
  int* eggplants = new int[14];
  int* a = &amp;eggplants[7];
  int* b = eggplants+10;
  int diff = b-a; // Diff is now equal to 3
  a += (diff*2); // adds 6 to a, making it point to eggplants[13]
  diff = a-b; // diff is again equal to 3
  diff = a-eggplants; //diff is now 13
  ++a; //The increment operator is valid on pointers, and operates the same way a += 1 would
  // So now a points to eggplants[14], which is not a valid location, but this is still
  // where the &#34;end&#34; of the array technically is.
  diff = a-eggplants; // Diff now equals 14, the size of the array
  --b; // Decrement works too
  diff = a-b; // a is pointing to index 14, b is pointing to 9, so 14-9 = 5. Diff is now 5.
  return 0;
}
</code></pre>There is a mistake in the code above, can you spot it? I used a <em>signed</em> <code>integer</code> to store the difference between the two pointers. What if one pointer was above 2147483647 and the other was at 0? The difference would overflow! Had I used an unsigned integer to store the difference, I&rsquo;d have to be really damn sure that the left pointer was larger than the right pointer, or the negative value would <em>also</em> overflow. This complexity is why you have to goad windows into letting your program deal with pointer sizes over 2147483647.</p><p>In addition to arithmetic, one can compare two pointers. We already know we can use <code>==</code> and <code>!=</code>, but we can also use <code>&lt; > &lt;=</code> and <code>>=</code>. While you can get away with comparing two completely unrelated pointers, these comparison operators are usually used in a context like the following:</p><p><pre class=language-cpp><code>int main(int argc, char* argv[])
{
  int* teapots = new int[15];
  int* end = teapots+15;
  for(int* s = teapots; s&lt;end; ++s)
    *s = 0;
  return 0;
}
</code></pre>Here the for loop increments the pointer itself rather than an index, until the pointer reaches the end, at which point it terminates. But, what if you had a pointer that didn&rsquo;t have any type at all? <code>void*</code> is a legal pointer type, that any pointer type can be implicitly converted to. You can also explicitly cast <code>void*</code> to any pointer type you want, which is why you are allowed to explicitly cast any pointer type to another pointer type (<code>int* p; short* q = (short*)p;</code> is entirely legal). Doing so, however, is obviously dangerous. <code>void*</code> has its own problems, namely, how big is it? The answer is, you don&rsquo;t know. <strong>Any attempt to use any kind of pointer arithmetic with a <code>void*</code> pointer will cause a compiler error</strong>. It is most often used when copying generic chunks of memory that only care about size in bytes, and not what is actually contained in the memory, like <code>memcpy()</code>.</p><p><pre class=language-cpp><code>int main(int argc, char* argv[])
{
  int* teapots = new int[15];
  void* p = (void*)teapots;
  p++; // compiler error
  unsigned short* d = (unsigned short*)p;
  d++; // No compiler error, but you end up pointing to half an integer
  d = (unsigned short*)teapots; // Still valid
  return 0;
}
</code></pre>Now that we know all about pointer manipulation, we need to look at pointers to pointers, and to anchor this in a context that actually makes sense, we need to look at how C++ does <strong>multidimensional arrays</strong>. In C#, <a href="http://msdn.microsoft.com/en-us/library/2yd9wwz4(v=vs.71).aspx">multidimensional arrays</a> look like this:</p><p><pre class=language-csharp><code>int[,] table = new int[4,5];
</code></pre>C++ has a different, but fairly reasonable stack-based syntax. When you want to declare a multidimensional array <em>on the heap</em>, however, things start getting <em>weird</em>:</p><p><pre class=language-cpp><code>int unicorns[5][3]; // Well this seems perfectly reasonable, I wonder what-
  int (*cthulu)[50] = new int[10][50]; // OH GOD GET IT AWAY GET IT AWAAAAAY...!
  int c=5;
  int (*cthulu)[50] = new int[c][50]; // legal
  //int (*cthulu)[] = new int[10][c]; // Not legal. Only the leftmost parameter
                                      // can be variable
  //int (*cthulu)[] = new int[10][50]; // This is also illegal, the compiler is not allowed
                                       // to infer the constant length of the array.
</code></pre>Why isn&rsquo;t the multidimensional array here just an <code>int**</code>? Clearly if <code>int* x</code> is equivalent to <code>int x[]</code>, shouldn&rsquo;t <code>int** x</code> be equivalent to <code>int x[][]</code>? Well, it <em>is</em> - just look at the <code>main()</code> function, its got a multidimensional array in there that can be declared as just <code>char** argv</code>. The problem is that there are two kinds of multidimensional arrays - <strong>square</strong> and <strong>jagged</strong>. While both are accessed in identical ways, how they work is fundamentally different.</p><p>Let&rsquo;s look at how one would go about allocating a 3x5 square array. We can&rsquo;t allocate a 3x5 chunk out of our computer&rsquo;s memory, because memory isn&rsquo;t 2-dimensional, its 1-dimensional. Its just freaking huge line of bytes. Here is how you squeeze a 2-dimensional array into a 1-dimensional line:</p><div class=imgwrap style=max-width:727px><a href=/img/tut4.png target=_blank><img src=/img/tut4.png alt="Allocating a 3x5 array" width=100%></a></div><p>As you can see, we just allocate each row right after the other to create a 15-element array ($5\cdot 3 = 15$). But then, how do we access it? Well, if it has a width of 5, to access another &ldquo;row&rdquo; we&rsquo;d just skip forward by 5. In general, if we have an $n$ by $m$ multidimensional array being represented as a one-dimensional array, the proper index for a coordinate $(x,y)$ is given by: <code>array[x + (y*n)]</code>. This can be extended to 3D and beyond but it gets a little messy. This is all the compiler is really doing with multidimensional array syntax - just automating this for you.</p><p>Now, if this is a <strong>square</strong> array (as evidenced by it being a square in 2D or a cube in 3D), a jagged array is one where each array is a different size, resulting in a &ldquo;jagged&rdquo; appearance:</p><div class=imgwrap style=max-width:320px><a href=/img/tut5.png target=_blank><img src=/img/tut5.png alt="Jagged array visualization" width=100%></a></div><p>We can&rsquo;t possibly allocate this in a single block of memory unless we did a lot of crazy ridiculous stuff that is totally unnecessary. However, given that arrays in C++ are just pointers to a block of memory, what if you had a pointer to a block of memory that was an array of pointers to more blocks of memory?</p><div class=imgwrap style=max-width:400px><a href=/img/tut6.png target=_blank><img src=/img/tut6.png alt="Jagged array pointers" width=100%></a></div><p>Suddenly we have our jagged array that can be accessed just like our previous arrays. It should be pointed out that with this format, each inner-array can be in a totally random chunk of memory, so the last element could be at position 200 and the first at position 5 billion. Consequently, pointer arithmetic only makes sense within each column. Because this is an array of arrays, we declare it by creating an array of pointers. This, however, does <strong>not</strong> initialize the entire array; all we have now is an array of <em>illegal pointers</em>. Since each array could be a different size than the other arrays (this being the entire point of having a jagged array in the first place), the only possible way of initializing these arrays is individually, often by using a <code>for loop</code>. Luckily, the syntax for accessing jagged arrays is the exact same as with square arrays.</p><p><pre class=language-cpp><code>int main(int argc, char* argv[])
{
  int** jagged = new int*[5]; //Creates an array of 5 pointers to integers.
  for(int i = 0; i &lt; 5; ++i)
  {
    jagged[i] = new int[3+i]; //Assigns each pointer to a new array of a unique size
  }
  jagged[4][1]=0; //Now we can assign values directly, or...
  int* second = jagged[2]; //Pull out one column, and
  second[0]=0; //manipulate it as a single array

  // The double-access works because of the order of operations. Since [] is just an
  // operator, it is evaluated from left to right, like any other operator. Here it is
  // again, but with the respective types that each operator resolves to in parenthesis.
  ( (int&amp;) ( (int*&amp;) jagged[4] ) [1] ) = 0;
}
</code></pre>As you can see above, just like we can have pointers to pointers, we can also have references to pointers, since pointers are just another data type. This allows you to re-assign pointer values inside jagged arrays, like so: <code>jagged[2] = (int*)kitty</code>. However, until <code>C++0x</code>, those references didn&rsquo;t have any meaningful data type, so even though the compiler was using <code>int*&</code>, using that in your code will throw a compiler error in older compilers. If you need to make your code work in non-<code>C++0x</code> compilers, you can simply avoid using references to pointers and instead use a pointer to a pointer.<pre class=language-cpp><code>int* bunny;
int* value = new int[5];

int*&amp; bunnyref = bunny; // Throws an error in old compilers
int** pbunny = &amp;bunny; // Will always work
bunnyref = value; // This does the same exact thing as below.
*pbunny = value;

// bunny is now equal to value
</code></pre>This also demonstrates the other use of a pointer-to-pointer data type, allowing you to remotely manipulate a pointer just like a pointer allows you to remotely manipulate an integer or other value type. So obviously you can do pointers to pointers to pointers to pointers to an absurd degree of lunacy, but this is <em>exceedingly rare</em> so you shouldn&rsquo;t need to worry about it. Now you should be strong in the art of pointer-fu, so our next tutorial will finally get into object-oriented techniques in C++ in comparison to C#. <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-3-classes-and/>Part 3: Classes and Structs and Inheritance OH MY!</a></p></div><hr><time itemprop=datePublished pubdate=pubdate datetime=2011-07-21T19:35:00+00:00><i class="fa-regular fa-clock fa-fw"></i>&nbsp;Published on <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-2-pointers/>July 21, 2011 at 7:35pm</a></time><aside><i class="fa-regular fa-share-square fa-fw"></i>&nbsp;share:<ul><li><a href="javascript:window.open('https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ferikmcclure.com%2fblog%2fc-to-c-tutorial-part-2-pointers%2f','popup','width=600,height=400');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" d="M16.75 9H13.5V7a1 1 0 011-1h2V3H14a4 4 0 00-4 4V9H8v3h2v9h3.5V12H16z"/></svg></a><li><a href="javascript:window.open('https://twitter.com/intent/tweet?text=C%23%20to%20C%2b%2b%20Tutorial%20-%20Part%202%3a%20Pointers%20Everywhere%21&url=https%3a%2f%2ferikmcclure.com%2fblog%2fc-to-c-tutorial-part-2-pointers%2f','popup','width=600,height=256');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" opacity="0" d="M0 0h24v24H0z"/><path class="st0" d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572.0-4.658 2.086-4.658 4.66.0.364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342.0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3.0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376.0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57.0 13.255-7.098 13.255-13.254.0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg></a></li><li><a href="javascript:window.open('https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2ferikmcclure.com%2fblog%2fc-to-c-tutorial-part-2-pointers%2f','popup','width=700,height=380');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><rect class="st0" height="11" width="4" x="3" y="9"/><circle class="st0" cx="5" cy="5" r="2"/><path class="st0" d="M16.5 8.25A4.47251 4.47251.0 0013 9.95343V9H9V20h4V13a2 2 0 014 0v7h4V12.75a4.5 4.5.0 00-4.5-4.5z"/></svg></a></li></ul></aside></article><article><a name=comments><h4>Comments</h4></a><hr><div class=comments><div id=c3212571582671363438><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//3.bp.blogspot.com/_8FNTTrcVylU/SR2vD1xQNHI/AAAAAAAAACU/9efOqRGDHiQ/S220-s32/jheatt+copy.jpg alt>
<b>Jhott</b><p>What about pointers to functions? I'm having trouble understanding why this doesn't work:<br><br><br>char* Test()<br>{<br>char cstm[] = { 'T', 'E', 'S', 'T', '\n' };<br>return cstm;<br>}<br><br>int _tmain(int argc, _TCHAR* argv[])<br>{<br>char* (*funcP)() = &amp;Test;<br>char* convPntr = (*funcP)();<br><br>//Why don't I see a "T" on the screen?<br>::printf("Character: %c", convPntr[0]);<br>}</p></div><hr><div id=c5869540101005377245><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//1.bp.blogspot.com/-K3nGMEbXbqI/Tg5QXhNWUNI/AAAAAAAAAGA/OmzJ8Trn7ZI/s32/avvy7_5.png alt>
<b>Erik McClure</b><p>I have deliberately not covered pointers to functions yet. I intend to cover them by comparing them to C# delegates at a later point.<br><br>As for why you don't see a 'T' on the screen, it has nothing to do with function pointers - You are not thinking with the stack. You must remember that all functions are scopes. This is easy to remember because anything inside { } is a scope, and that includes a function. That means, like all other scopes, any variable declared on the stack inside a function ceases to exist outside of that function. Your code here is referencing a variable that no longer exists. You can't return a pointer to a variable declared on the stack inside a function because once the function exits, cstm[] no longer exists because it is now out of scope, so the pointer is pointing to garbage memory.</p></div><hr><div id=c2546076055383486290><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//1.bp.blogspot.com/-K3nGMEbXbqI/Tg5QXhNWUNI/AAAAAAAAAGA/OmzJ8Trn7ZI/s32/avvy7_5.png alt>
<b>Erik McClure</b><p>Also your string doesn't have a null terminator, either, which is an even more elementary problem. This is why you usually don't use an array on the stack to store strings, you just define a constant "TEST\n" and throw around a pointer to it, which the compiler does for you when you say const char* val="TEST\n";</p></div><hr><div id=c8112796726293723087><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//3.bp.blogspot.com/_8FNTTrcVylU/SR2vD1xQNHI/AAAAAAAAACU/9efOqRGDHiQ/S220-s32/jheatt+copy.jpg alt>
<b>Jhott</b><p>Thanks for the explanation... I see my problem now. If I would have placed the return value of Test() in a character var instead of a pointer, that would have worked, right? Because then it would take the return value of the Test() function and copy it to the character var before "cstm" itself goes out of scope.<br><br>I didn't understand why you said my string doesn't have a null terminator though...?<br><br>char cstm[] = { 'T', 'E', 'S', 'T', '\n' };<br><br>I defined the last character as a null terminator?</p></div><hr><div id=c2922828990789017736><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//1.bp.blogspot.com/-K3nGMEbXbqI/Tg5QXhNWUNI/AAAAAAAAAGA/OmzJ8Trn7ZI/s32/avvy7_5.png alt>
<b>Erik McClure</b><p>'\n' is a newline character. '\0' or simply 0 is a null terminator.</p></div><hr><div id=c6073057482392914812><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//3.bp.blogspot.com/_8FNTTrcVylU/SR2vD1xQNHI/AAAAAAAAACU/9efOqRGDHiQ/S220-s32/jheatt+copy.jpg alt>
<b>Jhott</b><p>lol.... yes, I feel like an idiot.</p></div><hr><div id=c4357224406632415270><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src="//lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35" alt>
<b>lingmaaki</b><p>More.....<a href=http://net-informations.com/faq/oops/pointers.htm rel=nofollow>Is there pointer in C# like C or C++ ?</a><br><br>Ling<br></p></div></div><div class=comments></div><hr><div class=wrapcommento><div id=commento></div><script src=https://cdn.commento.io/js/commento.js></script></div></form></article></section><section class=archive><article><img src=https://erikmcclure.com/img/avatar.th.png alt=Avatar width=180 height=180><h2>Archive</h2><ol><li><details><summary>2025</summary><ul><li><a href=/blog/discord-overlay-breaks-gsync/>The New Discord Overlay Breaks GSync and Borderless Optimizations</a></li><li><a href=/blog/do-you-really-think-we-have-gender-in-the-future/>Do You Really Think We'll Have Genders In The Future?</a></li></ul></details></li><li><details><summary>2024</summary><ul><li><a href=/blog/stop-making-me-memorize-borrow-checker/>Stop Making Me Memorize The Borrow Checker</a></li><li><a href=/blog/rust-async-makes-me-want-to-gouge-my-eyes-out/>Rust Async Makes Me Want To Gouge My Eyes Out</a></li><li><a href=/blog/engineers-only-get-paid-something-broken/>Engineers Only Get Paid If Something Is Broken</a></li><li><a href=/blog/measuring-competence-is-epistemic-hell/>Measuring Competence Is Epistemic Hell</a></li><li><a href=/blog/we-could-fix-everything-we-just-dont/>We Could Fix Everything, We Just Don't</a></li></ul></details></li><li><details><summary>2023</summary><ul><li><a href=/blog/people-cant-care-about-everything/>People Can't Care About Everything</a></li><li><a href=/blog/discord-should-remove-usernames/>Discord Should Remove Usernames Entirely</a></li></ul></details></li><li><details><summary>2022</summary><ul><li><a href=/blog/money-is-fake/>Money Is Fake. It's Not Real. It's Made Up.</a></li><li><a href=/blog/we-need-new-motherboards/>We Need New Motherboards Before GPUs Collapse Under Their Own Gravity</a></li></ul></details></li><li><details><summary>2021</summary><ul><li><a href=/blog/cpp-constructors-memory-and-lifetimes/>C++ Constructors, Memory, and Lifetimes</a></li><li><a href=/blog/factorio-is-best-interview-we-have/>Factorio Is The Best Technical Interview We Have</a></li></ul></details></li><li><details><summary>2020</summary><ul><li><a href=/blog/why-you-cant-use-prebuilt-llvm-with-cpp17/>Why You Can't Use Prebuilt LLVM 10.0 with C++17</a></li><li><a href=/blog/pressure-based-anti-spam-for-discord-bots/>Pressure Based Anti-Spam for Discord Bots</a></li></ul></details></li><li><details><summary>2019</summary><ul><li><a href=/blog/name-shadowing-should-be-an-operator/>Name Shadowing Should Be An Operator</a></li><li><a href=/blog/a-rant-on-terra/>A Rant On Terra</a></li><li><a href=/blog/risc-is-fundamentally-unscalable/>RISC Is Fundamentally Unscalable</a></li></ul></details></li><li><details><summary>2018</summary><ul><li><a href=/blog/migrating-to-static-blog/>Migrating To A Static Blog</a></li><li><a href=/blog/how-to-avoid-memorizing-times-tables/>How To Avoid Memorizing Times Tables</a></li></ul></details></li><li><details><summary>2017</summary><ul><li><a href=/blog/ignoring-outliers-creates-racist/>Ignoring Outliers Creates Racist Algorithms</a></li><li><a href=/blog/i-used-to-want-to-work-for-google/>I Used To Want To Work For Google</a></li><li><a href=/blog/integrating-luajit-and-autogenerating-c/>Integrating LuaJIT and Autogenerating C Bindings In Visual Studio</a></li><li><a href=/blog/discord-rise-of-bot-wars/>Discord: Rise Of The Bot Wars</a></li><li><a href=/blog/companies-cant-be-apolitical/>Companies Can't Be Apolitical</a></li><li><a href=/blog/windows-wont-let-my-program-crash/>Windows Won't Let My Program Crash</a></li><li><a href=/blog/directx-is-terrifying/>DirectX Is Terrifying</a></li></ul></details></li><li><details><summary>2016</summary><ul><li><a href=/blog/everyone-does-srgb-wrong-because/>Everyone Does sRGB Wrong Because Everyone Else Does sRGB Wrong</a></li><li><a href=/blog/mathematical-notation-is-awful/>Mathematical Notation Is Awful</a></li></ul></details></li><li><details><summary>2015</summary><ul><li><a href=/blog/i-tried-to-install-linux-and-now-i/>I Tried To Install Linux And Now I Regret Everything</a></li><li><a href=/blog/you-arent-designing-software-for-robots/>We Aren't Designing Software For Robots</a></li><li><a href=/blog/using-data-to-balance-your-game-pony/>Using Data To Balance Your Game: Pony Clicker Analysis</a></li><li><a href=/blog/does-anyone-actually-want-good-software/>Does Anyone Actually Want Good Software?</a></li></ul></details></li><li><details><summary>2014</summary><ul><li><a href=/blog/how-not-to-sell-software/>How Not To Install Software</a></li><li><a href=/blog/can-we-choose-what-we-enjoy/>Can We Choose What We Enjoy?</a></li><li><a href=/blog/how-to-make-your-profiler-10x-faster/>How To Make Your Profiler 10x Faster</a></li><li><a href=/blog/the-problem-with-photorealism/>The Problem With Photorealism</a></li></ul></details></li><li><details><summary>2013</summary><ul><li><a href=/blog/googles-decline-really-bugs-me/>Google's Decline Really Bugs Me</a></li><li><a href=/blog/the-educational-imbroglio/>The Educational Imbroglio</a></li><li><a href=/blog/write-less-code/>Write Less Code</a></li><li><a href=/blog/most-people-have-shitty-computers/>Most People Have Shitty Computers</a></li><li><a href=/blog/leap-motion-impressions-input/>Leap Motion Impressions, Input Sanitation, and 3D Gesture Ideas</a></li><li><a href=/blog/aurora-theory-released/>Aurora Theory Released!</a></li><li><a href=/blog/what-i-learned-in-college/>What I Learned In College</a></li><li><a href=/blog/course-notes/>Course Notes</a></li><li><a href=/blog/contact/>Contact</a></li><li><a href=/blog/the-dark-side-of-htmlcss/>The Dark Side of Web Development</a></li><li><a href=/blog/windows-breaks-assert-inside/>Windows Breaks assert() Inside WM_CANCELMODE</a></li><li><a href=/blog/the-productivity-fallacy/>The Productivity Fallacy</a></li></ul></details></li><li><details><summary>2012</summary><ul><li><a href=/blog/c-to-c-tutorial-part-4-operator-overload/>C# to C++ Tutorial - Part 4: Operator Overload</a></li><li><a href=/blog/7-problems-raytracing-doesnt-solve/>7 Problems Raytracing Doesn't Solve</a></li><li><a href=/blog/analyzing-xkcd-click-and-drag/>Analyzing XKCD: Click and Drag</a></li><li><a href=/blog/coordinate-systems-and-cascading/>Coordinate Systems And Cascading Stupidity</a></li><li><a href=/blog/how-joysticks-ruined-my-graphics-engine/>How Joysticks Ruined My Graphics Engine</a></li><li><a href=/blog/multithreading-problems-in-game-design/>Multithreading Problems In Game Design</a></li><li><a href=/blog/stop-following-rules/>Stop Following The Rules</a></li><li><a href=/blog/why-windows-8-does-right-thing-wrong/>Why Windows 8 Does The Right Thing The Wrong Way</a></li><li><a href=/blog/visual-studio-broke-my-computer/>Visual Studio Broke My Computer</a></li><li><a href=/blog/implicit-ui-design/>Implicit UI Design</a></li><li><a href=/blog/linux-mint-12-kde/>Linux Mint 12 KDE</a></li><li><a href=/blog/new-post/>'Programmer' is an Overgeneralization</a></li></ul></details></li><li><details><summary>2011</summary><ul><li><a href=/blog/great-mystery-of-linear-gradient/>The Great Mystery of Linear Gradient Lighting</a></li><li><a href=/blog/signed-integers-considered-stupid-like/>Signed Integers Considered Stupid (Like This Title)</a></li><li><a href=/blog/c-to-c-tutorial-part-3-classes-and/>C# to C++ Tutorial - Part 3: Classes and Structs and Inheritance (OH MY!)</a></li><li><a href=/blog/problem-of-vsync/>The Problem of Vsync</a></li><li><a href=/blog/c-to-c-tutorial-part-2-pointers/>C# to C++ Tutorial - Part 2: Pointers Everywhere!</a></li><li><a href=/blog/c-to-c-tutorial-part-1-basics-of-syntax/>C# to C++ Tutorial - Part 1: Basics of Syntax</a></li><li><a href=/blog/ninth-circle-of-bugs/>The Ninth Circle of Bugs</a></li><li><a href=/blog/investigating-low-level-cpu-performance/>Investigating Low-level CPU Performance</a></li></ul></details></li><li><details><summary>2010</summary><ul><li><a href=/blog/im-failure/>The IM Failure</a></li><li><a href=/blog/album-for-sale-renascent/>Album For Sale! [Renascent]</a></li><li><a href=/blog/wavsaver/>WavSaver</a></li><li><a href=/blog/pixel-perfect-hit-testing/>Pixel Perfect Hit Testing</a></li><li><a href=/blog/8-bit-color-cycling/>8-bit color cycling</a></li><li><a href=/blog/physics-networking/>Physics Networking</a></li><li><a href=/blog/assembly-cas-implementation/>Assembly CAS implementation</a></li><li><a href=/blog/function-pointer-speed/>Function Pointer Speed</a></li><li><a href=/blog/most-bizarre-error-ever/>Most Bizarre Error Ever</a></li></ul></details></li><li><details><summary>2009</summary><ul><li><a href=/blog/physics-oriented-network-interpolation/>Physics-oriented Network Interpolation</a></li></ul></details></li></ol></article></section></main><footer><p><span>Copyright &copy;2025 Erik McClure</span> <a href=https://erikmcclure.com/sitemap.xml>Sitemap</a> | <a href=https://erikmcclure.com/blog/index.xml>RSS Feed</a></p></footer></div><script>"use strict";window.onload=function(){e=document.getElementsByClassName("math");for(var e,t=0,n=e.length;t<n;t++)renderMathInElement(e[t],{delimiters:[{left:"$$",right:"$$",display:!1},{left:"\\[",right:"\\]",display:!0}]})}</script></body></html>