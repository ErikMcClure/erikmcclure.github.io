<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=Edge"><meta http-equiv=permissions-policy content="interest-cohort=()"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#2b7bb5"><meta name=copyright content="Copyright (c)2024 Erik McClure"><meta name=keywords content="games,music,code,erik mcclure,erikmcclure,aurora theory,sweetie bot,discord,feathergui,fading light,tinyoal,cloud hop"><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"><meta name=google-site-verification content="Oxb2ia8HjcHLXlvstA8xPpQO3BO_y15Ds2Ia-feq1MQ"><meta name=generator content="Hugo 0.119.0"><link rel=me href=https://equestria.social/@cloudhop><link rel=canonical href=https://erikmcclure.com/blog/c-to-c-tutorial-part-4-operator-overload/><link rel=apple-touch-icon href=https://erikmcclure.com/favicon.ico><link rel="shortcut icon" type=image/x-icon href=https://erikmcclure.com/favicon.ico><link rel=stylesheet href=https://erikmcclure.com/css/main.css><link rel=stylesheet href=https://erikmcclure.com/css/prism.css rel=stylesheet><link rel=stylesheet href=https://erikmcclure.com/css/katex.min.css rel=stylesheet><link rel=stylesheet href=https://erikmcclure.com/css/fontawesome.min.css><link rel=stylesheet href=https://erikmcclure.com/css/regular.min.css><link rel=stylesheet href=https://erikmcclure.com/css/brands.min.css><link rel=stylesheet href=https://erikmcclure.com/css/solid.min.css><link rel=alternate type=application/rss+xml title="Erik McClure - RSS" href=https://erikmcclure.com/blog/index.xml><meta property="og:type" content="article"><title>C# to C++ Tutorial - Part 4: Operator Overload</title><meta property="og:title" content="C# to C++ Tutorial - Part 4: Operator Overload"><meta name=twitter:title content="C# to C++ Tutorial - Part 4: Operator Overload"><meta itemprop=name content="C# to C++ Tutorial - Part 4: Operator Overload"><meta name=description content="[ 1 · 2 · 3 · 4 · 5 · 6 · 7 ]
If you are familiar with C#, you should be familiar with the difference between C#&rsquo;s struct and class declarations. Namely, a struct is a value type and a class is a reference type, meaning that if you pass a struct to a function, its default behavior is for the entire struct to be copied into the function&rsquo;s parameter, so any modifications made to it won&rsquo;t affect whatever was passed in."><meta property="og:description" content="[ 1 · 2 · 3 · 4 · 5 · 6 · 7 ]
If you are familiar with C#, you should be familiar with the difference between C#&rsquo;s struct and class declarations. Namely, a struct is a value type and a class is a reference type, meaning that if you pass a struct to a function, its default behavior is for the entire struct to be copied into the function&rsquo;s parameter, so any modifications made to it won&rsquo;t affect whatever was passed in."><meta name=twitter:description content="[ 1 · 2 · 3 · 4 · 5 · 6 · 7 ]
If you are familiar with C#, you should be familiar with the difference between C#&rsquo;s struct and class declarations. Namely, a struct is a value type and a class is a reference type, meaning that if you pass a struct to a function, its default behavior is for the entire struct to be copied into the function&rsquo;s parameter, so any modifications made to it won&rsquo;t affect whatever was passed in."><meta itemprop=description content="[ 1 · 2 · 3 · 4 · 5 · 6 · 7 ]
If you are familiar with C#, you should be familiar with the difference between C#&rsquo;s struct and class declarations. Namely, a struct is a value type and a class is a reference type, meaning that if you pass a struct to a function, its default behavior is for the entire struct to be copied into the function&rsquo;s parameter, so any modifications made to it won&rsquo;t affect whatever was passed in."><meta property="og:url" content="https://erikmcclure.com/"><meta property="og:site_name" content="Erik McClure"><meta property="og:image" content="https://erikmcclure.com/img/avatar.png"><meta property="og:locale" content="en-US"><meta property="article:author" content="Erik McClure"><meta name=twitter:card content="summary"><meta name=twitter:site content="@erikmcclure0173"><meta name=twitter:creator content="@erikmcclure0173"><meta name=twitter:image content="https://erikmcclure.com/img/avatar.png"><meta name=twitter:dnt content="on"><link href=https://plus.google.com/104896885003230920472 rel=publisher><meta itemprop=image content="https://erikmcclure.com/img/avatar.png"><meta name=last-updated content="20121020-11:16:00.000"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-63026815-3"></script>
<script defer src=https://erikmcclure.com/syntax-prism.js></script>
<script defer src=https://erikmcclure.com/katex.min.js></script>
<script defer src=https://erikmcclure.com/mathtex-script-type.min.js></script>
<script defer src=https://erikmcclure.com/auto-render.min.js></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-63026815-3")</script></head><body><div id=container><header><nav><ul><li><a href=/blog/ title=Blog><i class="fa-solid fa-book fa-fw fa-lg"></i>&nbsp;<p>Blog</p></a></li><li><a href=/projects/ title=Projects><i class="fa-solid fa-briefcase fa-fw fa-lg"></i>&nbsp;<p>Projects</p></a></li><li><a href=https://erikmcclure.bandcamp.com title=Bandcamp><i class="fa-brands fa-bandcamp fa-fw fa-lg"></i>&nbsp;<p>Bandcamp</p></a></li><li><a href=https://github.com/erikmcclure title=Github><i class="fa-brands fa-github fa-fw fa-lg"></i>&nbsp;<p>Github</p></a></li><li><a href=/web/ title=Websites><i class="fa-solid fa-globe fa-fw fa-lg"></i>&nbsp;<p>Websites</p></a></li></ul></nav><div class=dim><h1>Erik McClure</h1></div></header><main class=blog><section><meta itemprop=mainEntityOfPage itemtype=https://schema.org/WebPage content="https://erikmcclure.com/"><meta itemprop=dateModified content="2012-10-20T11:16:00+00:00"><meta itemprop=headline content="C# to C++ Tutorial - Part 4: Operator Overload"><meta itemprop=description content="[ 1 · 2 · 3 · 4 · 5 · 6 · 7 ]
If you are familiar with C#, you should be familiar with the difference between C#&rsquo;s struct and class declarations. Namely, a struct is a value type and a class is a reference type, meaning that if you pass a struct to a function, its default behavior is for the entire struct to be copied into the function&rsquo;s parameter, so any modifications made to it won&rsquo;t affect whatever was passed in."><meta itemprop=url content="https://erikmcclure.com/blog/c-to-c-tutorial-part-4-operator-overload/"><div itemprop=publisher itemscope itemtype=https://schema.org/Organization><div itemprop=logo itemscope itemtype=https://schema.org/ImageObject><meta itemprop=url content="https://erikmcclure.com/img/avatar.png"><meta itemprop=width content="140"><meta itemprop=height content="140"></div><meta itemprop=name content="Erik McClure"></div><div itemprop=author itemscope itemtype=https://schema.org/Person><meta itemprop=name content="Erik McClure"></div><article><h4>C# to C++ Tutorial - Part 4: Operator Overload</h4><hr><div class=padding><p>[ <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-1-basics-of-syntax/>1</a> · <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-2-pointers/>2</a> · <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-3-classes-and/>3</a> · <strong>4</strong> · <span style=color:#aaa>5 · 6 · 7</span> ]</p><p>If you are familiar with C#, you should be familiar with the difference between C#&rsquo;s <code>struct</code> and <code>class</code> declarations. Namely, a <code>struct</code> is a value type and a <code>class</code> is a reference type, meaning that if you pass a struct to a function, its default behavior is for the entire struct to be <strong>copied</strong> into the function&rsquo;s parameter, so any modifications made to it won&rsquo;t affect whatever was passed in. On the flip side, a class is a reference value, so a <strong>reference</strong> is passed into the function, and any changes made to that reference will be reflected in the object that was originally passed into the function.</p><p><pre class=language-csharp><code>// Takes an integer, or a basic value type
public static int add(int v)
{
  v+=3;
  return 4+v;
}

public struct Oppa
{
  public string gangnam;
}

// Takes a struct, or a complex value type
public static Oppa style(Oppa g)
{
  g.gangnam=&#34;notstyle&#34;;
  return g;
}

public class Psy
{
  public int style;
}

// Takes a class, or a reference type
public static void change(Psy psy)
{
  psy.style=5;
}

// Takes an integer, but forces it to be passed by reference instead of by value.
public static int addref(ref int v)
{
  v+=3;
  return 4+v;
}

int a = 0;
int b = add(a);
// a is still 0
// b is now 7

int c = addref(a);
// a is now 3, because it was passed by reference
// c is now 7

Oppa s1;
s1.gangnam=&#34;style&#34;;
Oppa s2 = style(s1);
//s1.gangnam is still &#34;style&#34;
//s2.gangnam is now &#34;notstyle&#34;

Psy psy = new Psy();
psy.style=0;
change(psy);
// psy.style is now 5, because it was passed by reference
</code></pre>C++ also lets you pass in parameters by reference and by value, however it is more explicit about what is happening, so there is no default behavior to know about. If you simply declare the type itself, for example <code>(myclass C, int B)</code>, then it will be passed by value and copied. If, however, you use the reference symbol that we&rsquo;ve used before in variable declarations, it will be passed by reference. This happens no matter what. If a reference is passed into a function that takes a value, it will still have a copy made.</p><p><pre class=language-cpp><code>// Integer passed by value
int add(int v)
{
  v+=3;
  return 4+v;
}

class Psy
{
public:
  int style;
};

// Class passed by value
Psy change(Psy psy)
{
  psy.style=5;
  return psy;
}

// Integer passed by reference
int addref(int&amp; v)
{
  v+=3;
  return 4+v;
}

// Class passed by reference
Psy changeref(Psy&amp; psy)
{
  psy.style=5;
  return psy;
}

int horse = 2;
int korea = add(horse);
// horse is still 2
// korea is now 9

int horse2 = 2;
int korea2 = addref(horse2);
// horse2 is now 5
// korea2 is now 9

Psy psy;
psy.style = 0;
Psy ysp = change(psy);
// psy.style is still 0
// ysp.style is now 5

Psy psy2;
psy2.style = 0;
Psy ysp2 = changeref(psy2);
// psy2.style is now 5
// ysp2.style is also 5
</code></pre>However, in order to copy something, C++ needs to know how to properly copy your class. This gives rise to the <strong>copy constructor</strong>. By default, the compiler will automatically generate a copy constructor for your class that simply invokes all the default copy constructors of whatever member variables you have, just like C#. If, however, your class is holding on to a pointer, then this is going to cause a giant mess when two classes are pointing to the same thing and one of the deletes what it&rsquo;s pointing to! By specifying a copy constructor, we can deal with the pointer properly:</p><p><pre class=language-cpp><code>class myString
{
public:
  // The copy constructor, which copies the string over instead of copying the pointer
  myString(const myString&amp; copy)
  {
    size_t len = strlen(copy._str)+1; //+1 for null terminator
    _str=new char[len];
    memcpy(_str,copy._str,sizeof(char)*len);
  }
  // Normal constructor
  myString(const char* str)
  {
    size_t len = strlen(str);
    _str=new char[len];
    memcpy(_str,str,sizeof(char)*len);
  }
  // Destructor that deallocates our string
  ~myString()
  {
    delete [] _str;
  }

private:
  char* _str;
};

</code></pre>This copy constructor can be invoked manually, but it will simply be implicitly called whenever its needed. Of course, that isn&rsquo;t the only time we need to deal with our rogue pointer that screws things up. What happens when we set our class equal to another class? Remember, <strong>a reference cannot be changed after it is created</strong>. Observe the following behavior:</p><p><pre class=language-cpp><code>int a = 3;
int b = 2;
int&amp; ra = a;
int* pa = &amp;a;

b = a; //b is now 3
a = 0; //b is still 3, but a is now 0
b = ra; // b is now 0
a = 5; // b is still 0 but now a is 5
b = *pa; // b is now 5
b = 8; // b is now 8 but a is still 5

ra = b; //a is now 8! This assigns b&#39;s values to ra, it does NOT change the reference!
ra = 9; //a is now 9, and b is still 8! ra STILL refers to a, and NOTHING can change that.

pa = &amp;b; // Now pa points to to b
a = *pa; // a is now 8, because pointers CAN be changed.
*pa = 7; // Now b is 7, but a is still 8

int*&amp; rpa = pa; //Now we have a reference to a pointer (C++11)
//rpa = 5; // COMPILER ERROR, rpa is a reference to a POINTER
int** ppa = &amp;pa;
//rpa = ppa; // COMPILER ERROR, rpa is a REFERENCE to a pointer, not a pointer to a pointer!
rpa = &amp;a; //now pa points to a again. This does NOT change the reference!
b = *pa; // Now b is 8, the same as a.
</code></pre>So somehow, we have to overload the assignment operator! This brings us to <strong>Operator Overloading</strong>. <a href="http://msdn.microsoft.com/en-us/library/aa288467(v=vs.71).aspx">C# operator overloading</a> works by defining <em>global</em> operator overloads, ones that take a left and a right argument, and are static functions. By default, C++ operator overloading only take the <em>right argument</em>. The left side of the equation is implied to be the class itself. Consequently, <strong>C++ operators are not static</strong>. C++ does have global operators, but they are defined <strong>outside the class</strong>, and the assignment operator isn&rsquo;t allowed as a global operator; you have to define it inside the class. All the overload-able operators are shown below with appropriate declarations:</p><p><pre class=language-cpp><code>class someClass
{
someClass operator =(anything b); // me=other
someClass operator +(anything b); // me+other
someClass operator -(anything b); // me-other
someClass operator +(); // +me
someClass operator -(); // -me (negation)
someClass operator *(anything b); // me*other
someClass operator /(anything b); // me/other
someClass operator %(anything b); // me%other
someClass&amp; operator ++(); // ++me
someClass&amp; operator ++(int); // me++
someClass&amp; operator --(); // --me
someClass&amp; operator --(int); // me--
// All operators can TECHNICALLY return any value whatsoever, but for many of them only certain values make sense.
bool operator ==(anything b); 
bool operator !=(anything b);
bool operator &gt;(anything b);
bool operator &lt;(anything b);
bool operator &gt;=(anything b);
bool operator &lt;=(anything b);
bool operator !(); // !me
// These operators do not usually return someClass, but rather a type specific to what the class does.
anything operator &amp;&amp;(anything b); 
anything operator ||(anything b);

anything operator ~();
anything operator &amp;(anything b);
anything operator |(anything b);
anything operator ^(anything b);
anything operator &lt;&lt;(anything b);
anything operator &gt;&gt;(anything b);
someClass&amp; operator +=(anything b); // Should always return *this;
someClass&amp; operator -=(anything b);
someClass&amp; operator *=(anything b);
someClass&amp; operator /=(anything b);
someClass&amp; operator %=(anything b);
someClass&amp; operator &amp;=(anything b);
someClass&amp; operator |=(anything b);
someClass&amp; operator ^=(anything b);
someClass&amp; operator &lt;&lt;=(anything b);
someClass&amp; operator &gt;&gt;=(anything b);
anything operator [](anything b); // This will almost always return a reference to some internal array type, like myElement&amp;
anything operator *();
anything operator &amp;();
anything* operator -&gt;(); // This has to return a pointer or some other type that has the -&gt; operator defined.

anything operator -&gt;*(anything a);
anything operator ()(anything a1, U a2, ...);
anything operator ,(anything b);
operator otherThing(); // Allows this class to have an implicit conversion to type otherThing
void* operator new(size_t x); // These are called when you write new someClass()
void* operator new[](size_tx); // new someClass[num]
void operator delete(void*x); // delete pointer_to_someClass
void operator delete[](void*x); // delete [] pointer_to_someClass

};

// These are global operators that behave more like C# operators, but must be defined outside of classes, and a few operators do not have global overloads, which is why they are missing from this list. Again, operators can technically take or return any value, but normally you only override these so you can handle some other type being on the left side.
someClass operator +(anything a, someClass b);
someClass operator -(anything a, someClass b);
someClass operator +(someClass a);
someClass operator -(someClass a);
someClass operator *(anything a, someClass b);
someClass operator /(anything a, someClass b);
someClass operator %(anything a, someClass b);
someClass operator ++(someClass a);
someClass operator ++(someClass a, int); // Note the unnamed dummy-parameter int - this differentiates between prefix and suffix increment operators.
someClass operator --(someClass a);
someClass operator --(someClass a, int); // Note the unnamed dummy-parameter int - this differentiates between prefix and suffix decrement operators.

bool operator ==(anything a, someClass b);
bool operator !=(anything a, someClass b);
bool operator &gt;(anything a, someClass b);
bool operator &lt;(anything a, someClass b);
bool operator &gt;=(anything a, someClass b);
bool operator &lt;=(anything a, someClass b);
bool operator !(someClass a);
bool operator &amp;&amp;(anything a, someClass b);
bool operator ||(anything a, someClass b);

someClass operator ~(someClass a);
someClass operator &amp;(anything a, someClass b);
someClass operator |(anything a, someClass b);
someClass operator ^(anything a, someClass b);
someClass operator &lt;&lt;(anything a, someClass b);
someClass operator &gt;&gt;(anything a, someClass b);
someClass operator +=(anything a, someClass b);
someClass operator -=(anything a, someClass b);
someClass operator *=(anything a, someClass b);
someClass operator /=(anything a, someClass b);
someClass operator %=(anything a, someClass b);
someClass operator &amp;=(anything a, someClass b);
someClass operator |=(anything a, someClass b);
someClass operator ^=(anything a, someClass b);
someClass operator &lt;&lt;=(anything a, someClass b);
someClass operator &gt;&gt;=(anything a, someClass b);
someClass operator *(someClass a);
someClass operator &amp;(someClass a);

someClass operator -&gt;*(anything a, someClass b);
someClass operator ,(anything a, someClass b);
void* operator new(size_t x);
void* operator new[](size_t x);
void operator delete(void* x);
void operator delete[](void*x);
</code></pre>We can see that the assignment operator mimics the arguments of our copy constructor. For the most part, it does the exact same thing; the only difference is that existing values must be destroyed, an operation that should mostly mimic the destructor. We extend our previous class to have an assignment operator accordingly:</p><p><pre class=language-cpp><code>class myString
{
public:
  // The copy constructor, which copies the string over instead of copying the pointer
  myString(const myString&amp; copy)
  {
    size_t len = strlen(copy._str)+1; //+1 for null terminator
    _str=new char[len];
    memcpy(_str,copy._str,sizeof(char)*len);
  }
  // Normal constructor
  myString(const char* str)
  {
    size_t len = strlen(str);
    _str=new char[len];
    memcpy(_str,str,sizeof(char)*len);
  }
  // Destructor that deallocates our string
  ~myString()
  {
    delete [] _str;
  }

  // Assignment operator, does the same thing the copy constructor does, but also mimics the destructor by deleting _str. NOTE: It is considered bad practice to call the destructor directly. Use a Clear() method or something equivalent instead.
  myString&amp; operator=(const myString&amp; right)
  {
    delete [] _str;
    size_t len = strlen(right._str)+1; //+1 for null terminator
    _str=new char[len];
    memcpy(_str,right._str,sizeof(char)*len);
  }

private:
  char* _str;
};
</code></pre>These operations take an instance of the class and copy it&rsquo;s values to our instance. Consequently, these are known as <em>copy semantics</em>. If this was 1998, we&rsquo;d stop here, because for a long time, C++ only had copy semantics. Either you passed around references to objects, or you copied them. You could also pass around pointers to objects, but remember that pointers are value types just like integers and floats, so you are really just copying them around too. In fact, until recently, you were <em>not allowed to have references to pointers</em>. Pointers were the one data type that had to be passed by value. Provided you are using a C++0x-compliant compiler, <strong>this is no longer true</strong>, as you may remember from our <a href>first examples</a>. The new standard <a href=en.wikipedia.org/wiki/C%2B%2B11>released in 2011</a> allows references to pointers, and introduces <em>move semantics</em>.</p><p>Move semantics are designed to solve the following problem. If we have a series of dynamic string objects being concatenated, with normal copy constructors we run into a serious problem:</p><p><pre class=language-cpp><code>std::string result = std::string(&#34;Oppa&#34;) + std::string(&#34; Gangnam&#34;) + std::string(&#34; Style&#34;) + std::string(&#34; by&#34;) + std::string(&#34; Psy&#34;);
// This is evaluated by first creating a new string object with its own memory allocation, then deallocating both &#34; by&#34; and &#34; Psy&#34; after copying their contents into the new one
//std::string result = std::string(&#34;Oppa&#34;) + std::string(&#34; Gangnam&#34;) + std::string(&#34; Style&#34;) + std::string(&#34; by Psy&#34;);
// Then another new object is made and &#34; by Psy&#34; and &#34; Style&#34; are deallocated
//std::string result = std::string(&#34;Oppa&#34;) + std::string(&#34; Gangnam&#34;) + std::string(&#34; Style by Psy&#34;);
// And so on and so forth
//std::string result = std::string(&#34;Oppa&#34;) + std::string(&#34; Gangnam Style by Psy&#34;);
//std::string result = std::string(&#34;Oppa Gangnam Style by Psy&#34;);
// So just to add 5 strings together, we&#39;ve had to allocate room for 5 additional strings in the middle of it, 4 of which are then simply deallocated!
</code></pre>This is terribly inefficient; it would be much more efficient if we could utilize the temporary objects that are going to be destroyed anyway instead of reallocating a bunch of memory over and over again only to delete it immediately afterwards. This is where move semantics come in to play. First, we need to define a &ldquo;temporary&rdquo; object as one whose scope is entirely contained on <em>the right side of an expression</em>. That is to say, given a single assignment statement <code>a=b</code>, if an object is both created and destroyed inside <code>b</code>, then it is considered temporary. Because of this, these temporary values are also called <em>rvalues</em>, short for &ldquo;right values&rdquo;. C++0x introduces the syntax <code>variable&&</code> to designate an rvalue. This is how you declare a move constructor:</p><p><pre class=language-cpp><code>class myString
{
public:
  // The copy constructor, which copies the string over instead of copying the pointer
  myString(const myString&amp; copy)
  {
    size_t len = strlen(copy._str)+1; //+1 for null terminator
    _str=new char[len];
    memcpy(_str,copy._str,sizeof(char)*len);
  }
  // Move Constructor
  myString(myString&amp;&amp; mov)
  {
    _str = mov._str;
    mov._str=NULL;
  }
  // Normal constructor
  myString(const char* str)
  {
    size_t len = strlen(str);
    _str=new char[len];
    memcpy(_str,str,sizeof(char)*len);
  }
  // Destructor that deallocates our string
  ~myString()
  {
    if(_str!=NULL) // Make sure we only delete _str if it isn&#39;t NULL!
      delete [] _str;
  }

  // Assignment operator, does the same thing the copy constructor does, but also mimics the destructor by deleting _str. NOTE: It is considered bad practice to call the destructor directly. Use a Clear() method or something equivalent instead.
  myString&amp; operator=(const myString&amp; right)
  {
    delete [] _str;
    size_t len = strlen(right._str)+1; //+1 for null terminator
    _str=new char[len];
    memcpy(_str,right._str,sizeof(char)*len);
    return *this;
  }

private:
  char* _str;
};</code></pre><strong>NOTE: Observe that our destructor functionality was changed! Now that _str can be NULL, we have to check for that before deleting the object.</strong></p><p>The idea behind a move constructor is that, instead of <em>copying</em> the values into our object, we <em>move</em> them into our object, setting the source to some <code>NULL</code> value. Notice that this can only work for pointers, or objects containing pointers. Integers, floats, and other similar types can&rsquo;t really be &ldquo;moved&rdquo;, so instead their values are simply copied over. Consequently, move semantics is only beneficial for types like strings that involve dynamic memory allocation. However, because we must set the source pointers to 0, that means we can&rsquo;t use <code>const myString&&</code>, because then we wouldn&rsquo;t be able to modify the source pointers! This is why a move constructor is declared without a const modifier, which makes sense, since we intend to modify the object.</p><p>But wait, just like a copy constructor has an assignment copy operator, a move constructor has an equivalent assignment move operator. Just like the copy assignment, the move operator behaves exactly like the move constructor, but must destroy the existing object beforehand. The assignment move operator is declared like this:</p><pre class=language-cpp><code>myString&amp; operator=(myString&amp;&amp; right)
  {
    delete [] _str;
    _str=right._str;
    right._str=0;
    return *this;
  }
</code></pre><p>Move semantics can be used for some interesting things, like unique pointers, that <em>only</em> have move semantics - by disabling the copy constructor, you can create an object that is impossible to copy, and can therefore only be moved, which guarantees that there will only be one copy of its contents in existence. <code>std::unique_ptr</code> is an implementation of this provided in C++0x. Note that if a data structure requires copy semantics, <code>std::unique_ptr</code> will throw a compiler error, instead of simply mysteriously failing like the deprecated <code>std::autoptr</code>.</p><p>There is an important detail when you are using inheritance or objects with move semantics:</p><p><pre class=language-cpp><code>class Substring : myString
{
  Substring(Substring&amp;&amp; mov) : myString(std::move(mov))
  {
    _sub = std::move(mov._sub);
  }

  Substring&amp; operator=(Substring&amp;&amp; right)
  {
    myString::operator=(std::move(right));
    _sub = std::move(mov._sub);
    return *this;
  }

  myString _sub;
};
</code></pre>Here we are using <code>std::move()</code>, which takes a variable (that is either an rvalue or a normal reference) and returns an rvalue for that variable. This is because rvalues <em>stop being rvalues</em> the instant they are passed into a different function, which makes sense, since they are no longer on the right-hand side anymore. Consequently, if we were to pass <code>mov</code> above into our base class, it would trigger the <em>copy constructor</em>, because <code>mov</code> would be treated as <code>const Substring&</code>, instead of <code>Substring&&</code>. Using <code>std::move</code> lets us pass it in as <code>Substring&&</code> and properly trigger the move semantics. As you can see in the example, you must use <code>std::move</code> when moving any complex object, using base class constructors, or base class assignment operators. Note that <code>std::move</code> allows you to force an object to be moved to another object regardless of whether or not its actually an rvalue. This would be particularly useful for moving around <code>std::unique_ptr</code> objects.</p><p>There&rsquo;s some other weird things you can do with move semantics. This most interesting part is the strange behavior of <code>&&</code> when it is appended to existing references.</p><ul><li><code>A& &</code> becomes <code>A&</code></li><li><strong><code>A& &&</code> becomes <code>A&</code></strong></li><li><code>A&& &</code> becomes <code>A&</code></li><li><strong><code>A&& &&</code> becomes <code>A&&</code></strong></li></ul><p>By taking advantage of the second and fourth lines, we can perform <em>perfect forwarding</em>. Perfect forwarding allows us to pass an argument as either a normal reference (<code>A&</code>) or an rvalue (<code>A&&</code>) and then <em>forward it</em> into another function, preserving its status as an rvalue or a normal reference, including whether or not it&rsquo;s <code>const A&</code> or <code>const A&&</code>. Perfect forwarding can be implemented like so:</p><p><pre class=language-cpp><code>template&lt;typename U&gt;
void Set(U &amp;&amp; other)
{
  _str=std::forward&lt;U&gt;(other);
}
</code></pre>Notice that this allows us to assign our data object using either the copy assignment, or the move assignment operator, by using <code>std::forward&lt;U>()</code>, which transforms our reference into either an rvalue if it was an rvalue, or a normal reference if it was a normal reference, much like <code>std::move()</code> transforms everything into an rvalue. However, this requires a template, which may not always be correctly inferred. A more robust implementation uses two separate functions forwarding their parameters into a helper function:</p><p><pre class=language-cpp><code>class myString
{
public:
  // The copy constructor, which copies the string over instead of copying the pointer
  myString(const myString&amp; copy)
  {
    size_t len = strlen(copy._str)+1; //+1 for null terminator
    _str=new char[len];
    memcpy(_str,copy._str,sizeof(char)*len);
  }
  // Move Constructor
  myString(myString&amp;&amp; mov)
  {
    _str = mov._str;
    mov._str=NULL;
  }
  // Normal constructor
  myString(const char* str)
  {
    size_t len = strlen(str);
    _str=new char[len];
    memcpy(_str,str,sizeof(char)*len);
  }
  // Destructor that deallocates our string
  ~myString()
  {
    if(_str!=NULL) // Make sure we only delete _str if it isn&#39;t NULL!
      delete [] _str;
  }
  void Set(myString&amp;&amp; str)
  {
    _set&lt;myString&amp;&amp;&gt;(std::move(str));
  }
  void Set(const myString&amp; str)
  {
    _set&lt;const myString&amp;&gt;(str);
  }


  // Assignment operator, does the same thing the copy constructor does, but also mimics the destructor by deleting _str. NOTE: It is considered bad practice to call the destructor directly. Use a Clear() method or something equivalent instead.
  myString&amp; operator=(const myString&amp; right)
  {
    delete [] _str;
    size_t len = strlen(right._str)+1; //+1 for null terminator
    _str=new char[len];
    memcpy(_str,right._str,sizeof(char)*len);
    return *this;
  }

private:
  template&lt;typename U&gt;
  void _set(U &amp;&amp; other)
  {
    _str=std::forward&lt;U&gt;(other);
  }

  char* _str;
};
</code></pre>Notice the use of <code>std::move()</code> to transfer the rvalue correctly, followed by <code>std::forward&lt;U>()</code> to forward the parameter. By using this, we avoid redundant code, but can still build move-aware data structures that efficiently assign values with relative ease. Now, its on to <a href=#>Part 5: Delegated Llamas</a>! Or, well, delegates, function pointers, and lambdas. Possibly involving llamas. Maybe.</p></div><hr><time itemprop=datePublished pubdate=pubdate datetime=2012-10-20T11:16:00+00:00><i class="fa-regular fa-clock fa-fw"></i>&nbsp;Published on <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-4-operator-overload/>October 20, 2012 at 11:16am</a></time><aside><i class="fa-regular fa-share-square fa-fw"></i>&nbsp;share:<ul><li><a href="javascript:window.open('https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ferikmcclure.com%2fblog%2fc-to-c-tutorial-part-4-operator-overload%2f','popup','width=600,height=400');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" d="M16.75 9H13.5V7a1 1 0 011-1h2V3H14a4 4 0 00-4 4V9H8v3h2v9h3.5V12H16z"/></svg></a><li><a href="javascript:window.open('https://twitter.com/intent/tweet?text=C%23%20to%20C%2b%2b%20Tutorial%20-%20Part%204%3a%20Operator%20Overload&url=https%3a%2f%2ferikmcclure.com%2fblog%2fc-to-c-tutorial-part-4-operator-overload%2f','popup','width=600,height=256');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" opacity="0" d="M0 0h24v24H0z"/><path class="st0" d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572.0-4.658 2.086-4.658 4.66.0.364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342.0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3.0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376.0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57.0 13.255-7.098 13.255-13.254.0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg></a></li><li><a href="javascript:window.open('https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2ferikmcclure.com%2fblog%2fc-to-c-tutorial-part-4-operator-overload%2f','popup','width=700,height=380');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><rect class="st0" height="11" width="4" x="3" y="9"/><circle class="st0" cx="5" cy="5" r="2"/><path class="st0" d="M16.5 8.25A4.47251 4.47251.0 0013 9.95343V9H9V20h4V13a2 2 0 014 0v7h4V12.75a4.5 4.5.0 00-4.5-4.5z"/></svg></a></li></ul></aside></article><article><a name=comments><h4>Comments</h4></a><hr><div class=comments><div id=c7902195492669411275><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh3.googleusercontent.com/-i7cyHWlHQOQ/AAAAAAAAAAI/AAAAAAAAABg/nvYP8sd430A/s32-c/photo.jpg alt>
<b>Orestis125</b><p>Noo where is the rest of the tutorial?</p></div><hr><div id=c7885397258488716875><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src="//lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35" alt>
<b>NothingButFlower</b><p>Did you abandon this tutorial project completely? It has been quite brilliant for me since I found it, best text covering this topic Ive encountered so far.</p></div><hr><div id=c8618545649754470268><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh3.googleusercontent.com/-0bn0k8RcxiI/AAAAAAAAAAI/AAAAAAAAACI/arft8Q3Nno4/s32-c/photo.jpg alt>
<b>Mithun Mithun</b><p>Given so much information in it. its very useful .perfect explanation about Dot net framework.Thanks for your valuable information. <a href=http://www.credosystemz.com/training-in-chennai/best-dotnet-training-in-chennai/ rel=nofollow>dot net training in velachery</a> | <a href=http://www.credosystemz.com/training-in-chennai/best-dotnet-training-in-chennai/ rel=nofollow>dot net training in chennai</a></p></div></div><div class=comments></div><hr><div class=wrapcommento><div id=commento></div><script src=https://cdn.commento.io/js/commento.js></script></div></form></article></section><section class=archive><article><img src=https://erikmcclure.com/img/avatar.th.png alt=Avatar width=180 height=180><h2>Archive</h2><ol><li><details><summary>2024</summary><ul><li><a href=/blog/measuring-competence-is-epistemic-hell/>Measuring Competence Is Epistemic Hell</a></li><li><a href=/blog/we-could-fix-everything-we-just-dont/>We Could Fix Everything, We Just Don't</a></li></ul></details></li><li><details><summary>2023</summary><ul><li><a href=/blog/people-cant-care-about-everything/>People Can't Care About Everything</a></li><li><a href=/blog/discord-should-remove-usernames/>Discord Should Remove Usernames Entirely</a></li><li><a href=/blog/age-of-bullshit/>Welcome to the Age of Bullshit</a></li><li><a href=/blog/nuerodivergents-will-inherit-the-earth/>Neurodivergents Will Inherit The Earth</a></li></ul></details></li><li><details><summary>2022</summary><ul><li><a href=/blog/money-is-fake/>Money Is Fake. It's Not Real. It's Made Up.</a></li><li><a href=/blog/we-need-new-motherboards/>We Need New Motherboards Before GPUs Collapse Under Their Own Gravity</a></li><li><a href=/blog/never-respect-my-elders-after-what-they-did/>I'll Never Respect My Elders After What They've Done</a></li><li><a href=/blog/camp-vista/>Camp Vista - Growing Up Next To Microsoft</a></li></ul></details></li><li><details><summary>2021</summary><ul><li><a href=/blog/offworld-pack-orphans/>Kits And Pack Orphans First [Fiction]</a></li><li><a href=/blog/blockchain-new-javascript/>Blockchain Is The New JavaScript</a></li><li><a href=/blog/cpp-constructors-memory-and-lifetimes/>C++ Constructors, Memory, and Lifetimes</a></li><li><a href=/blog/factorio-is-best-interview-we-have/>Factorio Is The Best Technical Interview We Have</a></li></ul></details></li><li><details><summary>2020</summary><ul><li><a href=/blog/why-you-cant-use-prebuilt-llvm-with-cpp17/>Why You Can't Use Prebuilt LLVM 10.0 with C++17</a></li><li><a href=/blog/someone-is-stealing-tracker-songs/>Someone Is Stealing Tracker Songs And Selling Them</a></li><li><a href=/blog/pressure-based-anti-spam-for-discord-bots/>Pressure Based Anti-Spam for Discord Bots</a></li></ul></details></li><li><details><summary>2019</summary><ul><li><a href=/blog/name-shadowing-should-be-an-operator/>Name Shadowing Should Be An Operator</a></li><li><a href=/blog/a-rant-on-terra/>A Rant On Terra</a></li><li><a href=/blog/risc-is-fundamentally-unscalable/>RISC Is Fundamentally Unscalable</a></li></ul></details></li><li><details><summary>2018</summary><ul><li><a href=/blog/software-engineering-is-bad-but-it-s-not-that-bad/>Software Engineering Is Bad, But That's Not Why</a></li><li><a href=/blog/why-do-people-use-the-wrong-email-/>Why Do People Use The Wrong Email?</a></li><li><a href=/blog/software-optimizes-to-single-points-of-failure/>Software Optimizes to Single Points of Failure</a></li><li><a href=/blog/migrating-to-static-blog/>Migrating To A Static Blog</a></li><li><a href=/blog/how-to-avoid-memorizing-times-tables/>How To Avoid Memorizing Times Tables</a></li></ul></details></li><li><details><summary>2017</summary><ul><li><a href=/blog/ignoring-outliers-creates-racist/>Ignoring Outliers Creates Racist Algorithms</a></li><li><a href=/blog/i-used-to-want-to-work-for-google/>I Used To Want To Work For Google</a></li><li><a href=/blog/sexist-programmers-are-awful-engineers/>Sexist Programmers Are Awful Engineers</a></li><li><a href=/blog/why-i-never-built-my-soundcloud-killer/>Why I Never Built My SoundCloud Killer</a></li><li><a href=/blog/integrating-luajit-and-autogenerating-c/>Integrating LuaJIT and Autogenerating C Bindings In Visual Studio</a></li><li><a href=/blog/discord-rise-of-bot-wars/>Discord: Rise Of The Bot Wars</a></li><li><a href=/blog/programmers-should-take-linguistics/>Programmers Should Take Linguistics</a></li><li><a href=/blog/companies-cant-be-apolitical/>Companies Can't Be Apolitical</a></li><li><a href=/blog/i-cant-hear-anything-below-80-hz/>I Can't Hear Anything Below 80 Hz*</a></li><li><a href=/blog/windows-wont-let-my-program-crash/>Windows Won't Let My Program Crash</a></li><li><a href=/blog/directx-is-terrifying/>DirectX Is Terrifying</a></li><li><a href=/blog/our-software-is-beacon-of-hope/>Our Software Is a Beacon of Hope</a></li></ul></details></li><li><details><summary>2016</summary><ul><li><a href=/blog/everyone-does-srgb-wrong-because/>Everyone Does sRGB Wrong Because Everyone Else Does sRGB Wrong</a></li><li><a href=/blog/mathematical-notation-is-awful/>Mathematical Notation Is Awful</a></li><li><a href=/blog/the-gpl-is-usually-overkill/>The GPL Is Usually Overkill</a></li><li><a href=/blog/the-right-to-ignore-difference-between/>The Right To Ignore: The Difference Between Free Speech And Harassment</a></li></ul></details></li><li><details><summary>2015</summary><ul><li><a href=/blog/there-will-never-be-one-true/>There Will Never Be One True Programming Language</a></li><li><a href=/blog/abortion-has-no-moral-high-ground/>Abortion Has No Moral High Ground</a></li><li><a href=/blog/i-tried-to-install-linux-and-now-i/>I Tried To Install Linux And Now I Regret Everything</a></li><li><a href=/blog/you-arent-designing-software-for-robots/>We Aren't Designing Software For Robots</a></li><li><a href=/blog/using-data-to-balance-your-game-pony/>Using Data To Balance Your Game: Pony Clicker Analysis</a></li><li><a href=/blog/is-there-commercial-open-source-license/>Is There A Commercial Open Source License?</a></li><li><a href=/blog/does-anyone-actually-want-good-software/>Does Anyone Actually Want Good Software?</a></li><li><a href=/blog/why-dont-you-just-fire-them/>Why Don't You Just Fire Them?</a></li></ul></details></li><li><details><summary>2014</summary><ul><li><a href=/blog/how-not-to-sell-software/>How Not To Install Software</a></li><li><a href=/blog/not-reinventing-wheel-is-anticompetitive/>Never Reinventing The Wheel Is Anticompetitive</a></li><li><a href=/blog/everyone-can-be-above-average/>Everyone Can Be Above Average</a></li><li><a href=/blog/can-we-choose-what-we-enjoy/>Can We Choose What We Enjoy?</a></li><li><a href=/blog/how-to-make-your-profiler-10x-faster/>How To Make Your Profiler 10x Faster</a></li><li><a href=/blog/the-problem-with-photorealism/>The Problem With Photorealism</a></li><li><a href=/blog/success-is-relative/>Success Is Relative</a></li></ul></details></li><li><details><summary>2013</summary><ul><li><a href=/blog/googles-decline-really-bugs-me/>Google's Decline Really Bugs Me</a></li><li><a href=/blog/the-educational-imbroglio/>The Educational Imbroglio</a></li><li><a href=/blog/the-ladder-climbing-generation/>The Ladder-Climbing Generation</a></li><li><a href=/blog/the-microsoft-word-problem/>The Microsoft Word Problem</a></li><li><a href=/blog/write-less-code/>Write Less Code</a></li><li><a href=/blog/most-people-have-shitty-computers/>Most People Have Shitty Computers</a></li><li><a href=/blog/leap-motion-impressions-input/>Leap Motion Impressions, Input Sanitation, and 3D Gesture Ideas</a></li><li><a href=/blog/aurora-theory-released/>Aurora Theory Released!</a></li><li><a href=/blog/what-i-learned-in-college/>What I Learned In College</a></li><li><a href=/blog/how-to-complain-about-men-and-be-sexist/>How To Complain About Men And Be Sexist At The Same Time</a></li><li><a href=/blog/course-notes/>Course Notes</a></li><li><a href=/blog/contact/>Contact</a></li><li><a href=/blog/the-dark-side-of-htmlcss/>The Dark Side of Web Development</a></li><li><a href=/blog/windows-breaks-assert-inside/>Windows Breaks assert() Inside WM_CANCELMODE</a></li><li><a href=/blog/dreams-are-worth-fighting-for/>Dreams Are Worth Fighting For</a></li><li><a href=/blog/the-productivity-fallacy/>The Productivity Fallacy</a></li><li><a href=/blog/the-earbud-loudness-wars/>The Earbud Loudness Wars</a></li></ul></details></li><li><details><summary>2012</summary><ul><li><a href=/blog/giant-list-of-free-samples/>Giant List of FREE SAMPLES</a></li><li><a href=/blog/the-weekend-apelsin-got-lost-all-time/>The Weekend I Got Lost All The Time</a></li><li><a href=/blog/c-to-c-tutorial-part-4-operator-overload/>C# to C++ Tutorial - Part 4: Operator Overload</a></li><li><a href=/blog/7-problems-raytracing-doesnt-solve/>7 Problems Raytracing Doesn't Solve</a></li><li><a href=/blog/teenage-rebellion-as-failure-of-society/>Teenage Rebellion as a Failure of Society</a></li><li><a href=/blog/analyzing-xkcd-click-and-drag/>Analyzing XKCD: Click and Drag</a></li><li><a href=/blog/what-is-right-answer/>What Is A Right Answer?</a></li><li><a href=/blog/coordinate-systems-and-cascading/>Coordinate Systems And Cascading Stupidity</a></li><li><a href=/blog/how-joysticks-ruined-my-graphics-engine/>How Joysticks Ruined My Graphics Engine</a></li><li><a href=/blog/properly-dreaming-about-success/>Properly Dreaming About Success</a></li><li><a href=/blog/multithreading-problems-in-game-design/>Multithreading Problems In Game Design</a></li><li><a href=/blog/ip-law-makes-you-asshole/>IP Law Makes You an Asshole</a></li><li><a href=/blog/stop-following-rules/>Stop Following The Rules</a></li><li><a href=/blog/standards-problem/>The Standards Problem</a></li><li><a href=/blog/an-evidence-based-refutation-of-the-project-glass-parodies/>An evidence-based refutation of the Project Glass parodies</a></li><li><a href=/blog/language-wars-are-pointless/>Language Wars Are Pointless</a></li><li><a href=/blog/why-windows-8-does-right-thing-wrong/>Why Windows 8 Does The Right Thing The Wrong Way</a></li><li><a href=/blog/well-that-was-interesting/>Well That Was Interesting</a></li><li><a href=/blog/visual-studio-broke-my-computer/>Visual Studio Broke My Computer</a></li><li><a href=/blog/hiring-wrong-people/>Hiring the Wrong People</a></li><li><a href=/blog/chill-out/>Chill Out</a></li><li><a href=/blog/implicit-ui-design/>Implicit UI Design</a></li><li><a href=/blog/linux-mint-12-kde/>Linux Mint 12 KDE</a></li><li><a href=/blog/new-post/>'Programmer' is an Overgeneralization</a></li><li><a href=/blog/wikipedias-identity-crisis/>Wikipedia's Identity Crisis</a></li></ul></details></li><li><details><summary>2011</summary><ul><li><a href=/blog/your-esoteric-language-is-useless/>Your Esoteric Language is Useless</a></li><li><a href=/blog/great-mystery-of-linear-gradient/>The Great Mystery of Linear Gradient Lighting</a></li><li><a href=/blog/signed-integers-considered-stupid-like/>Signed Integers Considered Stupid (Like This Title)</a></li><li><a href=/blog/why-kids-hate-math/>Why Kids Hate Math</a></li><li><a href=/blog/importance-of-importance/>Don't Work on Someone Else's Dream</a></li><li><a href=/blog/c-to-c-tutorial-part-3-classes-and/>C# to C++ Tutorial - Part 3: Classes and Structs and Inheritance (OH MY!)</a></li><li><a href=/blog/problem-of-vsync/>The Problem of Vsync</a></li><li><a href=/blog/musical-genres/>Musical Genres</a></li><li><a href=/blog/c-to-c-tutorial-part-2-pointers/>C# to C++ Tutorial - Part 2: Pointers Everywhere!</a></li><li><a href=/blog/radians-explanation/>Radians: An explanation</a></li><li><a href=/blog/c-to-c-tutorial-part-1-basics-of-syntax/>C# to C++ Tutorial - Part 1: Basics of Syntax</a></li><li><a href=/blog/on-hackers/>On Hacking (or Why We Need Security Ratings)</a></li><li><a href=/blog/my-mom-had-heart-attack/>My Mom Had a Heart Attack</a></li><li><a href=/blog/religion-problem-perspectives/>The Religion Problem: Perspectives</a></li><li><a href=/blog/ninth-circle-of-bugs/>The Ninth Circle of Bugs</a></li><li><a href=/blog/save-rss/>Save RSS</a></li><li><a href=/blog/college-is-broken/>College Is Broken</a></li><li><a href=/blog/outside-perspective-on-psn-fiasco/>An Outside Perspective on the PSN Fiasco</a></li><li><a href=/blog/future-predictions/>Future Predictions</a></li><li><a href=/blog/investigating-low-level-cpu-performance/>Investigating Low-level CPU Performance</a></li><li><a href=/blog/bullying-never-stops/>The Bullying Never Stops</a></li></ul></details></li><li><details><summary>2010</summary><ul><li><a href=/blog/im-failure/>The IM Failure</a></li><li><a href=/blog/how-to-train-your-dragon/>How To Train Your Dragon</a></li><li><a href=/blog/album-for-sale-renascent/>Album For Sale! [Renascent]</a></li><li><a href=/blog/wavsaver/>WavSaver</a></li><li><a href=/blog/pixel-perfect-hit-testing/>Pixel Perfect Hit Testing</a></li><li><a href=/blog/fractal-cycle-screensaver/>Fractal Cycle Screensaver</a></li><li><a href=/blog/8-bit-color-cycling/>8-bit color cycling</a></li><li><a href=/blog/physics-networking/>Physics Networking</a></li><li><a href=/blog/assembly-cas-implementation/>Assembly CAS implementation</a></li><li><a href=/blog/function-pointer-speed/>Function Pointer Speed</a></li><li><a href=/blog/most-bizarre-error-ever/>Most Bizarre Error Ever</a></li><li><a href=/blog/floating-point-preformance/>Floating Point Preformance</a></li><li><a href=/blog/watch-this-now/>Watch This Now</a></li></ul></details></li><li><details><summary>2009</summary><ul><li><a href=/blog/physics-oriented-network-interpolation/>Physics-oriented Network Interpolation</a></li><li><a href=/blog/proving-strong-ai/>Proving Strong AI</a></li><li><a href=/blog/i-now-have-lj/>I now have an LJ</a></li></ul></details></li></ol></article></section></main><footer><p><span>Copyright &copy;2024 Erik McClure</span> <a href=https://erikmcclure.com/sitemap.xml>Sitemap</a> | <a href=https://erikmcclure.com/blog/index.xml>RSS Feed</a></p></footer></div><script>"use strict";window.onload=function(){e=document.getElementsByClassName("math");for(var e,t=0,n=e.length;t<n;t++)renderMathInElement(e[t],{delimiters:[{left:"$$",right:"$$",display:!1},{left:"\\[",right:"\\]",display:!0}]})}</script></body></html>