<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=Edge"><meta http-equiv=permissions-policy content="interest-cohort=()"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#2b7bb5"><meta name=copyright content="Copyright (c)2022 Erik McClure"><meta name=keywords content="games,music,code,erik mcclure,erikmcclure,aurora theory,sweetie bot,discord,feathergui,black sphere studios,tinyoal,upatch"><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"><meta name=google-site-verification content="Oxb2ia8HjcHLXlvstA8xPpQO3BO_y15Ds2Ia-feq1MQ"><meta name=generator content="Hugo 0.62.2"><link rel=canonical href=https://erikmcclure.com/blog/implicit-ui-design/><link rel=apple-touch-icon href=https://erikmcclure.com/favicon.ico><link rel="shortcut icon" type=image/x-icon href=https://erikmcclure.com/favicon.ico><link rel=stylesheet href=https://erikmcclure.com/css/main.css><link rel=stylesheet href=https://erikmcclure.com/css/prism.css rel=stylesheet><link rel=stylesheet href=https://erikmcclure.com/css/katex.min.css rel=stylesheet><link rel=stylesheet href=https://erikmcclure.com/css/font-awesome.min.css><link rel=alternate type=application/rss+xml title="Erik McClure - RSS" href=https://erikmcclure.com/index.xml><meta property="og:type" content="article"><title>Implicit UI Design</title><meta property="og:title" content="Implicit UI Design"><meta name=twitter:title content="Implicit UI Design"><meta itemprop=name content="Implicit UI Design"><meta name=description content="For a long time, I have been frustrated with the poor UI design that is rampant in the software industry. As a consequence, many Linux enthusiasts have pointed out how productive you can be with Emacs, VIM, and other keyboard-shortcut/terminal oriented software. The UI design has gotten so bad, I have to agree that in comparison to recent user interface designs, keyboard shortcuts are looking rather appealing. This, however, doesn't mean that one approach is inherently better than another, simply that modern user interfaces suck."><meta property="og:description" content="For a long time, I have been frustrated with the poor UI design that is rampant in the software industry. As a consequence, many Linux enthusiasts have pointed out how productive you can be with Emacs, VIM, and other keyboard-shortcut/terminal oriented software. The UI design has gotten so bad, I have to agree that in comparison to recent user interface designs, keyboard shortcuts are looking rather appealing. This, however, doesn't mean that one approach is inherently better than another, simply that modern user interfaces suck."><meta name=twitter:description content="For a long time, I have been frustrated with the poor UI design that is rampant in the software industry. As a consequence, many Linux enthusiasts have pointed out how productive you can be with Emacs, VIM, and other keyboard-shortcut/terminal oriented software. The UI design has gotten so bad, I have to agree that in comparison to recent user interface designs, keyboard shortcuts are looking rather appealing. This, however, doesn't mean that one approach is inherently better than another, simply that modern user interfaces suck."><meta itemprop=description content="For a long time, I have been frustrated with the poor UI design that is rampant in the software industry. As a consequence, many Linux enthusiasts have pointed out how productive you can be with Emacs, VIM, and other keyboard-shortcut/terminal oriented software. The UI design has gotten so bad, I have to agree that in comparison to recent user interface designs, keyboard shortcuts are looking rather appealing. This, however, doesn't mean that one approach is inherently better than another, simply that modern user interfaces suck."><meta property="og:url" content="https://erikmcclure.com/"><meta property="og:site_name" content="Erik McClure"><meta property="og:image" content="https://erikmcclure.com/img/avatar.png"><meta property="og:locale" content="en-US"><meta property="article:author" content="Erik McClure"><meta name=twitter:card content="summary"><meta name=twitter:site content="@erikmcclure0173"><meta name=twitter:creator content="@erikmcclure0173"><meta name=twitter:image content="https://erikmcclure.com/img/avatar.png"><meta name=twitter:dnt content="on"><link href=https://plus.google.com/104896885003230920472 rel=publisher><meta itemprop=image content="https://erikmcclure.com/img/avatar.png"><meta name=last-updated content="20120224-10:18:00.000"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-63026815-3"></script><script defer src=https://erikmcclure.com/syntax-prism.js></script><script defer src=https://erikmcclure.com/katex.min.js></script><script defer src=https://erikmcclure.com/mathtex-script-type.min.js></script><script defer src=https://erikmcclure.com/auto-render.min.js></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-63026815-3');</script></head><body><div id=container><header><nav><ul><li><a href=/blog/ title=Blog><i class="fa fa-book fa-fw fa-lg"></i>&nbsp;<p>Blog</p></a></li><li><a href=/projects/ title=Projects><i class="fa fa-briefcase fa-fw fa-lg"></i>&nbsp;<p>Projects</p></a></li><li><a href=https://erikmcclure.bandcamp.com title=Bandcamp><i class="fa fa-bandcamp fa-fw fa-lg"></i>&nbsp;<p>Bandcamp</p></a></li><li><a href=https://github.com/erikmcclure title=Github><i class="fa fa-github fa-fw fa-lg"></i>&nbsp;<p>Github</p></a></li><li><a href=https://twitter.com/erikmcclure0173 title=Twitter><i class="fa fa-twitter fa-fw fa-lg"></i>&nbsp;<p>Twitter</p></a></li><li><a href=/web/ title=Websites><i class="fa fa-globe fa-fw fa-lg"></i>&nbsp;<p>Websites</p></a></li></ul></nav><div class=dim><h1>Erik McClure</h1></div></header><main class=blog><section><meta itemprop=mainEntityOfPage itemtype=https://schema.org/WebPage content="https://erikmcclure.com/"><meta itemprop=dateModified content="2012-02-24T10:18:00+00:00"><meta itemprop=headline content="Implicit UI Design"><meta itemprop=description content="For a long time, I have been frustrated with the poor UI design that is rampant in the software industry. As a consequence, many Linux enthusiasts have pointed out how productive you can be with Emacs, VIM, and other keyboard-shortcut/terminal oriented software. The UI design has gotten so bad, I have to agree that in comparison to recent user interface designs, keyboard shortcuts are looking rather appealing. This, however, doesn't mean that one approach is inherently better than another, simply that modern user interfaces suck."><meta itemprop=url content="https://erikmcclure.com/blog/implicit-ui-design/"><div itemprop=publisher itemscope itemtype=https://schema.org/Organization><div itemprop=logo itemscope itemtype=https://schema.org/ImageObject><meta itemprop=url content="https://erikmcclure.com/img/avatar.png"><meta itemprop=width content="140"><meta itemprop=height content="140"></div><meta itemprop=name content="Erik McClure"></div><div itemprop=author itemscope itemtype=https://schema.org/Person><meta itemprop=name content="Erik McClure"></div><article><h4>Implicit UI Design</h4><hr><div class=padding><p>For a long time, I have been frustrated with the poor UI design that is rampant in the software industry. As a consequence, many Linux enthusiasts have pointed out how productive you can be with Emacs, VIM, and other keyboard-shortcut/terminal oriented software. The UI design has gotten so bad, I have to agree that in comparison to recent user interface designs, keyboard shortcuts are looking rather appealing. This, however, doesn't mean that one approach is inherently better than another, simply that modern user interfaces <em>suck</em>.</p><p>In this blog, I'm going to outline several improvements to user interfaces and the generalized alternative design philosophy that is behind many of them. To start, let's look at <a href=http://blogs.msdn.com/b/visualstudio/archive/2012/02/23/introducing-the-new-developer-experience.aspx>this recent article</a> about Visual Studio 11, which details Microsoft's latest strategy to ruin their products by sucking all the color out of them:</p><p><div style=text-align:center;overflow:hidden><a href=http://blogs.msdn.com/cfs-file.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-01-29-92-metablogapi/1667.dev10toolbars_5F00_4D41B521.png><img src=http://blogs.msdn.com/cfs-file.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-01-29-92-metablogapi/1667.dev10toolbars_5F00_4D41B521.png alt="Visual Studio 2010"></a><i>Visual Studio 2010</i></div><div style=text-align:center;overflow:hidden><a href=http://blogs.msdn.com/cfs-file.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-01-29-92-metablogapi/1667.dev10toolbars_5F00_4D41B521.png><img src=http://blogs.msdn.com/cfs-file.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-01-29-92-metablogapi/8117.dev11toolbars_5F00_2190EB25.png alt="Visual Studio 11"></a><i>Visual Studio 11</i></div></p><p>See, color is kind of important. Notably, color is <em>how I find icons in your toolbar</em>. To me, color is a kind of filter. If I know what color(s) are most prominent in a given icon, I can mentally filter out everything else and only have to browse through a much smaller subset of your icons. Combined with having a vague notion of where a given icon is, this usually reduces the number of icons I have to mentally sift through to only one or two.</p><div style=text-align:center;overflow:hidden><a href=/img/qem4h.png><img src=/img/qem4h.png alt="Color Filtering"></a><i>Mental color and spatial filtering</i></div><p>If you remove color, I am left to only my spatial elimination, which can make things extremely annoying when there are a bunch of icons right next to each other. Microsoft claims to have done a study that shows that this new style does not harm being able to identify a given icon in terms of speed, but fails to take into account the <em>mental tax</em> that goes into finding an icon without color. *While we understand that opinions on this new style of iconography may vary, an icon recognition study conducted with 76 participants, 40 existing and 36 new VS users, showed no negative effect in icon recognition rates for either group due to the glyph style transition. In the case of the new VS users they were able to successfully identify the new VS 11 icons faster than the VS 2010 icons (i.e., given a command, users were faster at pointing to the icon representing that command).* You may still be able to find the icon, especially after you've been forced to memorize its position just to find it again, and do it reasonably fast, but whether you like it or not, the absence of color will force your brain to process more possible icons before settling down on the one you actually want. When I'm compiling something, I only have a vague notion of where the start button actually is. I don't need to know exactly where it is or even what it looks like; it's extremely easy to find since its practically the only green button on the entire toolbar. Same goes for save and open. The uniform color makes the icons very easy to spot, and all the other icons are immediately discarded.</p><p>That said, there are many poorly design icons in Visual Studio. Take this group of icons:
<a href=/img/mIcIL.png target=_blank><img src=/img/mIcIL.png alt="Bad Icons!"></a></p><p>I don't really know what any of those buttons do. One of them is some sort of toolbox and one is probably the properties window, but they have <em>too many colors</em>. It becomes, again, mentally taxing when even looking at those icons because there is too much irrelevant information being processed. In this scenario, the colors are detrimental to the identification of the buttons. This is because there is no single dominant color, like on the play button, or the save button. Hence, the best solution is to design icons with principle colors, such that some or all the icon is one color and the rest is greyscale. The brain edits out the greyscale and allows identification by color, followed by location, followed by actual glyph shape. To avoid overloading the user with a rainbow of colors, consider scaling the amount of color to how likely a given button is to be used. Desaturate or shrink the colored area of buttons that are much less important. Color is a tool that can be used correctly or incorrectly - that doesn't mean you should just throw it away the first time you screw up.</p><p>We can make better decisions by taking into account how the user is going to use the GUI. By developing an awareness of how a user interface is normally used, we develop vastly superior interactions that accelerate, rather than impede, workflow. To return to visual studio, let's take a look at a feature in the VS11: pinning a variable preview.
<a href=/img/c6j3X.png target=_blank><img src=/img/c6j3X.png alt="Variable Preview"></a><a href=/img/fskyt.png target=_blank><img src=/img/fskyt.png alt="Pinned Variable Preview"></a></p><p>This is a terrible implementation for a number of reasons. First, since the pin button is all the way on the other end, it is a moving target and you'll never really be sure where it is until you need to pin something. Furthermore, you can drag the pinned variable around, and you'll want to after Visual Studio moves it to a seemingly random location that is almost always annoying (but only after the entire IDE locks up for 3 seconds because you haven't done it recently). When would a user be dragging a variable around? Only when its pinned. A better implementation is to make a handle on the left side of any variable preview. If you click the handle (and optionally drag the variable around), it is implicitly converted to a pinned variable without changing anything else, and a close button appears to the left of the handle.</p><p><a href=/img/yXQ12.png target=_blank><img src=/img/yXQ12.png alt="Better Variable Preview"></a><a href=/img/YOXVA.png target=_blank><img src=/img/YOXVA.png alt="Better Pinned Preview"></a></p><p>This is much easier to use, because it eliminates a mouse click and prevents the variable from moving to some random location you must then locate afterwards to move it to your actual desired location. By shifting the close button to the left, it is no longer a moving target. To make this even better, you should make sure previews snap to each other so you can quickly build a list of them, and probably include a menu dropdown by the close button too.</p><p>We have just used <em>Implicit UI Design</em>, where instead of forcing the user to explicitly specify what they want to have happen, we can use contextual clues to <em>imply</em> a given action. We knew that the user could not possibly move a variable preview without wanting to pin it, so we simply made the act of moving the preview, pin it. Another example is docking windows. Both Adobe and Visual Studio are guilty of trying to make everything dockable everywhere without realizing that this is usually just extremely annoying, not helpful. I mean really, why would I want to <em>dock</em> the find window?</p><div style=text-align:center;overflow:hidden><a href=/img/odtyz.png><img style=height:380px src=/img/odtyz.png alt="Bad Find Window!"></a></br><i>Goddamn it, not again</i></div><p>Even if I was doing a lot of find and replace, it just isn't useful. You can usually cover up half your code while finding and replacing without too much hassle. The only thing this does is make it really hard to move the damn window anywhere because if you aren't careful you'll accidentally dock it to the toolbar and then you have to pull the damn thing out and hope nothing else blew up, and if your really unlucky you'll have to reconstruct the whole freaking solution window.</p><p>That isn't helpful. The fact that the act of docking and undocking can be excruciatingly slow makes things even worse and is inexcusable. Only a UI that is bloated beyond my ability to comprehend could possibly have such a difficult time docking and undocking things, no doubt made worse by their fetishization of docking windows. Docking windows correctly requires that you account for the extremely common mistake of accidentally undocking or docking a window where you didn't want it. If a mistake is so common and so annoying, you should make it either much harder to do, or make it very easy to undo. In this case, you should remember where the window was docked last (or not docked), and make a space for it to be dropped into, instead of forcing the user to figure out which magic location on the screen actually docks the window to the right position (which sometimes involves differences of 2 or 3 pixels, which is incredibly absurd).</p><div style=text-align:center;overflow:hidden><a href=/img/ZKhiJ.png><img src=/img/ZKhiJ.png alt="Spot Holding"></a><br><i>Spot Holding</i></div><p>Panels are related to docking (usually you can dock something into a collapsible panel), but even these aren't done very efficiently. If you somehow manage to get the window you want docked into a panel, it defaults to pinning <em>the entire group of panels</em>, regardless of whether they were pinned before or not. I just wanted to pin one!</p><div style=text-align:center;overflow:hidden><a href=/img/A4Q2w.png><img src=/img/A4Q2w.png / alt="Pin Disaster"></a><br><i>You have to drag the thing out and redock it to pin just that one panel.</i></div><p>There is a better way to do this. If we click on a collapsible panel, we know the user wants to show it. However, the only reason they even need to click on the panel is because we don't show it immediately after the mouse hovers over the button. This time should be less than a tenth of a second, and it should immediately close if the mouse gets too far away. It should stay open if the mouse is close enough that the user might have temporarily left the window but may want to come back in. Hovering over another panel button <em>immediately</em> replaces the current panel (in this case, at least), and dragging the panel title bar or the panel button lets you dock or undock.</p><p>Now the user will never need to click the panel to make it show up, so we can make that operation do something else. Why not make clicking a panel pin it open? And don't do any of that &ldquo;pin the entire bunch of panels&rdquo; crap either, just pin that one panel and have it so the other panels can still pop up over it. Then, if you click the panel button again, it's unpinned. This is <em>so much better</em> than the clunky UI interfaces we have right now, and we did it by thinking about <em>Implicit UI Design</em>. By making the mouse click redundant, we could take that to <em>imply</em> that the user wants the panel to be pinned. Moving the mouse far away from the panel <em>implies</em> that the panel is no longer useful. To make sure a mistake is easy to correct, pinning a panel should be identical to simply having it be hovered over indefinitely, and should not change the surrounding UI in any way. Then a mistake can simply be undone by clicking the panel button again, which is a much larger target than a tiny little pin icon. Combine this with our improved docking above, so that a mistakenly undocked panel, when clicked and dragged again, has its old spot ready and waiting in case you want to undo your mistake.</p><div style=overflow:hidden><a href=/img/1j4kq.png><img src=/img/1j4kq.png alt="Panel holding"></a></div><p>It's 2012. I think its high time our user interfaces reflected that.</p></div><hr><time itemprop=datePublished pubdate=pubdate datetime=2012-02-24T10:18:00+00:00><i class="fa fa-clock-o fa-fw"></i>&nbsp;Published on <a href=https://erikmcclure.com/blog/implicit-ui-design/>February 24, 2012 at 10:18am</a></time><aside><i class="fa fa-share-square-o fa-fw"></i>&nbsp;share:<ul><li><a href="javascript:window.open('https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ferikmcclure.com%2fblog%2fimplicit-ui-design%2f','popup','width=600,height=400');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" d="M16.75 9H13.5V7a1 1 0 011-1h2V3H14a4 4 0 00-4 4V9H8v3h2v9h3.5V12H16z"/></svg></a><li><a href="javascript:window.open('https://twitter.com/intent/tweet?text=Implicit%20UI%20Design&url=https%3a%2f%2ferikmcclure.com%2fblog%2fimplicit-ui-design%2f','popup','width=600,height=256');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" opacity="0" d="M0 0h24v24H0z"/><path class="st0" d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572.0-4.658 2.086-4.658 4.66.0.364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342.0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3.0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376.0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57.0 13.255-7.098 13.255-13.254.0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg></a></li><li><a href="javascript:window.open('https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2ferikmcclure.com%2fblog%2fimplicit-ui-design%2f','popup','width=700,height=380');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><rect class="st0" height="11" width="4" x="3" y="9"/><circle class="st0" cx="5" cy="5" r="2"/><path class="st0" d="M16.5 8.25A4.47251 4.47251.0 0013 9.95343V9H9V20h4V13a2 2 0 014 0v7h4V12.75a4.5 4.5.0 00-4.5-4.5z"/></svg></a></li><li><a href="javascript:window.open('https://plus.google.com/share?app=110&url=https%3a%2f%2ferikmcclure.com%2fblog%2fimplicit-ui-design%2f','popup','width=400,height=380');"><svg xmlns="http://www.w3.org/2000/svg" viewBox="4 2 52.6934 50.6934" class="icon-img" height="24"><style>.st0{fill:#666}</style><g><path class="st0" d="M19.6671 25.7867c-.0075 1.7935.0 3.5869.0076 5.3803 3.0067.098 6.0208.0527 9.0275.098-1.3262 6.6689-10.3989 8.8315-15.199 4.4761C8.5674 31.9206 8.801 23.5412 13.9327 19.992c3.5869-2.8635 8.6884-2.1552 12.2752.324 1.4092-1.3036 2.7278-2.6977 4.0013-4.1445-2.984-2.3812-6.6462-4.0767-10.5421-3.8958-8.1307-.2713-15.6059 6.8497-15.7415 14.9805-.52 6.6462 3.8506 13.1644 10.0222 15.5155 6.1489 2.3661 14.031.7535 17.957-4.77 2.5922-3.4889 3.1498-7.98 2.8484-12.1999C29.7194 25.7641 24.6933 25.7716 19.6671 25.7867z"/><path class="st0" d="M49.0704 25.7641c-.0151-1.4996-.0226-3.0067-.0301-4.5062-1.4996.0-2.9916.0-4.4836.0-.0151 1.4996-.0301 2.9991-.0377 4.5062-1.5071.0075-3.0067.0151-4.5062.0302.0 1.4995.0 2.9915.0 4.4836 1.4995.0151 3.0066.0302 4.5062.0452.0151 1.4996.0151 2.9991.0302 4.4987 1.4996.0 2.9916.0 4.4911.0.0075-1.4996.015-2.9991.0301-4.5062 1.5071-.0151 3.0067-.0226 4.5062-.0377.0-1.4921.0-2.9916.0-4.4836C52.0771 25.7792 50.57 25.7792 49.0704 25.7641z"/></g></svg></a></li></ul></aside></article><article><a name=comments><h4>Comments</h4></a><hr><div class=comments><div id=c3495360871809190844><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src="//lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35" alt>
<b>scott</b><p>Don't forget: muscle memory also has a great deal to do with being able to find an item (ie, by position). And with a smaller set of items, your muscle memory can be just as effective without needing to identify by color. Then, color can be left for more important things to stand out, leaving the noise out of the way.<br><br>With the ginormous 2010 toolbar, you're right, monotone is going too far. But with the new simplified 19 item toolbar it sorta feels right.<br><br>I think they are moving in the right direction. Less toolbars and more emphasis on the known fact that developers are geeks and will seekout shortcut keys naturally (which as you mentioned is the appeal of systems like emacs and vim), thereby leaving the color to more contextually important needs, like to highlight something unusual or different.</p></div><hr><div class=reply id=c7415384556541063364><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAEs/UdovQFogllg/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>Smaller toolbar is good, but I am personally very reliant on color. I have yet to see any option for changing icons, but as soon as they just let me have my colored icons back I will stop complaining about it. That, and the toolbar color simply doesn't bother me. I would say they went in the right direction, but way too far into it. This is too extreme for my tastes.</p></div><hr><div class=reply id=c8637755950868588592><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//4.bp.blogspot.com/_97a-nJha7Io/TPkekeJ7PcI/AAAAAAAAAAM/9zDvKHxSErE/S220-s32/Uncompetative.png alt>
<b>Uncompetative</b><p>I have to agree with scott. I only check an icon once my mouse is almost upon it. Habituated usage enables me to find the rough location of a UI element. Colour and 3D should be avoided in icons unless they exceed the area of the tip of a finger, because screen resolutions and viewing distances conspire to make them hard to discern. A monochromatic silhouette suits a small set of frequently used actions whilst not detracting from the colour being used in the website under construction, or source code. Actually, it is preferable to reduce the number of icons even if there is room for a whole lot more. Maya's shelf makes this error - it also doesn't help that its icons are 50% too small and relatively rarely used. Given the complexity of the concepts they attempt to represent some kind of hover-to-reveal cyclic animation may help convey their function in the abscence of words. However, ultimately you may be better off using menus; yet, I don't feel conventional keyboard shortcuts scale to large systems - some hierarchical menu traversal through a chain of mnemonics with Return key confirmation may work better.<br><br>Personally, I'd like to see the icon bar relocated to the bottom edge of the window and the title bar rotated clockwise through 90 degrees so that the menu bar was on the top edge of the window. That way the mouse could locate targets more easily when the window was maximised even if it overshot as the pointer would be constrained by the boundary of the screen.<br><br>Anyway, thanks for a thought-provoking article.</p></div><hr><div id=c3473835130083808153><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//2.bp.blogspot.com/_ZoHTfJbZeoA/SZRl7qsp2rI/AAAAAAAAAJk/_tpCi9A5mTw/S220-s32/Alin.Constantin.jpg alt>
<b>Alin Constantin</b><p>> "If you somehow manage to get the window you want docked into a panel, it defaults to pinning the entire group of panels, regardless of whether they were pinned before or not. I just wanted to pin one!"<br><br>There is a way to do that, just not that obvious - drag the panel you want to pin out of the tab group, then dock it again - that will create a new docking group, separate from those that are in auto-hidden state.</p></div><hr><div class=reply id=c3561392233451858513><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAEs/UdovQFogllg/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>That's interesting. I tried that once and it didn't seem to work, but on a second attempt it apparently does.</p></div><hr><div id=c2867827262814216771><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src="//lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35" alt>
<b>TSchipper</b><p>It's funny how your second example, with the docking panels, shows the flip side of implicit design - sometimes the user does not think the way you think he does.<br><br>I guess the rationale behind the 'pin all panels' action was that if a user is docking windows into panels, this is probably the start of some sort of task and he/she is preparing his/her UI for it - meaning they'll want to dock multiple panels in all probability.<br>Turns out this isn't necessarily true.<br><br>While implicit UI design has some advantages, it also comes with disadvantages, and quite dangerous ones.<br><br>- While an action that requires you to click three times is more cumbersome than an action that requires you to hover and click once, there are two steps in this process hidden from the user. The designer assumes that the user knows what these two steps were, because they fit into the logical thinking process behind that step.<br>However, when the user _doesn't_ know the interface stops making sense to them. Your application becomes less transparent to the user, harder to figure out at first, because it does not show the steps it is performing based on an action.<br><br>- By letting the application decide what the users want to do, you sacrifice flexibility.<br>To take even a solid example such as the tooltip dragging: What if I bring up the tooltip on var1, then the tooltip overlays my declaration of var2, for which I've forgotten the exact name? I'd be tempted to drag the tooltip around so I could see what was underneath, yet this would end up pinning it.<br>The danger here is constraining a users workflow or habits to fit your own ideals, and it can easily happen if you take the UI intelligence too far. What if the application starts deciding whether you want to cut or copy a bit of code based on the code you have selected? After all, since code duplication is bad, you'd never want to copy an entire function in the same document right? A decision that makes perfect sense from a development point of view, but one that you'll agree not many users will be happy about.<br>This is a paradigm in the field I originally come from, industrial product design.<br>If you take something as simple as a chair and start compiling a list of requirements for it, it's easy to assume that it just needs to be able to bear the users weight on the seat, and that it shouldn't fall over. But ask yourself - have you ever standing-sat casually on the armrest of a chair when having a conversation? Have you ever tipped your chair backwards to stand on two legs while sitting on it?<br>These are not functions that a chair is designed for, but users do perform them quite often.<br><br>- Don't underestimate the psychological value of a click, especially for UI design aimed on non-techies. It is a conscious action that one commits to when one is sure that they want to perform the action it will trigger. This creates a sense of security in using an interface because the user knows that nothing will happen as long as they don't click on stuff where they don't know what it does.<br>If we take your example of all kinds of windows opening and closing when you move the mouse over their tabs - that is going to be scary for a typical user. They're just moving the mouse around, and all of a sudden they changed browser tabs. Does Undo work? No. Darn. What happened?<br>Activating elements in a UI based on hovering is akin to building a physical keyboard that starts typing when you put your fingers over the keys - it isn't all that practical in most cases.<br>Reason number one being that, in order to prevent chaos on a simple mouse move, you'd want a hover delay on most actions. After this delay is added, a simple mouse click would probably have been faster anyway.<br>--<br><br>The problems you cited can really be solved using any type of UI design philosophy, as long as you stick to one rule:<br>- Know your user, and design for _them_, not who you think they should be.</p></div><hr><div class=reply id=c129938107544110101><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAEs/UdovQFogllg/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>"I'd be tempted to drag the tooltip around so I could see what was underneath, yet this would end up pinning it."<br><br>But you can't drag around the tooltip without pinning it anyway. The problems you have cited are simply the consequence of taking an implicit UI design philosophy too far - and if you take ANYTHING too far, the results are never pretty.</p></div><hr><div id=c3641431318452499209><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh3.googleusercontent.com/-R0kKiPEd6ZE/AAAAAAAAAAI/AAAAAAAAAEk/N9t02GYsy3s/s32-c/photo.jpg alt>
<b>Hans Polak</b><p>Interesting post. I haven't worked with VS in a while, so I can't get into the fine detail. But the question that enters my mind is: why is this not a 'ribbon' type interface?<br><br>The ribbon interface was invented at MS and has a number of benefits. 1. It's always the same size. 2. Every command can be executed with the keyboard. 3. Icons are grouped and the most important ones (by frequency) are bigger.<br><br>I'm in favor of docking windows, but it's always hard to get it right. Your suggestion to make a collapsible panel is pretty good. I hate it when the docked windows pop up and eat sceen space from other docked windows.</p></div><hr><div class=reply id=c7218571851082137651><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAEs/UdovQFogllg/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>Judging from the direction Microsoft is going, its trying to shrink the toolbar. The ribbon is nice for functionality but is large and unwieldy. Hence it doesn't bring much benefit to an IDE.</p></div><hr><div class=reply id=c7814067717559088715><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh3.googleusercontent.com/-R0kKiPEd6ZE/AAAAAAAAAAI/AAAAAAAAAEk/N9t02GYsy3s/s32-c/photo.jpg alt>
<b>Hans Polak</b><p>Have you read these articles http://blogs.msdn.com/b/jensenh/archive/2006/03/28/563007.aspx about the ribbon design? Jensen Harris argues the ribbon occupies less screen real estate than the combination of other interface elements.<br><br>Of course in an IDE, the interface should also need the 'status' windows, but these could be tabs or collapsible or ...</p></div><hr><div class=reply id=c3672232785080612018><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAEs/UdovQFogllg/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>Seeing as a lot of people are arguing that you should get rid of the entire toolbar, I'm pretty sure the screen real estate taken up by the ribbon is pretty much unacceptable, since said other interface elements shouldn't be in the IDE anyway.</p></div><hr><div id=c6098474805059520200><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src="//lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35" alt>
<b>Dave Widel</b><p>I always dock the find window when I'm doing a lot of find and replacing. I have to because if I don't they move it to a new random location every 3rd find and I sometimes end up clicking the wrong button.</p></div><hr><div class=reply id=c5292657467663549041><div class=reply-arrow><i class="fa fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAEs/UdovQFogllg/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>The real problem here is them trying to move the find window for you. Even then, you can still let the find window be dockable if you make mistakes easier to recover from.</p></div></div><div class=comments></div><hr><div class=wrapcommento><div id=commento></div><script src=https://cdn.commento.io/js/commento.js></script></div></form></article></section><section class=archive><article><img src=https://erikmcclure.com/img/avatar.th.png alt=Avatar width=180 height=180><h2>Archive</h2><ol><li><details><summary>2022</summary><ul><li><a href=/blog/never-respect-my-elders-after-what-they-did/>I'll Never Respect My Elders After What They've Done</a></li><li><a href=/blog/camp-vista/>Camp Vista - Growing Up Next To Microsoft</a></li></ul></details></li><li><details><summary>2021</summary><ul><li><a href=/blog/blockchain-new-javascript/>Blockchain Is The New JavaScript</a></li><li><a href=/blog/cpp-constructors-memory-and-lifetimes/>C++ Constructors, Memory, and Lifetimes</a></li><li><a href=/blog/factorio-is-best-interview-we-have/>Factorio Is The Best Technical Interview We Have</a></li></ul></details></li><li><details><summary>2020</summary><ul><li><a href=/blog/why-you-cant-use-prebuilt-llvm-with-cpp17/>Why You Can't Use Prebuilt LLVM 10.0 with C++17</a></li><li><a href=/blog/someone-is-stealing-tracker-songs/>Someone Is Stealing Tracker Songs And Selling Them</a></li><li><a href=/blog/pressure-based-anti-spam-for-discord-bots/>Pressure Based Anti-Spam for Discord Bots</a></li></ul></details></li><li><details><summary>2019</summary><ul><li><a href=/blog/name-shadowing-should-be-an-operator/>Name Shadowing Should Be An Operator</a></li><li><a href=/blog/a-rant-on-terra/>A Rant On Terra</a></li><li><a href=/blog/risc-is-fundamentally-unscalable/>RISC Is Fundamentally Unscalable</a></li></ul></details></li><li><details><summary>2018</summary><ul><li><a href=/blog/software-engineering-is-bad-but-it-s-not-that-bad/>Software Engineering Is Bad, But That's Not Why</a></li><li><a href=/blog/why-do-people-use-the-wrong-email-/>Why Do People Use The Wrong Email?</a></li><li><a href=/blog/software-optimizes-to-single-points-of-failure/>Software Optimizes to Single Points of Failure</a></li><li><a href=/blog/migrating-to-static-blog/>Migrating To A Static Blog</a></li><li><a href=/blog/how-to-avoid-memorizing-times-tables/>How To Avoid Memorizing Times Tables</a></li></ul></details></li><li><details><summary>2017</summary><ul><li><a href=/blog/ignoring-outliers-creates-racist/>Ignoring Outliers Creates Racist Algorithms</a></li><li><a href=/blog/i-used-to-want-to-work-for-google/>I Used To Want To Work For Google</a></li><li><a href=/blog/sexist-programmers-are-awful-engineers/>Sexist Programmers Are Awful Engineers</a></li><li><a href=/blog/why-i-never-built-my-soundcloud-killer/>Why I Never Built My SoundCloud Killer</a></li><li><a href=/blog/integrating-luajit-and-autogenerating-c/>Integrating LuaJIT and Autogenerating C Bindings In Visual Studio</a></li><li><a href=/blog/discord-rise-of-bot-wars/>Discord: Rise Of The Bot Wars</a></li><li><a href=/blog/programmers-should-take-linguistics/>Programmers Should Take Linguistics</a></li><li><a href=/blog/companies-cant-be-apolitical/>Companies Can't Be Apolitical</a></li><li><a href=/blog/i-cant-hear-anything-below-80-hz/>I Can't Hear Anything Below 80 Hz*</a></li><li><a href=/blog/windows-wont-let-my-program-crash/>Windows Won't Let My Program Crash</a></li><li><a href=/blog/directx-is-terrifying/>DirectX Is Terrifying</a></li><li><a href=/blog/our-software-is-beacon-of-hope/>Our Software Is a Beacon of Hope</a></li></ul></details></li><li><details><summary>2016</summary><ul><li><a href=/blog/everyone-does-srgb-wrong-because/>Everyone Does sRGB Wrong Because Everyone Else Does sRGB Wrong</a></li><li><a href=/blog/mathematical-notation-is-awful/>Mathematical Notation Is Awful</a></li><li><a href=/blog/the-gpl-is-usually-overkill/>The GPL Is Usually Overkill</a></li><li><a href=/blog/the-right-to-ignore-difference-between/>The Right To Ignore: The Difference Between Free Speech And Harassment</a></li></ul></details></li><li><details><summary>2015</summary><ul><li><a href=/blog/there-will-never-be-one-true/>There Will Never Be One True Programming Language</a></li><li><a href=/blog/abortion-has-no-moral-high-ground/>Abortion Has No Moral High Ground</a></li><li><a href=/blog/i-tried-to-install-linux-and-now-i/>I Tried To Install Linux And Now I Regret Everything</a></li><li><a href=/blog/you-arent-designing-software-for-robots/>We Aren't Designing Software For Robots</a></li><li><a href=/blog/using-data-to-balance-your-game-pony/>Using Data To Balance Your Game: Pony Clicker Analysis</a></li><li><a href=/blog/is-there-commercial-open-source-license/>Is There A Commercial Open Source License?</a></li><li><a href=/blog/does-anyone-actually-want-good-software/>Does Anyone Actually Want Good Software?</a></li><li><a href=/blog/why-dont-you-just-fire-them/>Why Don't You Just Fire Them?</a></li></ul></details></li><li><details><summary>2014</summary><ul><li><a href=/blog/how-not-to-sell-software/>How Not To Install Software</a></li><li><a href=/blog/not-reinventing-wheel-is-anticompetitive/>Never Reinventing The Wheel Is Anticompetitive</a></li><li><a href=/blog/everyone-can-be-above-average/>Everyone Can Be Above Average</a></li><li><a href=/blog/can-we-choose-what-we-enjoy/>Can We Choose What We Enjoy?</a></li><li><a href=/blog/how-to-make-your-profiler-10x-faster/>How To Make Your Profiler 10x Faster</a></li><li><a href=/blog/the-problem-with-photorealism/>The Problem With Photorealism</a></li><li><a href=/blog/success-is-relative/>Success Is Relative</a></li></ul></details></li><li><details><summary>2013</summary><ul><li><a href=/blog/googles-decline-really-bugs-me/>Google's Decline Really Bugs Me</a></li><li><a href=/blog/the-educational-imbroglio/>The Educational Imbroglio</a></li><li><a href=/blog/the-ladder-climbing-generation/>The Ladder-Climbing Generation</a></li><li><a href=/blog/the-microsoft-word-problem/>The Microsoft Word Problem</a></li><li><a href=/blog/write-less-code/>Write Less Code</a></li><li><a href=/blog/most-people-have-shitty-computers/>Most People Have Shitty Computers</a></li><li><a href=/blog/leap-motion-impressions-input/>Leap Motion Impressions, Input Sanitation, and 3D Gesture Ideas</a></li><li><a href=/blog/aurora-theory-released/>Aurora Theory Released!</a></li><li><a href=/blog/what-i-learned-in-college/>What I Learned In College</a></li><li><a href=/blog/how-to-complain-about-men-and-be-sexist/>How To Complain About Men And Be Sexist At The Same Time</a></li><li><a href=/blog/course-notes/>Course Notes</a></li><li><a href=/blog/contact/>Contact</a></li><li><a href=/blog/the-dark-side-of-htmlcss/>The Dark Side of Web Development</a></li><li><a href=/blog/windows-breaks-assert-inside/>Windows Breaks assert() Inside WM_CANCELMODE</a></li><li><a href=/blog/dreams-are-worth-fighting-for/>Dreams Are Worth Fighting For</a></li><li><a href=/blog/the-productivity-fallacy/>The Productivity Fallacy</a></li><li><a href=/blog/the-earbud-loudness-wars/>The Earbud Loudness Wars</a></li></ul></details></li><li><details><summary>2012</summary><ul><li><a href=/blog/giant-list-of-free-samples/>Giant List of FREE SAMPLES</a></li><li><a href=/blog/the-weekend-apelsin-got-lost-all-time/>The Weekend I Got Lost All The Time</a></li><li><a href=/blog/c-to-c-tutorial-part-4-operator-overload/>C# to C++ Tutorial - Part 4: Operator Overload</a></li><li><a href=/blog/7-problems-raytracing-doesnt-solve/>7 Problems Raytracing Doesn't Solve</a></li><li><a href=/blog/teenage-rebellion-as-failure-of-society/>Teenage Rebellion as a Failure of Society</a></li><li><a href=/blog/analyzing-xkcd-click-and-drag/>Analyzing XKCD: Click and Drag</a></li><li><a href=/blog/what-is-right-answer/>What Is A Right Answer?</a></li><li><a href=/blog/coordinate-systems-and-cascading/>Coordinate Systems And Cascading Stupidity</a></li><li><a href=/blog/how-joysticks-ruined-my-graphics-engine/>How Joysticks Ruined My Graphics Engine</a></li><li><a href=/blog/properly-dreaming-about-success/>Properly Dreaming About Success</a></li><li><a href=/blog/multithreading-problems-in-game-design/>Multithreading Problems In Game Design</a></li><li><a href=/blog/ip-law-makes-you-asshole/>IP Law Makes You an Asshole</a></li><li><a href=/blog/stop-following-rules/>Stop Following The Rules</a></li><li><a href=/blog/standards-problem/>The Standards Problem</a></li><li><a href=/blog/an-evidence-based-refutation-of-the-project-glass-parodies/>An evidence-based refutation of the Project Glass parodies</a></li><li><a href=/blog/language-wars-are-pointless/>Language Wars Are Pointless</a></li><li><a href=/blog/why-windows-8-does-right-thing-wrong/>Why Windows 8 Does The Right Thing The Wrong Way</a></li><li><a href=/blog/well-that-was-interesting/>Well That Was Interesting</a></li><li><a href=/blog/visual-studio-broke-my-computer/>Visual Studio Broke My Computer</a></li><li><a href=/blog/hiring-wrong-people/>Hiring the Wrong People</a></li><li><a href=/blog/chill-out/>Chill Out</a></li><li><a href=/blog/implicit-ui-design/>Implicit UI Design</a></li><li><a href=/blog/linux-mint-12-kde/>Linux Mint 12 KDE</a></li><li><a href=/blog/new-post/>'Programmer' is an Overgeneralization</a></li><li><a href=/blog/wikipedias-identity-crisis/>Wikipedia's Identity Crisis</a></li></ul></details></li><li><details><summary>2011</summary><ul><li><a href=/blog/your-esoteric-language-is-useless/>Your Esoteric Language is Useless</a></li><li><a href=/blog/great-mystery-of-linear-gradient/>The Great Mystery of Linear Gradient Lighting</a></li><li><a href=/blog/signed-integers-considered-stupid-like/>Signed Integers Considered Stupid (Like This Title)</a></li><li><a href=/blog/why-kids-hate-math/>Why Kids Hate Math</a></li><li><a href=/blog/importance-of-importance/>Don't Work on Someone Else's Dream</a></li><li><a href=/blog/c-to-c-tutorial-part-3-classes-and/>C# to C++ Tutorial - Part 3: Classes and Structs and Inheritance (OH MY!)</a></li><li><a href=/blog/problem-of-vsync/>The Problem of Vsync</a></li><li><a href=/blog/musical-genres/>Musical Genres</a></li><li><a href=/blog/c-to-c-tutorial-part-2-pointers/>C# to C++ Tutorial - Part 2: Pointers Everywhere!</a></li><li><a href=/blog/radians-explanation/>Radians: An explanation</a></li><li><a href=/blog/c-to-c-tutorial-part-1-basics-of-syntax/>C# to C++ Tutorial - Part 1: Basics of Syntax</a></li><li><a href=/blog/on-hackers/>On Hacking (or Why We Need Security Ratings)</a></li><li><a href=/blog/my-mom-had-heart-attack/>My Mom Had a Heart Attack</a></li><li><a href=/blog/religion-problem-perspectives/>The Religion Problem: Perspectives</a></li><li><a href=/blog/ninth-circle-of-bugs/>The Ninth Circle of Bugs</a></li><li><a href=/blog/save-rss/>Save RSS</a></li><li><a href=/blog/college-is-broken/>College Is Broken</a></li><li><a href=/blog/outside-perspective-on-psn-fiasco/>An Outside Perspective on the PSN Fiasco</a></li><li><a href=/blog/future-predictions/>Future Predictions</a></li><li><a href=/blog/investigating-low-level-cpu-performance/>Investigating Low-level CPU Performance</a></li><li><a href=/blog/bullying-never-stops/>The Bullying Never Stops</a></li></ul></details></li><li><details><summary>2010</summary><ul><li><a href=/blog/aquaria-hints/>Aquaria Hints</a></li><li><a href=/blog/im-failure/>The IM Failure</a></li><li><a href=/blog/how-to-train-your-dragon/>How To Train Your Dragon</a></li><li><a href=/blog/album-for-sale-renascent/>Album For Sale! [Renascent]</a></li><li><a href=/blog/wavsaver/>WavSaver</a></li><li><a href=/blog/pixel-perfect-hit-testing/>Pixel Perfect Hit Testing</a></li><li><a href=/blog/fractal-cycle-screensaver/>Fractal Cycle Screensaver</a></li><li><a href=/blog/8-bit-color-cycling/>8-bit color cycling</a></li><li><a href=/blog/physics-networking/>Physics Networking</a></li><li><a href=/blog/assembly-cas-implementation/>Assembly CAS implementation</a></li><li><a href=/blog/function-pointer-speed/>Function Pointer Speed</a></li><li><a href=/blog/most-bizarre-error-ever/>Most Bizarre Error Ever</a></li><li><a href=/blog/floating-point-preformance/>Floating Point Preformance</a></li><li><a href=/blog/watch-this-now/>Watch This Now</a></li></ul></details></li><li><details><summary>2009</summary><ul><li><a href=/blog/physics-oriented-network-interpolation/>Physics-oriented Network Interpolation</a></li><li><a href=/blog/proving-strong-ai/>Proving Strong AI</a></li><li><a href=/blog/i-now-have-lj/>I now have an LJ</a></li></ul></details></li></ol></article></section></main><footer><p><span>Copyright &copy;2022 Erik McClure</span> <a href=https://erikmcclure.com/sitemap.xml>Sitemap</a> | <a href=https://erikmcclure.com/blog/index.xml>RSS Feed</a></p></footer></div><script>"use strict";window.onload=function(){var t=document.getElementsByClassName('math');for(var i=0,len=t.length;i<len;i++){renderMathInElement(t[i],{delimiters:[{left:"$$",right:"$$",display:false},{left:"\\[",right:"\\]",display:true}]});}}</script></body></html>