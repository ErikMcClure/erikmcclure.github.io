<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=Edge"><meta http-equiv=permissions-policy content="interest-cohort=()"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#2b7bb5"><meta name=copyright content="Copyright (c)2024 Erik McClure"><meta name=keywords content="games,music,code,erik mcclure,erikmcclure,aurora theory,sweetie bot,discord,feathergui,fading light,tinyoal,cloud hop"><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"><meta name=google-site-verification content="Oxb2ia8HjcHLXlvstA8xPpQO3BO_y15Ds2Ia-feq1MQ"><meta name=generator content="Hugo 0.119.0"><link rel=me href=https://equestria.social/@cloudhop><link rel=canonical href=https://erikmcclure.com/blog/multithreading-problems-in-game-design/><link rel=apple-touch-icon href=https://erikmcclure.com/favicon.ico><link rel="shortcut icon" type=image/x-icon href=https://erikmcclure.com/favicon.ico><link rel=stylesheet href=https://erikmcclure.com/css/main.css><link rel=stylesheet href=https://erikmcclure.com/css/prism.css rel=stylesheet><link rel=stylesheet href=https://erikmcclure.com/css/katex.min.css rel=stylesheet><link rel=stylesheet href=https://erikmcclure.com/css/fontawesome.min.css><link rel=stylesheet href=https://erikmcclure.com/css/regular.min.css><link rel=stylesheet href=https://erikmcclure.com/css/brands.min.css><link rel=stylesheet href=https://erikmcclure.com/css/solid.min.css><link rel=alternate type=application/rss+xml title="Erik McClure - RSS" href=https://erikmcclure.com/blog/index.xml><meta property="og:type" content="article"><title>Multithreading Problems In Game Design</title><meta property="og:title" content="Multithreading Problems In Game Design"><meta name=twitter:title content="Multithreading Problems In Game Design"><meta itemprop=name content="Multithreading Problems In Game Design"><meta name=description content="A couple years ago, when I first started designing a game engine to unify Box2D and my graphics engine, I thought this was a superb opportunity to join all the cool kids and multithread it. I mean all the other game developers were talking about having a thread for graphics, a thread for physics, a thread for audio, etc. etc. etc. So I spent a lot of time teaching myself various lockless threading techniques and building quite a few iterations of various multithreading structures."><meta property="og:description" content="A couple years ago, when I first started designing a game engine to unify Box2D and my graphics engine, I thought this was a superb opportunity to join all the cool kids and multithread it. I mean all the other game developers were talking about having a thread for graphics, a thread for physics, a thread for audio, etc. etc. etc. So I spent a lot of time teaching myself various lockless threading techniques and building quite a few iterations of various multithreading structures."><meta name=twitter:description content="A couple years ago, when I first started designing a game engine to unify Box2D and my graphics engine, I thought this was a superb opportunity to join all the cool kids and multithread it. I mean all the other game developers were talking about having a thread for graphics, a thread for physics, a thread for audio, etc. etc. etc. So I spent a lot of time teaching myself various lockless threading techniques and building quite a few iterations of various multithreading structures."><meta itemprop=description content="A couple years ago, when I first started designing a game engine to unify Box2D and my graphics engine, I thought this was a superb opportunity to join all the cool kids and multithread it. I mean all the other game developers were talking about having a thread for graphics, a thread for physics, a thread for audio, etc. etc. etc. So I spent a lot of time teaching myself various lockless threading techniques and building quite a few iterations of various multithreading structures."><meta property="og:url" content="https://erikmcclure.com/"><meta property="og:site_name" content="Erik McClure"><meta property="og:image" content="https://erikmcclure.com/img/avatar.png"><meta property="og:locale" content="en-US"><meta property="article:author" content="Erik McClure"><meta name=twitter:card content="summary"><meta name=twitter:site content="@erikmcclure0173"><meta name=twitter:creator content="@erikmcclure0173"><meta name=twitter:image content="https://erikmcclure.com/img/avatar.png"><meta name=twitter:dnt content="on"><link href=https://plus.google.com/104896885003230920472 rel=publisher><meta itemprop=image content="https://erikmcclure.com/img/avatar.png"><meta name=last-updated content="20120523-23:46:00.000"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-63026815-3"></script>
<script defer src=https://erikmcclure.com/syntax-prism.js></script>
<script defer src=https://erikmcclure.com/katex.min.js></script>
<script defer src=https://erikmcclure.com/mathtex-script-type.min.js></script>
<script defer src=https://erikmcclure.com/auto-render.min.js></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-63026815-3")</script></head><body><div id=container><header><nav><ul><li><a href=/blog/ title=Blog><i class="fa-solid fa-book fa-fw fa-lg"></i>&nbsp;<p>Blog</p></a></li><li><a href=/projects/ title=Projects><i class="fa-solid fa-briefcase fa-fw fa-lg"></i>&nbsp;<p>Projects</p></a></li><li><a href=https://erikmcclure.bandcamp.com title=Bandcamp><i class="fa-brands fa-bandcamp fa-fw fa-lg"></i>&nbsp;<p>Bandcamp</p></a></li><li><a href=https://github.com/erikmcclure title=Github><i class="fa-brands fa-github fa-fw fa-lg"></i>&nbsp;<p>Github</p></a></li><li><a href=/web/ title=Websites><i class="fa-solid fa-globe fa-fw fa-lg"></i>&nbsp;<p>Websites</p></a></li></ul></nav><div class=dim><h1>Erik McClure</h1></div></header><main class=blog><section><meta itemprop=mainEntityOfPage itemtype=https://schema.org/WebPage content="https://erikmcclure.com/"><meta itemprop=dateModified content="2012-05-23T23:46:00+00:00"><meta itemprop=headline content="Multithreading Problems In Game Design"><meta itemprop=description content="A couple years ago, when I first started designing a game engine to unify Box2D and my graphics engine, I thought this was a superb opportunity to join all the cool kids and multithread it. I mean all the other game developers were talking about having a thread for graphics, a thread for physics, a thread for audio, etc. etc. etc. So I spent a lot of time teaching myself various lockless threading techniques and building quite a few iterations of various multithreading structures."><meta itemprop=url content="https://erikmcclure.com/blog/multithreading-problems-in-game-design/"><div itemprop=publisher itemscope itemtype=https://schema.org/Organization><div itemprop=logo itemscope itemtype=https://schema.org/ImageObject><meta itemprop=url content="https://erikmcclure.com/img/avatar.png"><meta itemprop=width content="140"><meta itemprop=height content="140"></div><meta itemprop=name content="Erik McClure"></div><div itemprop=author itemscope itemtype=https://schema.org/Person><meta itemprop=name content="Erik McClure"></div><article><h4>Multithreading Problems In Game Design</h4><hr><div class=padding><p>A couple years ago, when I first started designing a game engine to unify Box2D and my graphics engine, I thought this was a superb opportunity to join all the cool kids and multithread it. I mean all the other game developers were talking about having a thread for graphics, a thread for physics, a thread for audio, etc. etc. etc. So I spent a lot of time teaching myself various lockless threading techniques and building quite a few iterations of various multithreading structures. Almost all of them failed spectacularly for various reasons, but in the end they were all too complicated.</p><p>I eventually settled on a single worker thread that was sent off to start working on the physics at the beginning of a frame render. Then at the beginning of each subsequent frame I would check to see if the physics were done, and if so sync the physics and graphics and start up another physics render iteration. It was a very clean solution, but fundamentally flawed. For one, it introduces an inescapable frame of input lag.</p><pre>Single Thread Low Load
&nbsp;&nbsp;FRAME 1&nbsp;&nbsp; +----+
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|
. Input1 -> |&nbsp;&nbsp;&nbsp;&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|[__]| Physics&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|[__]| Render&nbsp;&nbsp;&nbsp;&nbsp;
. FRAME 2&nbsp;&nbsp; +----+ INPUT 1 ON BACKBUFFER
. Input2 -> |&nbsp;&nbsp;&nbsp;&nbsp;|
. Process ->|&nbsp;&nbsp;&nbsp;&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|[__]| Physics
. Input3 -> |[__]| Render
. FRAME 3&nbsp;&nbsp; +----+ INPUT 2 ON BACKBUFFER, INPUT 1 VISIBLE
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;|
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;|
. Process ->|[__]| Physics
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|[__]| Render
&nbsp;&nbsp;FRAME 4&nbsp;&nbsp; +----+ INPUT 3 ON BACKBUFFER, INPUT 2 VISIBLE

Multi Thread Low Load
&nbsp;&nbsp;FRAME 1&nbsp;&nbsp; +----+
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;| 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|
. Input1 -> |&nbsp;&nbsp;&nbsp;&nbsp;| 
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |[__]| Render/Physics START&nbsp;&nbsp;
. FRAME 2&nbsp;&nbsp; +----+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
. Input2 -> |____| Physics END
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;|
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;| 
. Input3 -> |[__]| Render/Physics START
. FRAME 3&nbsp;&nbsp; +----+ INPUT 1 ON BACKBUFFER
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |____|
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;| PHYSICS END
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;| 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|____| Render/Physics START
&nbsp;&nbsp;FRAME 4&nbsp;&nbsp; +----+ INPUT 2 ON BACKBUFFER, INPUT 1 VISIBLE</pre><p>The multithreading, by definition, results in any given physics update only being reflected in the next rendered frame, because the entire point of multithreading is to immediately start rendering the current frame as soon as you start calculating physics. This causes a number of latency issues, but in addition it requires that one introduce a separated &ldquo;physics update&rdquo; function to be executed only during the physics/graphics sync. As I soon found out, this is a massive architectural complication, especially when you try to put in scripting or let other languages use your engine.</p><p>There is another, more subtle problem with dedicated threads for graphics/physics/audio/AI/anything. <strong>It doesn&rsquo;t scale.</strong> Let&rsquo;s say you have a platformer - AI will be contained inside the game logic, and the absolute vast majority of your CPU time will either be spent in graphics or physics, or possibly both. That means your game effectively only has two threads that are doing any meaningful amount of work. Modern processors have <strong>8 logical cores</strong><sup><a href=#ft_1>1</a></sup>, and the best one currently available has <strong>12</strong>. You&rsquo;re using <em>two of them</em>. You introduced all this complexity and input lag just so you could use 16.6% of the processor instead of 8.3%.</p><p>Instead of trying to create a thread for each individual component, you <a href=http://inception.davepedu.com/>need to go deeper</a>. You have to parallelize each individual component separately, then tie them together in a single-threaded design. This has the added bonus of being vastly more friendly to single-threaded CPUs that <em>can&rsquo;t</em> thread things (like certain phones), because the parallization goes on at a lower level and is invisible to the overall architecture of the library. So instead of having a graphics thread and a physics thread, you simply call the physics update, then call the graphics update, and inside each physics and graphics update you spawn enough worker threads to match the number of cores you have to work with and concurrently process as much stuff as possible. This eliminates latency problems, complicated library designs, and it <em>scales forever</em>. Even if your initial implementation of concurrency won&rsquo;t handle 32 cores, because the concurrency is encapsulated inside the engine, you can just go back and change it later <em>without ever having to modify any programs that use the graphics engine</em>.</p><p>Consequently, don&rsquo;t try to multithread your games. It isn&rsquo;t worth it. Separately parallelize each individual component instead and write your game engine single-threaded; only use additional threads for asynchronous activities like resource loading.</p><p><span style=font-size:80%><br><sup><a name=ft_1>1</a></span> The processors actually only have 4 or 6 <em>physical</em> cores, but use hyperthreading techniques so that 8 or 12 logical cores are presented to the operating system. From a software point of view, however, this is immaterial.</span></p></div><hr><time itemprop=datePublished pubdate=pubdate datetime=2012-05-23T23:46:00+00:00><i class="fa-regular fa-clock fa-fw"></i>&nbsp;Published on <a href=https://erikmcclure.com/blog/multithreading-problems-in-game-design/>May 23, 2012 at 11:46pm</a></time><aside><i class="fa-regular fa-share-square fa-fw"></i>&nbsp;share:<ul><li><a href="javascript:window.open('https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ferikmcclure.com%2fblog%2fmultithreading-problems-in-game-design%2f','popup','width=600,height=400');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" d="M16.75 9H13.5V7a1 1 0 011-1h2V3H14a4 4 0 00-4 4V9H8v3h2v9h3.5V12H16z"/></svg></a><li><a href="javascript:window.open('https://twitter.com/intent/tweet?text=Multithreading%20Problems%20In%20Game%20Design&url=https%3a%2f%2ferikmcclure.com%2fblog%2fmultithreading-problems-in-game-design%2f','popup','width=600,height=256');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" opacity="0" d="M0 0h24v24H0z"/><path class="st0" d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572.0-4.658 2.086-4.658 4.66.0.364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342.0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3.0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376.0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57.0 13.255-7.098 13.255-13.254.0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg></a></li><li><a href="javascript:window.open('https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2ferikmcclure.com%2fblog%2fmultithreading-problems-in-game-design%2f','popup','width=700,height=380');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><rect class="st0" height="11" width="4" x="3" y="9"/><circle class="st0" cx="5" cy="5" r="2"/><path class="st0" d="M16.5 8.25A4.47251 4.47251.0 0013 9.95343V9H9V20h4V13a2 2 0 014 0v7h4V12.75a4.5 4.5.0 00-4.5-4.5z"/></svg></a></li></ul></aside></article><article><a name=comments><h4>Comments</h4></a><hr><div class=comments><div id=c3637745481770565563><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src="//lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35" alt>
<b>FeepingCreature</b><p>Well-written and well-reasoned. Thank you for this post.</p></div><hr><div id=c331938694313727808><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src="//lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35" alt>
<b>ioquatix</b><p>Interesting experience. I've personally found that multi-threading is a lot more stable as long as you manage the latency. As you've said, it isn't easy, but it can be done. I normally use threads for physics and rendering, and then also sub-divide the work in individual threads as is possible - e.g. using 2 or 4 threads for a particle simulation update, splitting the world up and working in different areas in the physics loop on different threads. Additionally, networking and audio are easier to manage on their own threads and then feed events back into the main physics loop. The physics loop can be tightly timed (e.g. running 120hz or more, tightly synchronised with other sub-systems or over the network) and I've also been investigating running a physics loop with double buffering to avoid locking for rendering. There are many interesting possibilities to utilise 8 hardware backed threads or more!</p></div><hr><div class=reply id=c3173736219480546550><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAEs/UdovQFogllg/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>Audio and networking are different - networking especially lends itself to a deferred, multithreaded design. Audio can be multithreaded, but I have found this to be of limited use. The thing is that trying to effectively manage that kind of threading is extremely difficult due to complex interdependencies between graphics and physics, hence why I feel a separated encapsulated concurrency model is more appropriate.</p></div><hr><div id=c3289504635235399072><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//1.bp.blogspot.com/_YL1LCjTe740/SbazRok2aBI/AAAAAAAAAAM/AMmtgEzGWT0/S220-s32/32533-148-030f.jpg alt>
<b>Christian</b><p>Modern gaming design would be well served making use of the vastly superior floating point operations of the GPU. I know many of the newer video cards are increasing in cores, memory, and speed all the time. How much work have you done leveraging the GPU vs CPU?</p></div><hr><div class=reply id=c2069849079060116426><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAEs/UdovQFogllg/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>That is a question of graphics engine design, and is somewhat dependent on one's choice of API. The issue is that the GPU isn't the CPU and thus there is a memory barrier between information on the GPU and information on the CPU, which causes all sorts of strange bottlenecks. I personally am working on building a GPU-based particle engine and using DX10's geometry shader for speeding up certain sections of rendering, such as shadow calculation. However I have also found that some things are best left to the CPU, because the CPU already has access to the information instead of trying to shuttle it all the way to the GPU to perform the calculations.</p></div><hr><div id=c4858375859719921825><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src="//lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35" alt>
<b>Tanner Bruce</b><p>How do you manage rendering, when OpenGL for example can only handle being rendered to from one thread?</p></div><hr><div class=reply id=c1359727527448171197><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAEs/UdovQFogllg/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>DirectX actually has facilities for multithreading, but they are inefficient and so it is in a similar situation. This is something I have been musing on, but I haven't actually tried anything. My approach to parallelization in my engine will likely be focused in two areas - the main culling performed using a kd-tree that then dumps images into a red-black tree for z-order sorting, and the actual rendering stage that has to make the transformation calculations before sending the image to the GPU. The problem with a 2D engine is that I can't just throw things to the GPU whenever they happen to be finished prerendering, I have to call the GPU in a very specific order so the images get rendered correctly. You can sidestep this by isolating which images actually overlap by hijacking the kd-tree that's used for culling, but doing so is complicated and difficult to make effective.<br><br>One method for the actual rendering would be to spawn a number of worker threads which then power through the linked list of images, and after finishing, pushing a finished render packet on to a stack and link the image position to it, then have a master thread work through the finished images as they are prerendered by simply walking through the linked list, waiting until the next image is ready. Unfortunately we then run into additional problems with the driver state and the general restriction that the graphics card can only be in one state at a time. This requires that any state-based manipulations of the graphics card be deferred to the master thread, since they must be done in order in a single-threaded context.<br><br>Still, this kind of multithreading is probably unnecessary, because the graphics engine offloads a significant amount of calculations to the GPU, such that it is not usually stressful on the CPU.</p></div><hr><div id=c2899917955386844286><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh3.googleusercontent.com/-uwLhDcc6ze4/AAAAAAAAAAI/AAAAAAAAAAA/40Ra3RcSSfc/s32-c/photo.jpg alt>
<b>Alex de Vries</b><p>Hi, I've also created multithreading (separate update and render thread), but don't come the conclusion that it isn't worth it. True, it is very difficult to implement decently, but it is worth it for games that require lots of CPU. The goals is to seperate the render-state from the world-state so you can triple buffer the render state. The delay you talk about can be 'solved' using partial synchronization and extrapolation.<br><br>For an explanation of the problem please check out:<br><a href=http://blog.slapware.eu/game-engine/programming/multithreaded-renderloop-part1/ rel=nofollow>http://blog.slapware.eu/game-engine/programming/multithreaded-renderloop-part1/</a><br><a href=http://blog.slapware.eu/game-engine/programming/multithreaded-renderloop-part2/ rel=nofollow>http://blog.slapware.eu/game-engine/programming/multithreaded-renderloop-part2/</a><br><br>The website discusses the problems and shows a decent (though difficult) solution. Both source and binaries can be downloaded.</p></div><hr><div class=reply id=c5162314495692244507><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>Your solution is unsuitable for a number of reasons. First, its complicated as hell, and second, because of this complexity, it is extraordinarily difficult to properly merge with an existing physics engine.<br><br>The primary issue, however, is that the most benefit does not come from separating CPU and GPU intensive tasks, but rather from processing as much information as possible concurrently. This is why it is more valuable to have a vastly simpler single-threaded pipeline where physics and graphics are individually parallelized to maximize CPU usage. This scales way better because now each added core will speed up the program, instead of the set increase in speed that a complex multithreading solution will involve.<br><br>For that matter, if you are going to multithread something, doing something complicated like this is a bad way of doing it. If you require a custom physics engine in the first place, then you should package physics along with graphics and use a task-based package model that simply concurrently processes everything at the same time. Your method isn't worth the complexity because there are superior ways of handling it. A good example is Civ V's multithreaded pipeline that packages render calls up into a task manager as needed, which achieves truly astounding performance without a super complicated world state.<br><br>Also, spinning on Sleep(0) for a thread is not recommended. It is usually a better idea, whenever possible, to simply put a thread to signaled sleep using SleepEx(INFINITE,true) and then using QueueUserAPC to wake it up. Windows can usually activate the thread in under 37 microseconds. Sleep(0) lets it wake up faster, but is not an effective way to relieve stress on the CPU.</p></div><hr><div class=reply id=c2574570570561152060><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh3.googleusercontent.com/-uwLhDcc6ze4/AAAAAAAAAAI/AAAAAAAAAAA/40Ra3RcSSfc/s32-c/photo.jpg alt>
<b>Alex de Vries</b><p>It is complicated as hell, I'll give you that. But I think you're misunderstanding what the proposed solution is trying to solve.<br><br>The render loop is should be as quick as possible, but multithreading adds a lot of overhead. You don't want to perform a lot of mutex checks in the renderloop. The render loop should be as mutex-free as possible.<br><br>The game/simulation must be deterministic (one of the goals from <a href=http://blog.slapware.eu/ rel=nofollow>slapware.eu</a>). So "position.X = position.X * elapsedGameTime" is not allowed, because depending on render speed for motion calculation makes it non-deterministic. You might think this is overkill, but determinism is really great for multiplayer games. If you'll shoot a grenade you often see some sort of latency because the server sends lots and lots of position updates for the grenade. With determinism you don't need to spam your internet connection with position-updates. Having a multithreaded implementation that allows for FPS-drops (and absurd FPS like over 9000) without slowing down the game and still being deterministic is a difficult problem to solve and hence the difficult solution. If you know of any other solution I really like to know about it, I find this stuff intriguingly interesting!<br><br>The solution does not spin on Sleep(0), that would be a seriously bad implementation (imho). The site discusses the how thread-switching may cause stuttering and the two proposed solutions are partial thread synchronization and motion extrapolation.<br><br>If you are using a custom physics engine, you'll just plug it into the update-thread. It is as easy to integrate as in any other single threaded method.<br><br>Using a 'task-manager' is the obvious way of multithreading and the solution from <a href=http://blog.slapware.eu/ rel=nofollow>http://blog.slapware.eu/</a> still allows for such implementation. Usually you'll create a producer-consumer queue, and generate tasks that your background threads will handle. If you are adding this to the solution from slapware then the update-thread will be the 'producer' and he will spawn a couple of background threads (consumers) to calculate physics, AI and other CPU related stuff.<br><br>At least you should have a separate producer-consumer queue for GPU-related stuff and CPU related stuff. If you optimally want to use your GPU you need 1 thread for all the drawing (heavy on GPU, light on the bus) and one thread for updating models and textures (light on GPU, heavy on the bus). Assuming you have only one GPU. And not to subtract from the achievements of CIV4, a great game, but it is not one of the most complicated games for an engine to handle. (semi-)top-down is relatively easy especially if the game is semi-2D, even if you support LOD-algorithms for awesome infinite zoom-out.<br><br>Luckily, the complicated stuff from the proposed solution is only in the engine and not in the game. It is still possible to do everything you want without writing absurdly complicated code when creating a game.</p></div><hr><div class=reply id=c8912959532236026106><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>You appear to misunderstand what reality is.<br><br>1. If you are using mutexes at all in your game engine, you have already fucked yourself beyond all hope of redemption. You should NEVER implement any algorithm that doesn't use some form of lockless or at least obstruction-free implementation.<br><br>2. Determinism is impossible. Even if floating point errors were not an issue, *networking itself* guarantees that you will have consistency issues no matter what you do, because packet travel times are random, erratic, and sometimes they don't bother showing up at all. Even if they were perfectly reliable, lag ensures the world state will always be inconsistent with itself no matter what you do. The potential inconsistencies that can arise in a threaded actor-model concurrent system are extremely minor when handled properly, and as a result can simply be dealt with through the same correction algorithms that must deal with floating point inconsistencies and errant packets.<br><br>I can make a concurrent game engine that is highly efficient and won't suffer from any significant FPS drops, yet is vastly simpler than what you propose here, because you solve the problem from the wrong end. The future of games will be in engines that use actor-based concurrency models by packaging object information into immutable packets and processing them all using a swath of worker threads using multiple lockless queues that have virtually zero overhead and a single sync point per frame. This is simple, elegant, and is vastly more robust than the hellish complexity you propose. I can even do it for a 2D engine, where the rendering queue is strictly ordered. A 3D game is even easier to pull off, because you can render things wildly out of order using the z-buffer and clipping spaces.<br><br>This problem is not answered by creating separate threads that do specific things, its done by evaluating everything at the same time in small bursts. This will keep both the CPU and the GPU saturated with tasks without significant complexity. I was speaking of Civ V, not Civ IV, and Civ V pulled more out of the GPU than anyone else EVER DID. So unless you are saying your engine is literally faster than every other engine in the entire industry, because Civ V's engine is, you really shouldn't be talking.<br><br>And yes, that includes Unreal Engine 4, which simply does more fancy things, its raw rendering speed can't beat Civ V.</p></div><hr><div id=c6206156930516113659><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh3.googleusercontent.com/-uwLhDcc6ze4/AAAAAAAAAAI/AAAAAAAAAAA/40Ra3RcSSfc/s32-c/photo.jpg alt>
<b>Alex de Vries</b><p>I sense you too have a lot of knowledge about the subject, which makes this an interesting discussion. I'll try not to make it into some sort of flame-war between two techniques, because I really like to read what you have to say :)<br><br>1. Mutexes<br>I totally agree with you. Mutexes should be prevented wherever possible.<br><br>2. Determinism is possible.<br>Floating point errors occur, true, but if the floating point errors are consistent then there isn't any problem. This is also possible cross-platform because floating-operation are <a href=http://en.wikipedia.org/wiki/IEEE_floating_point rel=nofollow>standardized</a>. Most compilers even have flags to allow you to change the way that floating point are handled.<br>Network issues are no problem either, unless you use UDP (or some other protocol). For TCP/IP the order of the packets are guaranteed. This does not mean that packets arrive at your computer at the same time, but TCP uses a buffer and automatically asks for re-transmissions if needed. Your application will receive all packets in order. If there are any problems (some packet will never be received, even after asking for re-transmissions) the connection will just be dropped. Packet corruption is handled by check-sums (in both ip-packet-header and tcp-packet-header)<br><br>The complexity of a solution is never a real issue for me because I enjoy figuring out what the best approach is (for my situation). The technique I used is not as far fetched as you might think. It is a technique called <a href=http://vrjuggler.org/docs/vrjuggler/2.0/programmer.guide/programmer.guide/ch10s04.html#section.triple.buffering rel=nofollow>triple buffering</a> (not to be confused with triple buffering on the video card). CryENGINE 3 is another one of those great tripple-A game engines. I'm not going to compare these engines, lets just say that most these engines are pretty darn good. I'm certainly not going to compare something I have written in 1~2 weeks with a tripple-A engine. Especially because I have written this implementation in c#, lol. It is very difficult to look at a certain engine and determine what techniques they apply. They often limit themselves to saying things like "<i>we are supporting volumetric clouds</i>" or "<i>we have a taskmanager to optimally use all cores in your CPU</i>" without diving into the specifics of 'how' it is implemented. I wouldn't be surprised if these engines are also able apply a form of tripple buffering on render states.<br><br>I also agree with you that you'll need some sort of task manager to optimally use cores in your CPU/GPU. And the technique you describe seems pretty solid. We actually agree on most topics except for the one where I prefer a separation of 'task-manager' for GPU and CPU, while you just say that just one task-manager for both is good enough. I also use triple render-state buffering, but I probably wouldn't have implemented that if I didn't need determinism.<br><br>A task-manager with 50 workers for a dual-core CPU is silly as you probably agree with me. There should be some balance between the nr. of cores and the number of threads. The GPU and CPU are intrinsically different. They contain a different number of cores and the are connected through a bus that only allows one 'message' to be send to it at a time (protected by mutexes in the video card driver). Since the bus is protected with mutexes it should also seem silly to have more than 1 threat to try and send a message to the video card. Because they are so different it makes more sense to separate the queues so we are able to fine tune these queues (perhaps even setting thread-priorities).</p></div><hr><div class=reply id=c10388581716266356><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh3.googleusercontent.com/-uwLhDcc6ze4/AAAAAAAAAAI/AAAAAAAAAAA/40Ra3RcSSfc/s32-c/photo.jpg alt>
<b>Alex de Vries</b><p>Oh, P.S. Determinism in games is not outrageously naive. For both network-games and replay-files (For example Starcraft II). If you'd like to read about it <a href=http://www.aorensoftware.com/blog/2011/01/28/determinism-in-games/ rel=nofollow>http://www.aorensoftware.com/blog/2011/01/28/determinism-in-games/</a> seems to explain the basics pretty well.</p></div><hr><div class=reply id=c2195066744862361921><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>In my implementation, just like Civ V, I queue rendering calls into a single thread that sends them to the GPU as fast as possible. You'd do this no matter what technique you were using. The precalculations necessary are what the worker threads do. There are always as many worker threads as there are logical cores - for an i7 you'd have 8.<br><br>Triple buffering is a standard technique, but my technique implements something akin to it on a more distributed level. Each actor is, by itself, considered immutable, so a copy of it is made upon which calculations are done, and when this calculations are finished, the result is committed by flipping a pointer to ensure atomic usage of information across all actors. I feel like I should point out that your implementation is a particularly horrendous complication of triple buffering. Everyone uses something like that, its the only way to get anything done.<br><br>You completely missed that last point I made on determinism - even if all floating point calculations are executed perfectly and all packets arrive as expected, lag ensures that inconsistent situations will always crop up, and those inconsistencies will be several orders of magnitude more severe than any inconsistency that would occur due to out-of-order processing of objects within a single frame. You are trying to solve a problem that isn't a problem. You seem to think that my approach significantly sacrifices determinism when it really doesn't. You should be more worried about what happens when one player shoots another as he blows himself up in an explosion large enough to kill the first, which is exactly what that article you linked to points out, and in turn this implies that any indeterminacy created by my technique is manageable! So by definition the insanity you have created here isn't even necessary!</p></div><hr><div class=reply id=c2554555964538927524><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh3.googleusercontent.com/-uwLhDcc6ze4/AAAAAAAAAAI/AAAAAAAAAAA/40Ra3RcSSfc/s32-c/photo.jpg alt>
<b>Alex de Vries</b><p>You keep referring to the CIV V engine so you probably have read a lot about it. Could you refer me to the website/pdf that explains how they have implemented their rendering loop and worker queues? I can't seem to find it.<br><br>I am well aware of possible latency issues (and solutions) between client and server, but all those issues can be solved by letting the client's extrapolate game states and make a prediction of the changes caused by local actions. The difficulty lies in restoring game states on wrongful predictions, which for some games can be solved by sending a complete game state (on conflict only). For non-deterministic game engines this is way more difficult because each client's game state is by definition almost always wrong. To solve this for non-deterministic game engine you'll need to send position-information pretty much non-stop to prevent out-of-sync weirdness. So really, I do understand. I'm just saying that latency issues are not a good excuse to drop determinism.<br><br>The "problem" I tried to "solve" is creating a non blocking multithreaded deterministic game loop. You probably agree with me that this isn't easy to accomplish, just a couple of hour ago you claimed that determinism is impossible. You keep saying that I "<i>missed the point</i>" or that I "<i>misunderstand</i>" and calling my implementation "<i>horrendous</i>". Why are you saying such provocative things? Most of them not even true:<br>- the sleep(0) loop<br>- impossibility of non-determinism<br>- floating point errors make it non-determinsitic<br>- network packets arriving in the wrong order<br>- very difficult to integrate external physics module<br><br>I've shown you a different method of applying multithreading and it 'does' have advantages, even if you don't agree with me. This is the pseudo-code of my render loop. The only mutex is used when switching states.<br><br>while (true) {<br>RenderState latestUpdatedRenderState = world.GetLatestUpdatedRenderState(); /* Quick thread-safe pointer switch */<br>Draw(latestUpdatedRenderState);<br>FlipFrontAndBackBuffer();<br>}<br><br>I don't have to wait for physics calculations to complete, I can just render a new frame. No waiting, ever! Can't get much faster then that right? It is even possible to render at a higher FPS then the update-FPS because all positions are automatically extrapolated and inconsistencies are solved automatically. Not so "horrendous" now, is it? Even if the game is rendering at a meager 10FPS, the game speeds remains steady while still being deterministic.<br><br>Maybe we just have different goals for or engine. Especially for game-engines, there are seldom situations where a "one solution fits all" can be applied.</p></div><hr><div class=reply id=c8685781235327639257><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>You just said you tried specifically to solve the problem of determinancy, when I argue that it is not a significant problem in the first place, due to it needing to be solved elsewhere, and thus you are needlessly solving a problem that doesn't exist.<br><br>Non determinism is STILL impossible! All you have done to defend against this point is say that it can be managed, which is exactly what I pointed out.<br><br>I call your method horrendous because the render thread itself is attempting to extrapolate out positions, which is a big no-no, and you use a complicated object hierarchy, plus the internal design of the engine is complex and therefore susceptible to incredibly bizarre bugs. In fact, everything you do causes the exact problems that made me throw out my own multithreaded implementation due to potentially inconsistent physics states and lag. So if you don't consider those things to be a problem, then why would you offer your engine as an alternative to mine? Mine does nearly the same thing and has the same problems.<br><br>You basically did the same thing I did except in a much more roundabout, complicated way. You solved nothing.</p></div><hr><div class=reply id=c7959944261831159954><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh3.googleusercontent.com/-uwLhDcc6ze4/AAAAAAAAAAI/AAAAAAAAAAA/40Ra3RcSSfc/s32-c/photo.jpg alt>
<b>Alex de Vries</b><p>I think you meant "determinism is impossible". It is not about 'managing determinism', it either is, or isn't deterministic. Simple as that. It not something you 'solve'. The best way for being deterministic is by creating a fixed time step for updating the world (e.g. applying physics 60 times a second, even if the render-FPS is different). I find it really strange that you talk about the impossibility of determinism, we are talking about the same <a href=http://en.wikipedia.org/wiki/Deterministic_system rel=nofollow>thing</a> right?. Just download the sample from my website and see that at update-frame #1000 the position of the balls are always the same (no matter at what FPS you're running at). Determinism is possible. If you claim it isn't please give me an example.<br><br>You say extrapolation of position in the render thread is a big no-no. There is absolutely nothing wrong that, I don't know where you got that idea. There is nothing wrong it as long as you don't actually modify the state (which I don't).<br><br>You also call the internal design of my engine complex to the point it is susceptible to bizarre bugs. Complexity is an "eye of the beholder" thing. I have no problem understanding what is going, maybe it's too complex from your point of view, but not from mine. However, it is not something I recommend to anybody that is trying to make a game (it is better to use an existing engine).<br><br>My solution does not have any problems so, I'm not sure why you are saying that we share the same problems.<br><br>If you manage to convince me that you model is also deterministic, while being able to render at any FPS (without a slow down of the game) than you'll convince me that your simpler implementation is probably the better one. If you don't care about a deterministic game (which you don't, because you don't even believe in the existence of it) then my way of approaching things must seem unnecessary complex. I totally agree. If you don't care about stuff like that, then I too would have used a simpler method.<br><br>P.S. Do you have that link to the CIV V Engine? I really am interested in reading that.</p></div><hr><div class=reply id=c1529890685855220247><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh3.googleusercontent.com/-uwLhDcc6ze4/AAAAAAAAAAI/AAAAAAAAAAA/40Ra3RcSSfc/s32-c/photo.jpg alt>
<b>Alex de Vries</b><p>This discussion inspired me to type up some stuff of why determinism is a nice thing to have.<br><a href=http://blog.slapware.eu/game-engine/programming/deterministic-behavior/ rel=nofollow>http://blog.slapware.eu/game-engine/programming/deterministic-behavior/</a><br><br>I've also shown evidence that my engine is deterministic, so I assume this will convince you that determinism is indeed possible.<br><br>P.S. this blog-page is not yet officially published so it is subject to change. I still in the process of creating a new version of the engine...</p></div><hr><div class=reply id=c7109017547585993569><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>IF that is your definition of determinism, then every single solution I have ever built for this, including every single solution I will ever build, will be deterministic, and therefore I have absolutely no idea how ensuring that your engine was deterministic had any effect on your engine design.<br><br>Extrapolation on render thread == things go through walls before you realize they hit them. This is one of the reasons I abandoned several of my previous attempts, because of the potentially invalid physics state that would be rendered, even if the physics state itself was always consistent. Rather than solve that problem, you simply make it worse.<br><br>I keep pointing out problems your solution has, yet you continue to insist they are not problems.<br><br>Here's how you guarantee determinism in my model: Make all calculations depend on the previous frames' stale data. Ensure data gathering is done on the frame start sync step. Poof, its now deterministic. Of course, it now has a frame of lag, too, just like your solution does, even with extrapolation of positions because it is physically impossible for it to account for input it doesn't know about.<br><br>Civ V link: http://developer.amd.com/gpu_assets/Firaxis%20LORE.pps</p></div><hr><div id=c1019234638365130173><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh3.googleusercontent.com/-uwLhDcc6ze4/AAAAAAAAAAI/AAAAAAAAAAA/40Ra3RcSSfc/s32-c/photo.jpg alt>
<b>Alex de Vries</b><p>"<i>If that is your definition of determinism</i>"? Come on, it is a normal English word with a clear-cut definition. It is not like I'm making up words here. It's also really important for games (not all type of games though), so I thought you would be fairly familiar with the term.<br><br>My extrapolation does not invalidate the physics state. Assuming the update-thread runs at 60 FPS then at worst case the extrapolation will account for max. 16.6 ms of movement (and ~8.3 ms on average). This extrapolation is only used for rendering and not for modifying the physics state. If something goes through a wall because of extrapolation then at the next update frame it will already have been set to the right coordinates.<br><br>You keep pointing out problems where there are none, yet you continue to insist that there are. The comments you make, like the one on invalidating a physics state, makes me doubt you have actually read it. I get the impression that you just have glanced over it and thought that it's just some overly complicated jibberish. I don't mind if you don't want to read it, but please don't come up with obviously wrong 'problems' that my engine has.<br><br>If you make all calculation depend on the previous frame and gather input at start of the frame, then you're missing one important step. The physics should run at a fixed steps per second, shall we say 60FPS? Now imagine, if you will, your game being rendered on a 120 Hertz monitor. If you decide to render at 120 FPS you're only rendering 60 new frames per second. Any discrepancy between update-FPS and render-FPS will lead to nasty side effects! Simply increasing how many times you update per second won't help you that much. For your engine it is really weird to fix the update-thread to a certain FPS, as they are just 'jobs added to the queue'.<br><br>The best thing you said is "<i>I have absolutely no idea how ensuring that your engine was deterministic had any effect on your engine design.</i>". Maybe this is the reason why I have such a difficult time explaining to you how determinism should be enforced. On the other hand you say "<i>every single solution I have ever built for this [...] will be deterministic</i>", another obviously wrong statement. If you render your game at 1000 FPS how often you call your physics library? 1000 per second times right? You want to update the positions 1000 times otherwise rendering with such a high speed has no real benefit. Calculating physics with a time step determined by rendering speed will break determinism. <a href="http://box2d.org/forum/viewtopic.php?f=9&amp;t=8585" rel=nofollow>Box 2D physics are only deterministic of the timestep is constant.</a>.<br><br>Civilization 5 is a turn based game which simplifies creating network-protocols and replay-files, so there is no real added benefit for adding determinism in such a game. This is why I stated previously that the engine for Civilization 5 has it very easy. An RTS has way more hurdles to overcome so I'm more impressed with the engine used in Supreme Commander 2 and Starcraft 2, even if they don't look as beautiful. It is ignorant to think that CIV's approach is a one-solution-fits-all, which is exactly why I've posted the links on a deterministic non-blocking render loop.<br><br>If you'd like, I can come up with some resources that explain what determinism is, why it is important for (certain type of) games, why it is difficult to have determinism without fixing render-FPS and how determinism helps in simplifying network protocols for games (among other things).<br><br>Do you now understand why your game engine is not able to be deterministic without severe consequences?<br><br>Thanks for the link on CIV5's engine presentation. I really wish I was there to hear about the details :) Looking at those sheets really makes me want to continue experimenting with game engine techniques.</p></div><hr><div id=c2842715691887211400><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>I didn't SAY your extrapolation invalidated the physics state, I said that you RENDER an invalid physics state!<br><br>I keep pointing out problems and then you keep misinterpreting them.<br><br>Uh, every single solution I have ever written involves constant timesteps. Because I use Box2D. So yes, it is all deterministic. Sorry. Doing physics with a constant timestep is as simple as using box2D's accumulation method, which my method would do, and furthermore I argue that trying to render frames in between physics calculations is worthless because the extrapolation simply introduces artifacts, and if you can't render physics at 60 FPS you're screwed anyway. Hence, physics are blocking, and if they aren't blocking you either 1. aren't deterministic or 2. are extrapolating positions widely and are therefore rendering frames with an invalid physics state, even if the internal physics state is correct.<br><br>So I contend that trying to render faster than the physics timestep is useless, and therefore your solution is useless.</p></div><hr><div id=c6073788887083519745><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh3.googleusercontent.com/-uwLhDcc6ze4/AAAAAAAAAAI/AAAAAAAAAAA/40Ra3RcSSfc/s32-c/photo.jpg alt>
<b>Alex de Vries</b><p>rendering an invalid physics state when using extrapolation is sporadic and if it happens it probably doesn't even take 10ms. So you are telling me that you are limiting your game to 60FPS just to be deterministic? Wow, gamers with a monitors with any other frequency than 60 Herz must be pretty disappointed with your engine. Wait, even if you do not want to be deterministic you are using fixed time steps? You are aware that it is possible to use dynamic length time steps so the physics keep up with the render FPS, right?<br><br>Let me guess what you are going to say: "If the player wants 120 Hz, I'll just crank up the physics to 120 FPS", showing that you still don't get what we are trying to achieve by ensuring determinism.<br><br>I 'can' render faster then the physics time step. If physics runs at a meager 20FPS, everything still runs smoothly (because of a render FPS of 1000+ FPS and extrapolation) I can't even see those nasty physics artifacts you seem to dislike so much. At an update of 60 FPS this becomes even less of a problem. If you can call it a problem, as it isn't even noticeable.</p></div><hr><div class=reply id=c2069473163935769805><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>I have actually implemented dynamic timesteps before but I keep switching between dynamic and constant because I'm not sure which one has the most benefits yet. The primary reason I wasn't using dynamic timesteps was because I wasn't sure what kind of consequences it might have for the physics calculations. It wasn't much a matter of ensuring determinism as simply not caring about determinism and being more concerned about not destabilizing the physics simulation by using timesteps that are so small they blow up the floating point inaccuracies.<br><br>You can render faster than the physics time step and I think its useless. If your physics aren't rendering at a sufficiently high rate, everything else will suffer.<br><br>As far as I can tell, you have a more nuanced understanding of determinism than I do, however, in your efforts to ensure it, you have made multiple sacrifices that I was not willing to make even for a nondeterministic multithreaded scenario. Hence, even if I was trying to enforce determinism, I would not accept your solution, because I do not want to render an inconsistent physics step and I will not accept an additional frame of input lag.<br><br>I have, however, taken what you have said here to make a few small adjustments to my engine to ensure it actually is deterministic, since a primarily single-threaded engine should probably be deterministic anyway.</p></div><hr><div class=reply id=c528105383878526709><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh3.googleusercontent.com/-uwLhDcc6ze4/AAAAAAAAAAI/AAAAAAAAAAA/40Ra3RcSSfc/s32-c/photo.jpg alt>
<b>Alex de Vries</b><p>We clearly have a different opinion on where to prioritize. Lets just sum up the differences and call it a day.<br><br>1. Your engine uses multithreading that is easier to implement.<br>2. Your engine does not have a 1 frame (avg. ~8.3ms) lag for parsing input<br>3. Your engine will never cause physics artifacts (mine will sporadically have a render-artifact for one frame, most of the time not even visible depending on how hit boxes are created)<br><br>1. My engine has a faster render loop (does not have to wait on anything, ever, even if physics or AI turned out to be really slow in a CPU heavy game)<br>2. My engine is able to run in any FPS I like without having to sacrifice determinism (important for RTS games)<br>3. My engine will not slow down the game and physics, even if we are rending at 2FPS (important for network games)<br><br>Anything I forgot?<br><br>Oh P.S. If you are really interested an low-latency rendering I recommend reading articles/interviews/... from John Carmack (creater of doom). He is is still actively developing and is by many people considered to be a God of game engine optimizations. He has a hobby for Virtual Reality, for which any input latency will make you puke.</p></div><hr><div class=reply id=c9068140052526416105><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>I already pay attention to John Carmack but lately what he's been delving into separates from my own personal avenues of research. In particular he seems to be jumping on the texel-based rendering bandwagon, which I have many objections to.<br><br>I would like to note that my engine can still "run" at any FPS I want with a constant physics timestep, its just that no physics objects will move during the update. Technically, animations and other things would still run, and in fact I could implement my own interpolation if I wanted to, but it would still be deterministic.<br><br>At this point I'm going to make it so my engine can either use a variable timestep or a constant timestep, which then lets the game using the engine choose whether or not it wants to be deterministic.</p></div><hr><div id=c8702335690771044604><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src="//lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35" alt>
<b>Necrowizzard</b><p>Besides the 'flame-war' going on.<br><br>There are actually many disadvantages from such a multithreaded architecture, but I currently still like it.<br><br>The need of conceptually dividing the functionality turns out to be positive for maintainability in my case. The borders between the modules are hard to overcome and therefore you can't take the lazy path of just hacking something in between. A lot of trouble comes from adding fast features that are not separated enough. So in general I found that it makes it easier to work on individual problems. Still the overhead is large.<br><br>The general problem is that writing a multithreaded game engine isn't just a work of a few days, therefore the actual performance differences are hard to measure. My current architecture runs with 4 different modules which are basically communicating via double-buffering. And I would also encourage others to pursue a similar path, if they can live with a steep curve of getting things together in the first place. I blieve that separating really pays off when going further along the road. Currently I wouldn't go back to a single threaded/module approach. Still it is possible that my opinion may change in the future.</p></div><hr><div class=reply id=c536145052596806163><div class=reply-arrow><i class="fa-solid fa-level-up"></i></div><img src=//lh5.googleusercontent.com/-4ezLtYpHa-E/AAAAAAAAAAI/AAAAAAAAAQI/rkWVell_uxQ/s32-c/photo.jpg alt>
<b>Erik McClure</b><p>My graphics engine is required to run entirely by itself. I use box2D, which is an encapsulated physics engine. I therefore consider the division of labor to be fairly well enforced. However, I discovered that there is such a thing as *too much* encapsulation in that it really starts to get in the way of more practical solutions. Consequently there are a few places where I deliberately tie things together very closely because doing it any other way has a tendency to create more problems than it solves. CEGUI is a great example of trying to do too much with too much isolation of functionality, rendering it a bloated, catastrophic mess.</p></div></div><div class=comments></div><hr><div class=wrapcommento><div id=commento></div><script src=https://cdn.commento.io/js/commento.js></script></div></form></article></section><section class=archive><article><img src=https://erikmcclure.com/img/avatar.th.png alt=Avatar width=180 height=180><h2>Archive</h2><ol><li><details><summary>2024</summary><ul><li><a href=/blog/stop-making-me-memorize-borrow-checker/>Stop Making Me Memorize The Borrow Checker</a></li><li><a href=/blog/rust-async-makes-me-want-to-gouge-my-eyes-out/>Rust Async Makes Me Want To Gouge My Eyes Out</a></li><li><a href=/blog/engineers-only-get-paid-something-broken/>Engineers Only Get Paid If Something Is Broken</a></li><li><a href=/blog/measuring-competence-is-epistemic-hell/>Measuring Competence Is Epistemic Hell</a></li></ul></details></li><li><details><summary>2023</summary><ul><li><a href=/blog/discord-should-remove-usernames/>Discord Should Remove Usernames Entirely</a></li></ul></details></li><li><details><summary>2022</summary><ul><li><a href=/blog/we-need-new-motherboards/>We Need New Motherboards Before GPUs Collapse Under Their Own Gravity</a></li></ul></details></li><li><details><summary>2021</summary><ul><li><a href=/blog/cpp-constructors-memory-and-lifetimes/>C++ Constructors, Memory, and Lifetimes</a></li><li><a href=/blog/factorio-is-best-interview-we-have/>Factorio Is The Best Technical Interview We Have</a></li></ul></details></li><li><details><summary>2020</summary><ul><li><a href=/blog/why-you-cant-use-prebuilt-llvm-with-cpp17/>Why You Can't Use Prebuilt LLVM 10.0 with C++17</a></li><li><a href=/blog/pressure-based-anti-spam-for-discord-bots/>Pressure Based Anti-Spam for Discord Bots</a></li></ul></details></li><li><details><summary>2019</summary><ul><li><a href=/blog/name-shadowing-should-be-an-operator/>Name Shadowing Should Be An Operator</a></li><li><a href=/blog/a-rant-on-terra/>A Rant On Terra</a></li><li><a href=/blog/risc-is-fundamentally-unscalable/>RISC Is Fundamentally Unscalable</a></li></ul></details></li><li><details><summary>2018</summary><ul><li><a href=/blog/migrating-to-static-blog/>Migrating To A Static Blog</a></li><li><a href=/blog/how-to-avoid-memorizing-times-tables/>How To Avoid Memorizing Times Tables</a></li></ul></details></li><li><details><summary>2017</summary><ul><li><a href=/blog/integrating-luajit-and-autogenerating-c/>Integrating LuaJIT and Autogenerating C Bindings In Visual Studio</a></li><li><a href=/blog/discord-rise-of-bot-wars/>Discord: Rise Of The Bot Wars</a></li><li><a href=/blog/windows-wont-let-my-program-crash/>Windows Won't Let My Program Crash</a></li><li><a href=/blog/directx-is-terrifying/>DirectX Is Terrifying</a></li></ul></details></li><li><details><summary>2016</summary><ul><li><a href=/blog/everyone-does-srgb-wrong-because/>Everyone Does sRGB Wrong Because Everyone Else Does sRGB Wrong</a></li><li><a href=/blog/mathematical-notation-is-awful/>Mathematical Notation Is Awful</a></li></ul></details></li><li><details><summary>2015</summary><ul><li><a href=/blog/using-data-to-balance-your-game-pony/>Using Data To Balance Your Game: Pony Clicker Analysis</a></li></ul></details></li><li><details><summary>2014</summary><ul><li><a href=/blog/can-we-choose-what-we-enjoy/>Can We Choose What We Enjoy?</a></li><li><a href=/blog/how-to-make-your-profiler-10x-faster/>How To Make Your Profiler 10x Faster</a></li><li><a href=/blog/the-problem-with-photorealism/>The Problem With Photorealism</a></li></ul></details></li><li><details><summary>2013</summary><ul><li><a href=/blog/googles-decline-really-bugs-me/>Google's Decline Really Bugs Me</a></li><li><a href=/blog/write-less-code/>Write Less Code</a></li><li><a href=/blog/leap-motion-impressions-input/>Leap Motion Impressions, Input Sanitation, and 3D Gesture Ideas</a></li><li><a href=/blog/aurora-theory-released/>Aurora Theory Released!</a></li><li><a href=/blog/what-i-learned-in-college/>What I Learned In College</a></li><li><a href=/blog/course-notes/>Course Notes</a></li><li><a href=/blog/windows-breaks-assert-inside/>Windows Breaks assert() Inside WM_CANCELMODE</a></li><li><a href=/blog/the-productivity-fallacy/>The Productivity Fallacy</a></li></ul></details></li><li><details><summary>2012</summary><ul><li><a href=/blog/c-to-c-tutorial-part-4-operator-overload/>C# to C++ Tutorial - Part 4: Operator Overload</a></li><li><a href=/blog/7-problems-raytracing-doesnt-solve/>7 Problems Raytracing Doesn't Solve</a></li><li><a href=/blog/analyzing-xkcd-click-and-drag/>Analyzing XKCD: Click and Drag</a></li><li><a href=/blog/coordinate-systems-and-cascading/>Coordinate Systems And Cascading Stupidity</a></li><li><a href=/blog/how-joysticks-ruined-my-graphics-engine/>How Joysticks Ruined My Graphics Engine</a></li><li><a href=/blog/multithreading-problems-in-game-design/>Multithreading Problems In Game Design</a></li><li><a href=/blog/why-windows-8-does-right-thing-wrong/>Why Windows 8 Does The Right Thing The Wrong Way</a></li><li><a href=/blog/visual-studio-broke-my-computer/>Visual Studio Broke My Computer</a></li><li><a href=/blog/implicit-ui-design/>Implicit UI Design</a></li><li><a href=/blog/linux-mint-12-kde/>Linux Mint 12 KDE</a></li><li><a href=/blog/new-post/>'Programmer' is an Overgeneralization</a></li></ul></details></li><li><details><summary>2011</summary><ul><li><a href=/blog/great-mystery-of-linear-gradient/>The Great Mystery of Linear Gradient Lighting</a></li><li><a href=/blog/signed-integers-considered-stupid-like/>Signed Integers Considered Stupid (Like This Title)</a></li><li><a href=/blog/c-to-c-tutorial-part-3-classes-and/>C# to C++ Tutorial - Part 3: Classes and Structs and Inheritance (OH MY!)</a></li><li><a href=/blog/problem-of-vsync/>The Problem of Vsync</a></li><li><a href=/blog/c-to-c-tutorial-part-2-pointers/>C# to C++ Tutorial - Part 2: Pointers Everywhere!</a></li><li><a href=/blog/c-to-c-tutorial-part-1-basics-of-syntax/>C# to C++ Tutorial - Part 1: Basics of Syntax</a></li><li><a href=/blog/ninth-circle-of-bugs/>The Ninth Circle of Bugs</a></li><li><a href=/blog/investigating-low-level-cpu-performance/>Investigating Low-level CPU Performance</a></li></ul></details></li><li><details><summary>2010</summary><ul><li><a href=/blog/album-for-sale-renascent/>Album For Sale! [Renascent]</a></li><li><a href=/blog/wavsaver/>WavSaver</a></li><li><a href=/blog/pixel-perfect-hit-testing/>Pixel Perfect Hit Testing</a></li><li><a href=/blog/8-bit-color-cycling/>8-bit color cycling</a></li><li><a href=/blog/physics-networking/>Physics Networking</a></li><li><a href=/blog/assembly-cas-implementation/>Assembly CAS implementation</a></li><li><a href=/blog/function-pointer-speed/>Function Pointer Speed</a></li><li><a href=/blog/most-bizarre-error-ever/>Most Bizarre Error Ever</a></li></ul></details></li><li><details><summary>2009</summary><ul><li><a href=/blog/physics-oriented-network-interpolation/>Physics-oriented Network Interpolation</a></li></ul></details></li></ol></article></section></main><footer><p><span>Copyright &copy;2024 Erik McClure</span> <a href=https://erikmcclure.com/sitemap.xml>Sitemap</a> | <a href=https://erikmcclure.com/blog/index.xml>RSS Feed</a></p></footer></div><script>"use strict";window.onload=function(){e=document.getElementsByClassName("math");for(var e,t=0,n=e.length;t<n;t++)renderMathInElement(e[t],{delimiters:[{left:"$$",right:"$$",display:!1},{left:"\\[",right:"\\]",display:!0}]})}</script></body></html>