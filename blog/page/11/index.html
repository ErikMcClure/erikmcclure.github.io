<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=Edge"><meta http-equiv=permissions-policy content="interest-cohort=()"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#2b7bb5"><meta name=copyright content="Copyright (c)2025 Erik McClure"><meta name=keywords content="games,music,code,erik mcclure,erikmcclure,aurora theory,sweetie bot,discord,feathergui,fading light,tinyoal,cloud hop"><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"><meta name=google-site-verification content="Oxb2ia8HjcHLXlvstA8xPpQO3BO_y15Ds2Ia-feq1MQ"><meta name=generator content="Hugo 0.119.0"><link rel=me href=https://equestria.social/@cloudhop><link rel=canonical href=https://erikmcclure.com/blog/><link rel=apple-touch-icon href=https://erikmcclure.com/favicon.ico><link rel="shortcut icon" type=image/x-icon href=https://erikmcclure.com/favicon.ico><link rel=stylesheet href=https://erikmcclure.com/css/main.css><link rel=stylesheet href=https://erikmcclure.com/css/prism.css rel=stylesheet><link rel=stylesheet href=https://erikmcclure.com/css/katex.min.css rel=stylesheet><link rel=stylesheet href=https://erikmcclure.com/css/fontawesome.min.css><link rel=stylesheet href=https://erikmcclure.com/css/regular.min.css><link rel=stylesheet href=https://erikmcclure.com/css/brands.min.css><link rel=stylesheet href=https://erikmcclure.com/css/solid.min.css><link rel=alternate type=application/rss+xml title="Erik McClure - RSS" href=https://erikmcclure.com/blog/index.xml><meta property="og:type" content="website"><title>Blogs - Erik McClure</title><meta property="og:title" content="Blogs - Erik McClure"><meta name=twitter:title content="Blogs - Erik McClure"><meta itemprop=name content="Blogs - Erik McClure"><meta name=description content="Applied mathematician and software architect who occasionally writes music."><meta property="og:description" content="Applied mathematician and software architect who occasionally writes music."><meta name=twitter:description content="Applied mathematician and software architect who occasionally writes music."><meta itemprop=description content="Applied mathematician and software architect who occasionally writes music."><meta property="og:url" content="https://erikmcclure.com/"><meta property="og:site_name" content="Erik McClure"><meta property="og:image" content="https://erikmcclure.com/img/avatar.png"><meta property="og:locale" content="en-US"><meta property="article:author" content="Erik McClure"><meta name=twitter:card content="summary"><meta name=twitter:site content="@erikmcclure0173"><meta name=twitter:creator content="@erikmcclure0173"><meta name=twitter:image content="https://erikmcclure.com/img/avatar.png"><meta name=twitter:dnt content="on"><link href=https://plus.google.com/104896885003230920472 rel=publisher><meta itemprop=image content="https://erikmcclure.com/img/avatar.png"><meta name=last-updated content="20250329-17:35:00.000"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-63026815-3"></script>
<script defer src=https://erikmcclure.com/syntax-prism.js></script>
<script defer src=https://erikmcclure.com/katex.min.js></script>
<script defer src=https://erikmcclure.com/mathtex-script-type.min.js></script>
<script defer src=https://erikmcclure.com/auto-render.min.js></script>
<script defer src=https://cdn.commento.io/js/count.js></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-63026815-3")</script></head><body><div id=container><header><nav><ul><li><a href=/blog/ title=Blog><i class="fa-solid fa-book fa-fw fa-lg"></i>&nbsp;<p>Blog</p></a></li><li><a href=/projects/ title=Projects><i class="fa-solid fa-briefcase fa-fw fa-lg"></i>&nbsp;<p>Projects</p></a></li><li><a href=https://erikmcclure.bandcamp.com title=Bandcamp><i class="fa-brands fa-bandcamp fa-fw fa-lg"></i>&nbsp;<p>Bandcamp</p></a></li><li><a href=https://github.com/erikmcclure title=Github><i class="fa-brands fa-github fa-fw fa-lg"></i>&nbsp;<p>Github</p></a></li><li><a href=/web/ title=Websites><i class="fa-solid fa-globe fa-fw fa-lg"></i>&nbsp;<p>Websites</p></a></li></ul></nav><div class=dim><h1>Erik McClure</h1></div></header><main class=blog><section><article><h4><a href=/blog/7-problems-raytracing-doesnt-solve/>7 Problems Raytracing Doesn't Solve</a></h4><hr><div class=padding><p>I see a lot of people get excited about extreme concurrency in modern hardware bringing us closer to the magical holy grail of <em>raytracing</em>. It seems that everyone thinks that once we have raytracing, we can fully simulate entire digital worlds, everything will be photorealistic, and graphics will become a &ldquo;solved problem&rdquo;. This simply isn&rsquo;t true, and in fact highlights several fundamental misconceptions about the problems faced by modern games and other interactive media.</p><p>For those unfamiliar with the term, <em>raytracing</em> is the process of rendering a 3D scene by tracing the path of a beam of light after it is emitted from a light source, calculating its properties as it bounces off various objects in the world until it finally hits the virtual camera. At least, you hope it hits the camera. You see, to be perfectly accurate, you have to cast a bajillion rays of light out from the light sources and then see which ones end up hitting the camera at some point. This is obviously a problem, because most of the rays don&rsquo;t actually hit the camera, and are simply wasted. Because this brute force method is so incredibly inefficient, many complex algorithms (such as <a href=http://en.wikipedia.org/wiki/Photon_mapping>photon-mapping</a> and <a href=http://en.wikipedia.org/wiki/Metropolis_light_transport>Metropolis light transport</a>) have been developed to yield approximations that are thousands of times more efficient. These techniques are almost always focused on attempting to find paths from the light source to the camera, so rays can be cast in the reverse direction. Some early approximations actually cast rays out from the camera until they hit an object, then calculated the lighting information from the distance and angle, disregarding other objects in the scene. While highly efficient, this method produced extremely inaccurate results.</p><p>It is with a certain irony that raytracing is touted as being a precise, super-accurate rendering method when all raytracing is actually done via approximations in the first place. Pixar uses photon-mapping for its movies. Most raytracers operate on stochastic sampling approximations. We can already do raytracing in realtime, if we get approximate enough, it just looks <a href="http://www.youtube.com/watch?v=h5mRRElXy-w&amp;t=0m50s">boring</a> and is extremely limited. Graphics development doesn&rsquo;t just stop when someone develops realtime raytracing, because there will always be room for a better approximation.</p><h5 id=1-photorealism>1. Photorealism</h5><p>The meaning of <em>photorealism</em> is difficult to pin down, in part because the term is inherently subjective. If you define photorealism as being able to render a virtual scene such that it precisely matches a photo, then it is almost impossible to achieve in any sort of natural environment where the slightest wind can push a tree branch out of alignment.</p><p>This quickly gives rise to defining photorealism as rendering a virtual scene such that it is indistinguishable from a photograph of a similar scene, even if they aren&rsquo;t exactly the same. This, however, raises the issue of just how indistinguishable it needs to be. This seems like a bizarre concept, but there are different degrees of &ldquo;indistinguishable&rdquo; due to the differences between people&rsquo;s observational capacities. Many people will never notice a slightly misaligned shadow or a reflection that&rsquo;s a tad too bright. For others, they will stand out like sore thumbs and completely destroy their suspension of disbelief.</p><p>We have yet another problem in that the entire concept of &ldquo;photorealism&rdquo; has nothing to do with how humans see the world in the first place. Photos are inherently linear, while human experience a much more dynamic, log-based lighting scale. This gives rise to <a href=http://en.wikipedia.org/wiki/High_dynamic_range_imaging>HDR photography</a>, which actually has almost nothing to do with the HDR implemented in games. Games simply change the brightness of the entire scene, instead of combining the brightness of multiple exposures to brighten some areas and darken others in the <a href=http://en.wikipedia.org/wiki/File:BrnoSunsetHDRExampleByIgor.jpg>same photo</a>. If all photos are not created equal, then exactly which photo are we talking about when we say &ldquo;photorealistic&rdquo;?</p><h5 id=2-complexity>2. Complexity</h5><p>Raytracing is often cited as allowing an order of magnitude more detail in models by being able to efficiently process many more polygons. This is only sort of true in that raytracing is not subject to the same computational constraints that rasterization is. Rasterization must render every single triangle in the scene, whereas raytracing is only interested in whether or not a ray hits a triangle. Unfortunately, it still has to navigate through the scene representation. Even if a raytracer could handle a scene with a billion polygons efficiently, this raises completely unrelated problems involving RAM access times and cache pollution that suddenly become actual performance bottlenecks instead of micro-optimizations.</p><p>In addition, raytracing approximation algorithms almost always take advantage of rays that degrade quickly, such that they can only bounce 10-15 times before becoming irrelevant. This is fine and dandy for walking around in a city or a forest, but what about a kitchen? Even though raytracing is much better at handling reflections accurately, highly reflective materials cripple the raytracer, because now rays are bouncing hundreds of times off a myriad of surfaces instead of just 10. If not handled properly, it can absolutely devastate performance, which is catastrophic for game engines that must maintain constant render times.</p><h5 id=3-scale>3. Scale</h5><p>How do you raytrace stars? Do you simply wrap a sphere around the sky and give it a &ldquo;star&rdquo; material? Do you make them all point sources infinitely far away? How does this work in a space game, where half the stars you see can actually be visited, and the other half are entire galaxies? How do you accurately simulate an entire solar system down to the surface of a planet, as the <a href=http://kerbalspaceprogram.com/forum/entry.php/54-Scaled-Space-Now-with-100-more-Floating-Origin%21>Kerbal Space Program developers</a> had to? Trying to figure out how to represent that kind of information in a meaningful form with only 64 bits of precision, if you are lucky, is a problem completely separate from raytracing, yet of increasingly relevant concern as games continue to expand their horizons more and more. How do we simulate an entire galaxy? How can we maintain meaningful precision when faced with astronomical scales, and how does this factor in to our rendering pipeline? These are problems that arise in any rendering pipeline, regardless of what techniques it uses, due to fundamental limitations in our representations of numbers.</p><h5 id=4-materials>4. Materials</h5><p>Do you know what methane clouds look like? What about writing an <a href=http://en.wikipedia.org/wiki/File:Aerogel_nasa.jpg>aerogel</a> shader? Raytracing, by itself, doesn&rsquo;t simply figure out how a given material works, you have to tell it how each material behaves, and its accuracy is wholly dependent on how accurate your description of the material is. This isn&rsquo;t easy, either, it requires advanced mathematical models and heaps of data collection. In many places we&rsquo;re actually <a href=http://blog.selfshadow.com/publications/s2012-shading-course/>still trying to figure out</a> how to build physically correct material equations in the first place. Did you know that Dreamworks had to rewrite part of their cloud shader<sup><a href=#r1>1</a></sup> for How To Train Your Dragon? It turns out that getting clouds to look good when your character is flying directly beneath them with a hand raised is <em>really hard</em>.</p><p>This is just for <em>common lighting phenomena!</em> How are you going to write shaders for things like pools of magic water and birefringent <a href=http://en.wikipedia.org/wiki/Birefringence>calcite crystals</a>? How about trying to accurately simulate <a href=http://en.wikipedia.org/wiki/File:CircularPolarizer.jpg>circular polarizers</a> when most raytracers don&rsquo;t even know what polarization is? Does being photorealistic require you to simulate the <a href=http://en.wikipedia.org/wiki/Tyndall_effect>Tyndall Effect</a> for caustics in <a href=http://en.wikipedia.org/wiki/File:Why_is_the_sky_blue.jpg>crystals</a> and <a href=http://en.wikipedia.org/wiki/File:WaterAndFlourSuspensionLiquid.jpg>particulate matter</a>? There are <em>so many tiny little details</em> all around us that affect everything from the <a href=http://en.wikipedia.org/wiki/Tyndall_scattering#Blue_irises>color of our iris</a> to the <a href=http://en.wikipedia.org/wiki/Rainbow#Number_of_colours_in_spectrum_or_rainbow>creation of rainbows</a>. Just how much does our raytracer need to simulate in order to be photorealistic?</p><h5 id=5-physics>5. Physics</h5><p>What if we ignored the first four problems and simply assumed we had managed to make a perfect, magical photorealistic raytracer. Congratulations, you&rsquo;ve managed to co-opt the entirety of your CPU for the task of rendering a static 3D scene, leaving nothing left for the physics. All we&rsquo;ve managed to accomplish is taking the &ldquo;interactive&rdquo; out of &ldquo;interactive media&rdquo;. Being able to influence the world around us is a key ingredient to immersion in games, and this requires more and more accurate physics, which are arguably just as difficult to calculate as raytracing is. The most advanced real-time physics engine to-date is the <a href=http://www.gameranx.com/updates/id/707/article/mind-blowing-physics-engine-demonstration/>Lagoa Multiphysics</a>, and it can only just <em>barely</em> simulate a tiny scene in a well-controlled environment before it completely decimates a modern CPU. This is without any complex rendering at all. Now try doing that for a scene with a radius of several miles. Oh, and remember our <a href=#h3>issue with scaling</a>? This applies to physics too! Except with physics, its an <em>order of magnitude even more difficult</em>.</p><h5 id=6-content>6. Content</h5><p>As many developers have been discovering, procedural generation is not magic pixie dust you can sprinkle on problems to make them go away. Yet, without advances in content generation, we are forced to hire armies of artists to create the absurd amounts of detail required by modern games. Raytracing doesn&rsquo;t solve this problem, it makes it <em>worse</em>. In any given square mile of a human settlement, there are <em>billions</em> of individual objects, ranging from pine cones, to rocks, to TV sets, to <em>crumbs</em>, all of which technically have physics, and must be kept track of, and rendered, and even more importantly, <em>modeled</em>.</p><p>Despite <a href=http://en.wikipedia.org/wiki/Spore>multiple attempts</a> at leveraging procedural generation, the content problem has simply refused to go away. Until we can effectively harness the power of procedural generation, augmented artistic tools, and automatic design morphing, the advent of fully photorealistic raytracing will be useless. The best graphics engine in the world is nothing without art.</p><h5 id=7-ai>7. AI</h5><p><div style=margin-left:3em>&lt;Patrician|Away> what does your robot do, sam
&lt;bovril> it collects data about the surrounding environment, then discards it and drives into walls
— <i>Bash.org quote [#240849](http://bash.org/?240849)</i></div>Of course, while we&rsquo;re busy desperately trying to raytrace supercomplex scenes with advanced physics, we haven&rsquo;t even left any CPU time to calculate the AI! The AI in games is so consistently terrible its turned into <a href=http://tvtropes.org/pmwiki/pmwiki.php/Main/ArtificialStupidity>its own trope</a>. The game industry spends all its computational time trying to render a scene, leaving almost nothing left for the AI routines, forcing them to rely on <a href=http://en.wikipedia.org/wiki/A*_search_algorithm>techniques from 1968</a>. Think about that - we are approaching the point where AI in games comes down to a 50-year old technique that was considered hopelessly outdated before I was even born. Oh, and I should also point out that Graphics, Physics, Art, and AI are all completely separate fields with fundamentally different requirements that all have to work together in a coherent manner just so you can shoot headshots in Call of Duty 22.</p><p>I know that raytracing is exciting, sometimes simply as a demonstration of raw computational power. But it always disheartens me when people fantasize about playing amazingly detailed games indistinguishable from real life when that simply isn&rsquo;t going to happen, even with the inevitable development<sup>2</sup> of realtime raytracing. By the time it becomes commercially viable, it will simply be yet another incremental step in our eternal quest for infinite realism. It is an important step, and one we should strive for, but it alone is not sufficient to spark a revolution.</p><span style=font-size:80%><br><sup><a name=r1>1</a></sup> Found on the special features section of the How To Train Your Dragon DVD.<br><sup>2</sup> Disclaimer: I've been trying to develop an efficient raytracing algorithm for ages and haven't had much luck. <a href=http://www.tml.tkk.fi/~samuli/publications/lehtinen2012siggraph_paper.pdf>These guys are faring much better</a>.</span></div><hr><time itemprop=datePublished pubdate=pubdate datetime=2012-09-27T04:13:00+00:00><i class="fa-regular fa-clock fa-fw"></i>&nbsp;Published on <a href=https://erikmcclure.com/blog/7-problems-raytracing-doesnt-solve/>September 27, 2012 at 4:13am</a></time><aside><i class="fa-regular fa-comments fa-fw"></i>&nbsp;<a href=/blog/7-problems-raytracing-doesnt-solve/#commento>40 comments</a></aside><aside><i class="fa-regular fa-share-square fa-fw"></i>&nbsp;share:<ul><li><a href="javascript:window.open('https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ferikmcclure.com%2fblog%2f7-problems-raytracing-doesnt-solve%2f','popup','width=600,height=400');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" d="M16.75 9H13.5V7a1 1 0 011-1h2V3H14a4 4 0 00-4 4V9H8v3h2v9h3.5V12H16z"/></svg></a><li><a href="javascript:window.open('https://twitter.com/intent/tweet?text=7%20Problems%20Raytracing%20Doesn%27t%20Solve&url=https%3a%2f%2ferikmcclure.com%2fblog%2f7-problems-raytracing-doesnt-solve%2f','popup','width=600,height=256');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" opacity="0" d="M0 0h24v24H0z"/><path class="st0" d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572.0-4.658 2.086-4.658 4.66.0.364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342.0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3.0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376.0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57.0 13.255-7.098 13.255-13.254.0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg></a></li><li><a href="javascript:window.open('https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2ferikmcclure.com%2fblog%2f7-problems-raytracing-doesnt-solve%2f','popup','width=700,height=380');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><rect class="st0" height="11" width="4" x="3" y="9"/><circle class="st0" cx="5" cy="5" r="2"/><path class="st0" d="M16.5 8.25A4.47251 4.47251.0 0013 9.95343V9H9V20h4V13a2 2 0 014 0v7h4V12.75a4.5 4.5.0 00-4.5-4.5z"/></svg></a></li></ul></aside></article><article><h4><a href=/blog/analyzing-xkcd-click-and-drag/>Analyzing XKCD: Click and Drag</a></h4><hr><div class=padding><p>Today, xkcd <a href=http://xkcd.com/1110/>featured a comic</a> with a <em>comically</em> large image that is navigated by clicking and dragging. In the interests of SCIENCE (and possibly accidentally DDoSing Randall&rsquo;s image server - sorry!), I created a static HTML file of the <strong><a href=http://blackspherestudios.com/storage/xkcd_huge_static.html>entire composite image</a></strong>.<sup>1</sup></p><p>The collage is made up of 225 images<sup>2</sup> that stretch out over a total image area 79872 pixels high and 165888 pixels wide. The images take up 5.52 MB of space and are named with a simple naming scheme <code>"ydxd.png"</code> where d represents a cardinal direction appropriate for the axis (n for north, s for south on the y axis and e for east, w for west on the x axis) along with the tile coordinate number; for example, <code>"1n1e.png"</code>. Tiles are 2048x2048 png images with an average size of 24.53 KB. If you were to try and represent this as a single, uncompressed 32-bit 79872x165888 image file, it would take up 52.99 GB of space.</p><p>Assuming a human&rsquo;s average height is 1.8 meters, that would give this image a scale of about 1 meter per 22 pixels. That means the total composite image is approximately 3.63 kilometers high and 7.54 kilometers wide. It would take an average human 1.67 hours to walk from one end of the image to the other. Note that the characters at the far left say they&rsquo;ve been walking for 2 miles - they are 67584 pixels from the starting point, which translates to 3.072 km or ~1.9 miles, so this seems to indicate my rough estimates here are reasonably accurate.</p><p>If Randall spent, on average, one hour drawing each frame, it would take him 9.375 days of constant, nonstop work to finish this. If he instead spent an average of 10 minutes per frame, it would take ~37.5 hours, or almost an entire 40-hour work week.</p><p>Basically I&rsquo;m saying Randall Munroe is fucking insane.</p><span style=font-size:80%><sup>1</sup> If you are on firefox or chrome, right-clicking and selecting "Save as" will download the HTML file along with all 225 images into a separate folder.
<sup>2</sup> There are actually 3159 possible images (39 x 81), but all-white and all-black images are not included, instead being replaced by either the default white background or a massive black &lt;div> representing the ground, located 28672 pixels from the top of the image, with a height of 51200.</span></div><hr><time itemprop=datePublished pubdate=pubdate datetime=2012-09-19T07:33:00+00:00><i class="fa-regular fa-clock fa-fw"></i>&nbsp;Published on <a href=https://erikmcclure.com/blog/analyzing-xkcd-click-and-drag/>September 19, 2012 at 7:33am</a></time><aside><i class="fa-regular fa-comments fa-fw"></i>&nbsp;<a href=/blog/analyzing-xkcd-click-and-drag/#commento>18 comments</a></aside><aside><i class="fa-regular fa-share-square fa-fw"></i>&nbsp;share:<ul><li><a href="javascript:window.open('https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ferikmcclure.com%2fblog%2fanalyzing-xkcd-click-and-drag%2f','popup','width=600,height=400');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" d="M16.75 9H13.5V7a1 1 0 011-1h2V3H14a4 4 0 00-4 4V9H8v3h2v9h3.5V12H16z"/></svg></a><li><a href="javascript:window.open('https://twitter.com/intent/tweet?text=Analyzing%20XKCD%3a%20Click%20and%20Drag&url=https%3a%2f%2ferikmcclure.com%2fblog%2fanalyzing-xkcd-click-and-drag%2f','popup','width=600,height=256');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" opacity="0" d="M0 0h24v24H0z"/><path class="st0" d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572.0-4.658 2.086-4.658 4.66.0.364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342.0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3.0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376.0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57.0 13.255-7.098 13.255-13.254.0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg></a></li><li><a href="javascript:window.open('https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2ferikmcclure.com%2fblog%2fanalyzing-xkcd-click-and-drag%2f','popup','width=700,height=380');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><rect class="st0" height="11" width="4" x="3" y="9"/><circle class="st0" cx="5" cy="5" r="2"/><path class="st0" d="M16.5 8.25A4.47251 4.47251.0 0013 9.95343V9H9V20h4V13a2 2 0 014 0v7h4V12.75a4.5 4.5.0 00-4.5-4.5z"/></svg></a></li></ul></aside></article><article><h4><a href=/blog/coordinate-systems-and-cascading/>Coordinate Systems And Cascading Stupidity</a></h4><hr><div class=padding><p>Today I learned that there are way too many coordinate systems, and that I&rsquo;m an idiot (but that was already well-established). I have also learned to not trust graphics tutorials, but the reasons for that won&rsquo;t become apparent until the end of this article.</p><p>There are <a href=http://en.wikipedia.org/wiki/Cartesian_coordinate_system#Orientation_and_handedness>two types of coordinate systems</a>: left-handed and right-handed coordinate systems. By convention, most everyone in math and science uses right-handed coordinate systems with positive x going to the right, positive y going up, and positive z coming out of the screen. A left-handed coordinate system is the same, but positive z instead points into the screen. Of course, there are many other possible coordinate system configurations, each either being right or left-handed; some modern CAD packages have y pointing into the screen and z pointing up, and screen-space in graphics traditionally has y pointing down and z pointing into the screen.</p><p>If you start digging through DirectX and OpenGL, the handedness of the coordinate systems being used are ill-defined due to its reliance on various perspective transforms. Consequently, while DirectX traditionally uses a left-handed coordinate system and OpenGL uses a right-handed coordinate system, you can simply use <code>D3DPerspectiveMatrixRH</code> to give DirectX a right-handed coordinate system, and openGL actually uses a left-handed coordinate system by default on its shader pipeline - but all of these are entirely dependent on the handedness of the projection matrices involved. So, technically the coordinate system is whichever one you choose, but unlike the rest of the world, computer graphics has no real standard on which coordinate system to use, and so its just a giant mess of various coordinate systems all over the place, which means you don&rsquo;t know what handedness a given function is for until things start getting funky.</p><p>I discovered all this, because today I found out that, for the past 6 or so years (the entire time my graphics engine has ever existed in any shape or form), it has been <strong>rotating everything backwards</strong>. I didn&rsquo;t notice.</p><p>This happened due to a number of unfortunate coincidences. For many years, I simply didn&rsquo;t notice because I didn&rsquo;t know what direction the sign of a given rotation was supposed to rotate in, and even if I did I would have assumed this to be the default for graphics for some strange reason (there are a <em>lot</em> of weird things in graphics). The first hint was when I was integrating with Box2D and I had to reverse the rotation of its bodies to match up with my images. This did trigger an investigation, but I mistakenly concluded that it was <em>Box2D</em> that had it wrong, not me, because I was using <code>atan2</code> to check coordinates, and I was passing them in as <code>atan2(v.x,v.y)</code>. The problem is that <code>atan2</code> is defined as <code>float atan2(float y, float x)</code>, which means my coordinates were reversed and I was getting nonsense angles.</p><p>Now, here you have to understand that I was currently using a standard left-handed coordinate system, with y pointing up, x pointing right and z into the screen. The thing is, I wanted a coordinate system where y pointed <em>down</em>, and so I did as a tutorial instructed me to and reversed all of my y coordinates on the low-level drawing functions.</p><p>So, when <code>atan2(x,y)</code> gave me bad results, I mistakenly thought &ldquo;Oh, i forgot to reverse the y coordinate!&rdquo; Suddenly <code>atan2(x,-y)</code> was giving me angles that matched what my images were doing. The thing is, if you switch x and y and negate y, <code>atan2(x,-y)==-atan2(y,x)</code>. One mistake had been incorrectly validated by yet another mistake, caused by <em>yet another mistake!</em></p><p>You see, by inverting those y coordinates, I was accidentally reversing the result of my rotation matrices, which caused them to rotate everything backwards. This was further complicated by how the camera rotates things - if your camera is fixed, how do you make it appear that it is rotating? You rotate everything else <em>in the opposite direction!</em> Hence even though my camera was rotating backwards despite looking like it was rotating forwards, it was actually being rotated the right way for the wrong reason.</p><p>While I initially thought the fix for this would require some crazy coordinate system juggling, the actual solution was fairly simple. The fact was, a coordinate system with z pointing into the screen and y pointing down <em>is still right-handed</em>, which means it should play nicely with rotations from a traditional right-handed system. Since the handedness of a coordinate system is largely determined by the perspective matrix, reversing y-coordinates in the drawing functions was actually reversing them too late in the pipeline. Hence, because I used <code>D3DXMatrixPerspectiveLH</code>, I had a left-handed coordinate system, and my rotations ended up being reversed. <code>D3DXMatrixPerspectiveRH</code> negates the z-coordinate to switch the handedness of the coordinate system, but I like positive z pointing into the screen, so I instead hacked the left-handed perspective matrix itself and negated the y-scaling parameter in cell [2,2], then undid all the y-coordinate inversion insanity that had been inside my drawing functions (you could also negate the y coordinate in any world transform matrix sufficiently early in the pipeline by specifying a negative y scaling in [2,2]). Suddenly everything was consistent, and rotations were happening in the right direction again. Now the Camera rotation actually required the negative rotation, as one would expect, and I still got to use a coordinate system with y pointing down. Unfortunately it also reversed several rotation operations throughout the engine, some of which were functions that had been returning the wrong value <em>this whole time</em> so as to match up with the incorrect rotation of the engine - something that will give me nightmares for weeks, probably involving a crazed rabbit hitting me over the head with a carrot screaming <em><strong>&ldquo;STUPID STUPID STUPID STUPID!&rdquo;</strong></em></p><p>What&rsquo;s truly terrifying that all of this was indirectly caused by reversing the y coordinates in the first place. Had I instead flipped them in the perspective matrix itself (or otherwise properly transformed the coordinate system), I never would have had to deal with negating y coordinates, I never would have mistaken <code>atan2(x,-y)</code> as being valid, and I never would have had rotational issues in the first place.</p><p>All because of that one stupid tutorial.</p><p><sub>P.S. the moral of the story isn&rsquo;t that tutorials are bad, it&rsquo;s that you shouldn&rsquo;t be a stupid dumbass and not write unit tests or look at function definitions.</sub></p></div><hr><time itemprop=datePublished pubdate=pubdate datetime=2012-07-25T01:06:00+00:00><i class="fa-regular fa-clock fa-fw"></i>&nbsp;Published on <a href=https://erikmcclure.com/blog/coordinate-systems-and-cascading/>July 25, 2012 at 1:06am</a></time><aside><i class="fa-regular fa-comments fa-fw"></i>&nbsp;<a href=/blog/coordinate-systems-and-cascading/#commento>1 comment</a></aside><aside><i class="fa-regular fa-share-square fa-fw"></i>&nbsp;share:<ul><li><a href="javascript:window.open('https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ferikmcclure.com%2fblog%2fcoordinate-systems-and-cascading%2f','popup','width=600,height=400');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" d="M16.75 9H13.5V7a1 1 0 011-1h2V3H14a4 4 0 00-4 4V9H8v3h2v9h3.5V12H16z"/></svg></a><li><a href="javascript:window.open('https://twitter.com/intent/tweet?text=Coordinate%20Systems%20And%20Cascading%20Stupidity&url=https%3a%2f%2ferikmcclure.com%2fblog%2fcoordinate-systems-and-cascading%2f','popup','width=600,height=256');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" opacity="0" d="M0 0h24v24H0z"/><path class="st0" d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572.0-4.658 2.086-4.658 4.66.0.364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342.0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3.0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376.0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57.0 13.255-7.098 13.255-13.254.0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg></a></li><li><a href="javascript:window.open('https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2ferikmcclure.com%2fblog%2fcoordinate-systems-and-cascading%2f','popup','width=700,height=380');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><rect class="st0" height="11" width="4" x="3" y="9"/><circle class="st0" cx="5" cy="5" r="2"/><path class="st0" d="M16.5 8.25A4.47251 4.47251.0 0013 9.95343V9H9V20h4V13a2 2 0 014 0v7h4V12.75a4.5 4.5.0 00-4.5-4.5z"/></svg></a></li></ul></aside></article><article><h4><a href=/blog/how-joysticks-ruined-my-graphics-engine/>How Joysticks Ruined My Graphics Engine</a></h4><hr><div class=padding><p>It&rsquo;s almost a tradition.</p><p>Every time my graphics engine has been stuck in maintenence mode for 6 months, I&rsquo;ll suddenly realize I need to push out an update or implement some new feature. I then realize that I haven&rsquo;t actually paid attention to any of my testing programs, or their speed, in months. This is followed by panic, as I discover my engine running at half speed, or worse. Having made an infinite number of tiny tweaks that all could have caused the problem, I am often thrown into temporary despair only to almost immediately find some incredibly stupid mistake that was causing it. One time it was because I left the profiler on. Another time it was caused by calling the Render function twice. I&rsquo;m gearing up to release the <a href=http://blackspherestudios.com>first public beta</a> of my graphics engine, and this time is no different.</p><p>I find an old backup distribution of my graphics engine and run the tests, and my engine is running at 1100 FPS instead of 3000 or 4000 like it should be. Even the stress test is going at only ~110 FPS instead of 130 FPS. The strange part was that for the lightweight tests, it seemed to be hitting a wall at about 1100 FPS, whereas normally it hits a wall around 4000-5000 due to CPU⇒GPU bottlenecks. This is usually caused by some kind of debugging, so I thought I&rsquo;d left the profiler on again, but no, it was off. After stepping through the rendering pipeline and finding nothing, I knew I had no chance of just guessing what the problem was, so I turned on the profiler and checked the results. Everything seemed relatively normal except-<pre class=language-cil><code>PlaneShader::cEngine::_callpresent       1.0    144.905 us   19%        145 us   19%
PlaneShader::cEngine::Update             1.0     12.334 us    2%        561 us   72%
PlaneShader::cEngine::FlushMessages    1.0    546.079 us   70%        549 us   71%
</code></pre><strong><em>What the FUCK?!</em></strong> Why is <em>70%</em> of my time being spent in <code>FlushMessages()</code>? All that does is process window messages! It shouldn&rsquo;t take any time at all, and here it is taking longer to process messages than it does to render an entire frame!<pre class=language-cpp><code>bool cEngine::FlushMessages()
{
PROFILE_FUNC();
_exactmousecalc();
//windows stuff
MSG msg;

while(PeekMessageW(&amp;msg, NULL, 0, 0, PM_REMOVE))
{
TranslateMessage(&amp;msg);
DispatchMessageW(&amp;msg);

    if(msg.message == WM_QUIT)
    {
      _quit = true;
      return false;
    }

}

_joyupdateall();
return !_quit; //function returns opposite of quit
}
</code></pre>Bringing up the function, there don&rsquo;t seem to be many opportunities for it to fail. I go ahead and comment out <code>_exactmousecalc()</code> and <code>_joyupdateall()</code>, wondering if, perhaps, something in the joystick function was messing up? Lo and behold, my speeds are back to normal! After re-inserting the exact mouse calculation, it is, in fact, <code>_joyupdateall()</code> causing the problem. This is the start of the function:<pre class=language-cpp><code>void cInputManager::_joyupdateall()
{
JOYINFOEX info;
info.dwSize=sizeof(JOYINFOEX);
info.dwFlags= \[ Clipped... \];

for(unsigned short i = 0; i &lt; _maxjoy; ++i)
{
if(joyGetPosEx(i,&amp;info)==JOYERR_NOERROR)
{
if(_allbuttons\[i\]!=info.dwButtons)
{
</code></pre>Well, shit, there isn&rsquo;t really any possible explanation here other than <em>something</em> going wrong with <code>joyGetPosEx</code>. It turns out that calling <code>joyGetPosEx</code> when there isn&rsquo;t a joystick plugged in takes a whopping 34.13 µs (microseconds) on average, which is almost as long as it takes me to render a single frame (43.868 µs). There&rsquo;s probably a good reason for this, but evidently it is not good practice to call it unnecessarily. Fixing this was relatively easy - just force an explicit call to look for active joystick inputs and only poll those, but its still one of the weirdest performance bottlenecks I&rsquo;ve come up against.</p><p>Of course, if you aren&rsquo;t developing a graphics engine, consider that 1/60 of a second is 16666 µs - 550 µs leaves a lot of breathing room for a game to work with, but a graphics engine must not force <em>any</em> unnecessary cost on to a program that is using it unless that program explicitly allows it, hence the problem.</p><p>Then again, <a href=http://stackoverflow.com/questions/1528727/why-is-sse-scalar-sqrtx-slower-than-rsqrtx-x>calculating invsqrt(x)*x is faster than sqrt(x)</a>, so I guess anything is possible.</p></div><hr><time itemprop=datePublished pubdate=pubdate datetime=2012-06-22T22:29:00+00:00><i class="fa-regular fa-clock fa-fw"></i>&nbsp;Published on <a href=https://erikmcclure.com/blog/how-joysticks-ruined-my-graphics-engine/>June 22, 2012 at 10:29pm</a></time><aside><i class="fa-regular fa-comments fa-fw"></i>&nbsp;<a href=/blog/how-joysticks-ruined-my-graphics-engine/#commento>2 comments</a></aside><aside><i class="fa-regular fa-share-square fa-fw"></i>&nbsp;share:<ul><li><a href="javascript:window.open('https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ferikmcclure.com%2fblog%2fhow-joysticks-ruined-my-graphics-engine%2f','popup','width=600,height=400');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" d="M16.75 9H13.5V7a1 1 0 011-1h2V3H14a4 4 0 00-4 4V9H8v3h2v9h3.5V12H16z"/></svg></a><li><a href="javascript:window.open('https://twitter.com/intent/tweet?text=How%20Joysticks%20Ruined%20My%20Graphics%20Engine&url=https%3a%2f%2ferikmcclure.com%2fblog%2fhow-joysticks-ruined-my-graphics-engine%2f','popup','width=600,height=256');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" opacity="0" d="M0 0h24v24H0z"/><path class="st0" d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572.0-4.658 2.086-4.658 4.66.0.364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342.0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3.0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376.0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57.0 13.255-7.098 13.255-13.254.0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg></a></li><li><a href="javascript:window.open('https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2ferikmcclure.com%2fblog%2fhow-joysticks-ruined-my-graphics-engine%2f','popup','width=700,height=380');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><rect class="st0" height="11" width="4" x="3" y="9"/><circle class="st0" cx="5" cy="5" r="2"/><path class="st0" d="M16.5 8.25A4.47251 4.47251.0 0013 9.95343V9H9V20h4V13a2 2 0 014 0v7h4V12.75a4.5 4.5.0 00-4.5-4.5z"/></svg></a></li></ul></aside></article><article><h4><a href=/blog/multithreading-problems-in-game-design/>Multithreading Problems In Game Design</a></h4><hr><div class=padding><p>A couple years ago, when I first started designing a game engine to unify Box2D and my graphics engine, I thought this was a superb opportunity to join all the cool kids and multithread it. I mean all the other game developers were talking about having a thread for graphics, a thread for physics, a thread for audio, etc. etc. etc. So I spent a lot of time teaching myself various lockless threading techniques and building quite a few iterations of various multithreading structures. Almost all of them failed spectacularly for various reasons, but in the end they were all too complicated.</p><p>I eventually settled on a single worker thread that was sent off to start working on the physics at the beginning of a frame render. Then at the beginning of each subsequent frame I would check to see if the physics were done, and if so sync the physics and graphics and start up another physics render iteration. It was a very clean solution, but fundamentally flawed. For one, it introduces an inescapable frame of input lag.</p><pre>Single Thread Low Load
&nbsp;&nbsp;FRAME 1&nbsp;&nbsp; +----+
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|
. Input1 -> |&nbsp;&nbsp;&nbsp;&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|[__]| Physics&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|[__]| Render&nbsp;&nbsp;&nbsp;&nbsp;
. FRAME 2&nbsp;&nbsp; +----+ INPUT 1 ON BACKBUFFER
. Input2 -> |&nbsp;&nbsp;&nbsp;&nbsp;|
. Process ->|&nbsp;&nbsp;&nbsp;&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|[__]| Physics
. Input3 -> |[__]| Render
. FRAME 3&nbsp;&nbsp; +----+ INPUT 2 ON BACKBUFFER, INPUT 1 VISIBLE
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;|
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;|
. Process ->|[__]| Physics
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|[__]| Render
&nbsp;&nbsp;FRAME 4&nbsp;&nbsp; +----+ INPUT 3 ON BACKBUFFER, INPUT 2 VISIBLE

Multi Thread Low Load
&nbsp;&nbsp;FRAME 1&nbsp;&nbsp; +----+
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;| 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|
. Input1 -> |&nbsp;&nbsp;&nbsp;&nbsp;| 
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |[__]| Render/Physics START&nbsp;&nbsp;
. FRAME 2&nbsp;&nbsp; +----+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
. Input2 -> |____| Physics END
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;|
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;| 
. Input3 -> |[__]| Render/Physics START
. FRAME 3&nbsp;&nbsp; +----+ INPUT 1 ON BACKBUFFER
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |____|
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;| PHYSICS END
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;| 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|____| Render/Physics START
&nbsp;&nbsp;FRAME 4&nbsp;&nbsp; +----+ INPUT 2 ON BACKBUFFER, INPUT 1 VISIBLE</pre><p>The multithreading, by definition, results in any given physics update only being reflected in the next rendered frame, because the entire point of multithreading is to immediately start rendering the current frame as soon as you start calculating physics. This causes a number of latency issues, but in addition it requires that one introduce a separated &ldquo;physics update&rdquo; function to be executed only during the physics/graphics sync. As I soon found out, this is a massive architectural complication, especially when you try to put in scripting or let other languages use your engine.</p><p>There is another, more subtle problem with dedicated threads for graphics/physics/audio/AI/anything. <strong>It doesn&rsquo;t scale.</strong> Let&rsquo;s say you have a platformer - AI will be contained inside the game logic, and the absolute vast majority of your CPU time will either be spent in graphics or physics, or possibly both. That means your game effectively only has two threads that are doing any meaningful amount of work. Modern processors have <strong>8 logical cores</strong><sup><a href=#ft_1>1</a></sup>, and the best one currently available has <strong>12</strong>. You&rsquo;re using <em>two of them</em>. You introduced all this complexity and input lag just so you could use 16.6% of the processor instead of 8.3%.</p><p>Instead of trying to create a thread for each individual component, you <a href=http://inception.davepedu.com/>need to go deeper</a>. You have to parallelize each individual component separately, then tie them together in a single-threaded design. This has the added bonus of being vastly more friendly to single-threaded CPUs that <em>can&rsquo;t</em> thread things (like certain phones), because the parallization goes on at a lower level and is invisible to the overall architecture of the library. So instead of having a graphics thread and a physics thread, you simply call the physics update, then call the graphics update, and inside each physics and graphics update you spawn enough worker threads to match the number of cores you have to work with and concurrently process as much stuff as possible. This eliminates latency problems, complicated library designs, and it <em>scales forever</em>. Even if your initial implementation of concurrency won&rsquo;t handle 32 cores, because the concurrency is encapsulated inside the engine, you can just go back and change it later <em>without ever having to modify any programs that use the graphics engine</em>.</p><p>Consequently, don&rsquo;t try to multithread your games. It isn&rsquo;t worth it. Separately parallelize each individual component instead and write your game engine single-threaded; only use additional threads for asynchronous activities like resource loading.</p><p><span style=font-size:80%><br><sup><a name=ft_1>1</a></span> The processors actually only have 4 or 6 <em>physical</em> cores, but use hyperthreading techniques so that 8 or 12 logical cores are presented to the operating system. From a software point of view, however, this is immaterial.</span></p></div><hr><time itemprop=datePublished pubdate=pubdate datetime=2012-05-23T23:46:00+00:00><i class="fa-regular fa-clock fa-fw"></i>&nbsp;Published on <a href=https://erikmcclure.com/blog/multithreading-problems-in-game-design/>May 23, 2012 at 11:46pm</a></time><aside><i class="fa-regular fa-comments fa-fw"></i>&nbsp;<a href=/blog/multithreading-problems-in-game-design/#commento>27 comments</a></aside><aside><i class="fa-regular fa-share-square fa-fw"></i>&nbsp;share:<ul><li><a href="javascript:window.open('https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ferikmcclure.com%2fblog%2fmultithreading-problems-in-game-design%2f','popup','width=600,height=400');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" d="M16.75 9H13.5V7a1 1 0 011-1h2V3H14a4 4 0 00-4 4V9H8v3h2v9h3.5V12H16z"/></svg></a><li><a href="javascript:window.open('https://twitter.com/intent/tweet?text=Multithreading%20Problems%20In%20Game%20Design&url=https%3a%2f%2ferikmcclure.com%2fblog%2fmultithreading-problems-in-game-design%2f','popup','width=600,height=256');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" opacity="0" d="M0 0h24v24H0z"/><path class="st0" d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572.0-4.658 2.086-4.658 4.66.0.364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342.0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3.0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376.0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57.0 13.255-7.098 13.255-13.254.0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg></a></li><li><a href="javascript:window.open('https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2ferikmcclure.com%2fblog%2fmultithreading-problems-in-game-design%2f','popup','width=700,height=380');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><rect class="st0" height="11" width="4" x="3" y="9"/><circle class="st0" cx="5" cy="5" r="2"/><path class="st0" d="M16.5 8.25A4.47251 4.47251.0 0013 9.95343V9H9V20h4V13a2 2 0 014 0v7h4V12.75a4.5 4.5.0 00-4.5-4.5z"/></svg></a></li></ul></aside></article><div class=pager><ul><li><a href=/blog/page/10>Newer</a></li><li style=text-align:center><a href=/blog/>Home</a></li><li style=text-align:right><a href=/blog/page/12>Older</a></li></ul></div></section><section class=archive><article><img src=https://erikmcclure.com/img/avatar.th.png alt=Avatar width=180 height=180><h2>Archive</h2><ol><li><details><summary>2025</summary><ul><li><a href=/blog/discord-overlay-breaks-gsync/>The New Discord Overlay Breaks GSync and Borderless Optimizations</a></li><li><a href=/blog/do-you-really-think-we-have-gender-in-the-future/>Do You Really Think We'll Have Genders In The Future?</a></li></ul></details></li><li><details><summary>2024</summary><ul><li><a href=/blog/stop-making-me-memorize-borrow-checker/>Stop Making Me Memorize The Borrow Checker</a></li><li><a href=/blog/rust-async-makes-me-want-to-gouge-my-eyes-out/>Rust Async Makes Me Want To Gouge My Eyes Out</a></li><li><a href=/blog/engineers-only-get-paid-something-broken/>Engineers Only Get Paid If Something Is Broken</a></li><li><a href=/blog/measuring-competence-is-epistemic-hell/>Measuring Competence Is Epistemic Hell</a></li><li><a href=/blog/we-could-fix-everything-we-just-dont/>We Could Fix Everything, We Just Don't</a></li></ul></details></li><li><details><summary>2023</summary><ul><li><a href=/blog/people-cant-care-about-everything/>People Can't Care About Everything</a></li><li><a href=/blog/discord-should-remove-usernames/>Discord Should Remove Usernames Entirely</a></li></ul></details></li><li><details><summary>2022</summary><ul><li><a href=/blog/money-is-fake/>Money Is Fake. It's Not Real. It's Made Up.</a></li><li><a href=/blog/we-need-new-motherboards/>We Need New Motherboards Before GPUs Collapse Under Their Own Gravity</a></li></ul></details></li><li><details><summary>2021</summary><ul><li><a href=/blog/cpp-constructors-memory-and-lifetimes/>C++ Constructors, Memory, and Lifetimes</a></li><li><a href=/blog/factorio-is-best-interview-we-have/>Factorio Is The Best Technical Interview We Have</a></li></ul></details></li><li><details><summary>2020</summary><ul><li><a href=/blog/why-you-cant-use-prebuilt-llvm-with-cpp17/>Why You Can't Use Prebuilt LLVM 10.0 with C++17</a></li><li><a href=/blog/pressure-based-anti-spam-for-discord-bots/>Pressure Based Anti-Spam for Discord Bots</a></li></ul></details></li><li><details><summary>2019</summary><ul><li><a href=/blog/name-shadowing-should-be-an-operator/>Name Shadowing Should Be An Operator</a></li><li><a href=/blog/a-rant-on-terra/>A Rant On Terra</a></li><li><a href=/blog/risc-is-fundamentally-unscalable/>RISC Is Fundamentally Unscalable</a></li></ul></details></li><li><details><summary>2018</summary><ul><li><a href=/blog/migrating-to-static-blog/>Migrating To A Static Blog</a></li><li><a href=/blog/how-to-avoid-memorizing-times-tables/>How To Avoid Memorizing Times Tables</a></li></ul></details></li><li><details><summary>2017</summary><ul><li><a href=/blog/ignoring-outliers-creates-racist/>Ignoring Outliers Creates Racist Algorithms</a></li><li><a href=/blog/i-used-to-want-to-work-for-google/>I Used To Want To Work For Google</a></li><li><a href=/blog/integrating-luajit-and-autogenerating-c/>Integrating LuaJIT and Autogenerating C Bindings In Visual Studio</a></li><li><a href=/blog/discord-rise-of-bot-wars/>Discord: Rise Of The Bot Wars</a></li><li><a href=/blog/companies-cant-be-apolitical/>Companies Can't Be Apolitical</a></li><li><a href=/blog/windows-wont-let-my-program-crash/>Windows Won't Let My Program Crash</a></li><li><a href=/blog/directx-is-terrifying/>DirectX Is Terrifying</a></li></ul></details></li><li><details><summary>2016</summary><ul><li><a href=/blog/everyone-does-srgb-wrong-because/>Everyone Does sRGB Wrong Because Everyone Else Does sRGB Wrong</a></li><li><a href=/blog/mathematical-notation-is-awful/>Mathematical Notation Is Awful</a></li></ul></details></li><li><details><summary>2015</summary><ul><li><a href=/blog/i-tried-to-install-linux-and-now-i/>I Tried To Install Linux And Now I Regret Everything</a></li><li><a href=/blog/you-arent-designing-software-for-robots/>We Aren't Designing Software For Robots</a></li><li><a href=/blog/using-data-to-balance-your-game-pony/>Using Data To Balance Your Game: Pony Clicker Analysis</a></li><li><a href=/blog/does-anyone-actually-want-good-software/>Does Anyone Actually Want Good Software?</a></li></ul></details></li><li><details><summary>2014</summary><ul><li><a href=/blog/how-not-to-sell-software/>How Not To Install Software</a></li><li><a href=/blog/can-we-choose-what-we-enjoy/>Can We Choose What We Enjoy?</a></li><li><a href=/blog/how-to-make-your-profiler-10x-faster/>How To Make Your Profiler 10x Faster</a></li><li><a href=/blog/the-problem-with-photorealism/>The Problem With Photorealism</a></li></ul></details></li><li><details><summary>2013</summary><ul><li><a href=/blog/googles-decline-really-bugs-me/>Google's Decline Really Bugs Me</a></li><li><a href=/blog/the-educational-imbroglio/>The Educational Imbroglio</a></li><li><a href=/blog/write-less-code/>Write Less Code</a></li><li><a href=/blog/most-people-have-shitty-computers/>Most People Have Shitty Computers</a></li><li><a href=/blog/leap-motion-impressions-input/>Leap Motion Impressions, Input Sanitation, and 3D Gesture Ideas</a></li><li><a href=/blog/aurora-theory-released/>Aurora Theory Released!</a></li><li><a href=/blog/what-i-learned-in-college/>What I Learned In College</a></li><li><a href=/blog/course-notes/>Course Notes</a></li><li><a href=/blog/contact/>Contact</a></li><li><a href=/blog/the-dark-side-of-htmlcss/>The Dark Side of Web Development</a></li><li><a href=/blog/windows-breaks-assert-inside/>Windows Breaks assert() Inside WM_CANCELMODE</a></li><li><a href=/blog/the-productivity-fallacy/>The Productivity Fallacy</a></li></ul></details></li><li><details><summary>2012</summary><ul><li><a href=/blog/c-to-c-tutorial-part-4-operator-overload/>C# to C++ Tutorial - Part 4: Operator Overload</a></li><li><a href=/blog/7-problems-raytracing-doesnt-solve/>7 Problems Raytracing Doesn't Solve</a></li><li><a href=/blog/analyzing-xkcd-click-and-drag/>Analyzing XKCD: Click and Drag</a></li><li><a href=/blog/coordinate-systems-and-cascading/>Coordinate Systems And Cascading Stupidity</a></li><li><a href=/blog/how-joysticks-ruined-my-graphics-engine/>How Joysticks Ruined My Graphics Engine</a></li><li><a href=/blog/multithreading-problems-in-game-design/>Multithreading Problems In Game Design</a></li><li><a href=/blog/stop-following-rules/>Stop Following The Rules</a></li><li><a href=/blog/why-windows-8-does-right-thing-wrong/>Why Windows 8 Does The Right Thing The Wrong Way</a></li><li><a href=/blog/visual-studio-broke-my-computer/>Visual Studio Broke My Computer</a></li><li><a href=/blog/implicit-ui-design/>Implicit UI Design</a></li><li><a href=/blog/linux-mint-12-kde/>Linux Mint 12 KDE</a></li><li><a href=/blog/new-post/>'Programmer' is an Overgeneralization</a></li></ul></details></li><li><details><summary>2011</summary><ul><li><a href=/blog/great-mystery-of-linear-gradient/>The Great Mystery of Linear Gradient Lighting</a></li><li><a href=/blog/signed-integers-considered-stupid-like/>Signed Integers Considered Stupid (Like This Title)</a></li><li><a href=/blog/c-to-c-tutorial-part-3-classes-and/>C# to C++ Tutorial - Part 3: Classes and Structs and Inheritance (OH MY!)</a></li><li><a href=/blog/problem-of-vsync/>The Problem of Vsync</a></li><li><a href=/blog/c-to-c-tutorial-part-2-pointers/>C# to C++ Tutorial - Part 2: Pointers Everywhere!</a></li><li><a href=/blog/c-to-c-tutorial-part-1-basics-of-syntax/>C# to C++ Tutorial - Part 1: Basics of Syntax</a></li><li><a href=/blog/ninth-circle-of-bugs/>The Ninth Circle of Bugs</a></li><li><a href=/blog/investigating-low-level-cpu-performance/>Investigating Low-level CPU Performance</a></li></ul></details></li><li><details><summary>2010</summary><ul><li><a href=/blog/im-failure/>The IM Failure</a></li><li><a href=/blog/album-for-sale-renascent/>Album For Sale! [Renascent]</a></li><li><a href=/blog/wavsaver/>WavSaver</a></li><li><a href=/blog/pixel-perfect-hit-testing/>Pixel Perfect Hit Testing</a></li><li><a href=/blog/8-bit-color-cycling/>8-bit color cycling</a></li><li><a href=/blog/physics-networking/>Physics Networking</a></li><li><a href=/blog/assembly-cas-implementation/>Assembly CAS implementation</a></li><li><a href=/blog/function-pointer-speed/>Function Pointer Speed</a></li><li><a href=/blog/most-bizarre-error-ever/>Most Bizarre Error Ever</a></li></ul></details></li><li><details><summary>2009</summary><ul><li><a href=/blog/physics-oriented-network-interpolation/>Physics-oriented Network Interpolation</a></li></ul></details></li></ol></article></section></main><footer><p><span>Copyright &copy;2025 Erik McClure</span> <a href=https://erikmcclure.com/sitemap.xml>Sitemap</a> | <a href=https://erikmcclure.com/blog/index.xml>RSS Feed</a></p></footer></div><script>"use strict";window.onload=function(){e=document.getElementsByClassName("math");for(var e,t=0,n=e.length;t<n;t++)renderMathInElement(e[t],{delimiters:[{left:"$$",right:"$$",display:!1},{left:"\\[",right:"\\]",display:!0}]})}</script></body></html>