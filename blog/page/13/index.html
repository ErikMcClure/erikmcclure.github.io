<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=Edge"><meta http-equiv=permissions-policy content="interest-cohort=()"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#2b7bb5"><meta name=copyright content="Copyright (c)2025 Erik McClure"><meta name=keywords content="games,music,code,erik mcclure,erikmcclure,aurora theory,sweetie bot,discord,feathergui,fading light,tinyoal,cloud hop"><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"><meta name=google-site-verification content="Oxb2ia8HjcHLXlvstA8xPpQO3BO_y15Ds2Ia-feq1MQ"><meta name=generator content="Hugo 0.119.0"><link rel=me href=https://equestria.social/@cloudhop><link rel=canonical href=https://erikmcclure.com/blog/><link rel=apple-touch-icon href=https://erikmcclure.com/favicon.ico><link rel="shortcut icon" type=image/x-icon href=https://erikmcclure.com/favicon.ico><link rel=stylesheet href=https://erikmcclure.com/css/main.css><link rel=stylesheet href=https://erikmcclure.com/css/prism.css rel=stylesheet><link rel=stylesheet href=https://erikmcclure.com/css/katex.min.css rel=stylesheet><link rel=stylesheet href=https://erikmcclure.com/css/fontawesome.min.css><link rel=stylesheet href=https://erikmcclure.com/css/regular.min.css><link rel=stylesheet href=https://erikmcclure.com/css/brands.min.css><link rel=stylesheet href=https://erikmcclure.com/css/solid.min.css><link rel=alternate type=application/rss+xml title="Erik McClure - RSS" href=https://erikmcclure.com/blog/index.xml><meta property="og:type" content="website"><title>Blogs - Erik McClure</title><meta property="og:title" content="Blogs - Erik McClure"><meta name=twitter:title content="Blogs - Erik McClure"><meta itemprop=name content="Blogs - Erik McClure"><meta name=description content="Applied mathematician and software architect who occasionally writes music."><meta property="og:description" content="Applied mathematician and software architect who occasionally writes music."><meta name=twitter:description content="Applied mathematician and software architect who occasionally writes music."><meta itemprop=description content="Applied mathematician and software architect who occasionally writes music."><meta property="og:url" content="https://erikmcclure.com/"><meta property="og:site_name" content="Erik McClure"><meta property="og:image" content="https://erikmcclure.com/img/avatar.png"><meta property="og:locale" content="en-US"><meta property="article:author" content="Erik McClure"><meta name=twitter:card content="summary"><meta name=twitter:site content="@erikmcclure0173"><meta name=twitter:creator content="@erikmcclure0173"><meta name=twitter:image content="https://erikmcclure.com/img/avatar.png"><meta name=twitter:dnt content="on"><link href=https://plus.google.com/104896885003230920472 rel=publisher><meta itemprop=image content="https://erikmcclure.com/img/avatar.png"><meta name=last-updated content="20250119-10:16:00.000"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-63026815-3"></script>
<script defer src=https://erikmcclure.com/syntax-prism.js></script>
<script defer src=https://erikmcclure.com/katex.min.js></script>
<script defer src=https://erikmcclure.com/mathtex-script-type.min.js></script>
<script defer src=https://erikmcclure.com/auto-render.min.js></script>
<script defer src=https://cdn.commento.io/js/count.js></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-63026815-3")</script></head><body><div id=container><header><nav><ul><li><a href=/blog/ title=Blog><i class="fa-solid fa-book fa-fw fa-lg"></i>&nbsp;<p>Blog</p></a></li><li><a href=/projects/ title=Projects><i class="fa-solid fa-briefcase fa-fw fa-lg"></i>&nbsp;<p>Projects</p></a></li><li><a href=https://erikmcclure.bandcamp.com title=Bandcamp><i class="fa-brands fa-bandcamp fa-fw fa-lg"></i>&nbsp;<p>Bandcamp</p></a></li><li><a href=https://github.com/erikmcclure title=Github><i class="fa-brands fa-github fa-fw fa-lg"></i>&nbsp;<p>Github</p></a></li><li><a href=/web/ title=Websites><i class="fa-solid fa-globe fa-fw fa-lg"></i>&nbsp;<p>Websites</p></a></li></ul></nav><div class=dim><h1>Erik McClure</h1></div></header><main class=blog><section><article><h4><a href=/blog/great-mystery-of-linear-gradient/>The Great Mystery of Linear Gradient Lighting</a></h4><hr><div class=padding><p>A long, long time ago, in pretty much the same place I&rsquo;m sitting in right now, I was learning how one would do 2D lighting with soft shadows and discovered the age old adage in 2D graphics: linear gradient lighting looks better than mathematically correct inverse square lighting.</p><p>Strange.</p><p>I brushed it off as artistic license and perceptual trickery, but over the years, as I dug into advanced lighting concepts, nothing could explain this. It was a mystery. Around the time I discovered microfacet theory I figured it could theoretically be an attempt to approximate non-lambertanian reflectance models, but even that wouldn&rsquo;t turn an exponential curve into a linear one.</p><p>This bizarre law even showed up in my 3D lighting experiments. Attempting to invoke the inverse square law would simply result in extremely bright and dark areas and would look absolutely terrible, and yet the only apparent fix I saw anywhere was simply calculating light via linear distance in clear violation of observed light behavior. Everywhere I looked, people calculated light on a linear basis, everywhere, on everything. Was it the equations? Perhaps the equations being used operated on linear light values instead of exponential ones and so only output the correct value if the light was linear? No, that wasn&rsquo;t it. I couldn&rsquo;t figure it out. Years and years and years would pass with this discrepancy left unaccounted for.</p><p>A few months ago I noted an article on gamma correction and assumed it was related to color correction or some other post process effect designed to compensate for monitor behavior, and put it as a very low priority research point on my mental to-do-list. No reason fixing up minor brightness problems until your graphics engine can actually render everything properly. Yesterday, though, I happened across a <a href="http://news.ycombinator.com/item?id=3294840">Hacker News</a> posting about learning modern 3D engine programming. Curious if it had anything I didn&rsquo;t already know, I ran through its topics, and <a href=http://www.arcsynthesis.org/gltut/Texturing/Tutorial%2016.html>found this</a>. Gamma correction wasn&rsquo;t just making the scene brighter to fit with the monitor, it was compensating for the fact that <em>most images are actually already gamma-corrected</em>.</p><p>In a nutshell, the brightness of a monitor is exponential, not linear (with a power of about 2.2). The result is that a linear gradient displayed on the monitor is not actually increasing in brightness linearly. Because it&rsquo;s mapped to a curve, it will actually increase in brightness exponentially. This is due to the human visual system processing luminosity on a logarithmic scale. The curve in question is this:</p><p><a href=http://http.developer.nvidia.com/GPUGems3/elementLinks/24fig02.jpg target=_blank><img src=http://http.developer.nvidia.com/GPUGems3/elementLinks/24fig02.jpg alt="Gamma Response Curve"></a>
<span style=font-size:80%><br><i>Source: <a href=http://http.developer.nvidia.com/GPUGems3/gpugems3_ch24.html>GPU Gems 3 - Chapter 24: The Importance of Being Linear</a></i></span></p><p>You can see the effect in this picture, taken from the <a href=http://www.arcsynthesis.org/gltut/Texturing/Tutorial%2016.html>article I mentioned</a>:
<a href=http://www.arcsynthesis.org/gltut/Texturing/Gamma%20Ramp%20sRGB.png target=_blank><img src=http://www.arcsynthesis.org/gltut/Texturing/Gamma%20Ramp%20sRGB.png alt="Linear Curve"></a></p><p>The thing is, I always assumed the top linear gradient was a linear gradient. Sure it looks a little dark, but hey, I suppose that might happen if you&rsquo;re increasing at 25% increments, right? <strong>WRONG</strong>. The <em>bottom strip</em> is a true linear gradient<sup>1</sup>. The top strip is a literal assignment of linear gradient RGB values, going from 0 to 62 to 126, etc. While this is, digitally speaking, a mathematical linear gradient, what happens when it gets displayed on the screen? It gets distorted by the CRT Gamma curve seen in the above graph, which makes the end value <em>exponential</em>. The bottom strip, on the other hand, is gamma corrected - it is NOT a mathematical linear gradient. It&rsquo;s values go from 0 to <strong>134</strong> to <strong>185</strong>. As a result, when this exponential curve is displayed on your monitor, it&rsquo;s values are dragged down by the exact inverse exponential curve, resulting in a true linear curve. An image that has been &ldquo;gamma-corrected&rdquo; in this manner is said to exist in sRGB color space.</p><p>The thing is, most images <em>aren&rsquo;t linear</em>. They&rsquo;re actually in the sRGB color space, otherwise they&rsquo;d look totally wrong when we viewed them on our monitors. Normally, this doesn&rsquo;t matter, which is why most 2D games simply ignore gamma completely. Because all a 2D engine does is take a pixel and display it on the screen without touching it, if you enable gamma correction you will actually <em>over-correct</em> the image and it will look terrible. This becomes a problem with image editing, because digital artists are drawing and coloring things on their monitors and they try to make sure that everything looks good <em>on their monitor</em>. So if an artist were visually trying to make a linear gradient, they would probably make something similar to the already gamma-corrected strip we saw earlier. Because virtually no image editors linearize images when saving (for good reason), the resulting image an artist creates is <em>actually in sRGB color space</em>, which is why only turning on gamma correction will usually simply make everything look bright and washed out, since you are normally using images that are <em>already gamma-corrected</em>. This is actually good thing due to subtle precision issues, but it creates a serious problem when you start trying to do lighting calculations.</p><p>The thing is, lighting calculations are linear operations. It&rsquo;s why you use Linear Algebra for most of your image processing needs. Because of this, when I tried to use the inverse-square law for my lighting functions, the resulting value that I was multiplying on to the already-gamma-corrected image <em><strong>was not gamma corrected!</strong></em> In order to do proper lighting, you would have to first linearize the gamma-corrected image, perform the lighting calculation on it, and then re-gamma-correct the end result.</p><p>Wait a minute, what did we say the gamma curve value was? It&rsquo;s <span class=math>$$ x^{2.2} $$</span>, so <span class=math>$$ x^{0.45} $$</span> will gamma-correct the value <span class=math>$$ x $$</span>. But the inverse square law states that the intensity of a light is actually <span class=math>$$ \frac{1}{x^2} $$</span>, so if you were to gamma correct the inverse square law, you&rsquo;d end up with:<div class=math>\[ {\bigg(\frac{1}{x^2}}\bigg)^{0.45} = {x^{-2}}^{0.45} = x^{-0.9} ≈ x^{1} \]</div><em>That&rsquo;s almost linear!<sup>2</sup></em></p><p><strong><span style=font-size:200%>OH MY GOD<br></span></strong><a href=http://bucultureshock.com/wp-content/uploads/2011/10/mind-blown-11.jpeg target=_blank><img src=http://bucultureshock.com/wp-content/uploads/2011/10/mind-blown-11.jpeg alt="MIND == BLOWN"></a></p><p><em><strong>That&rsquo;s it!</strong></em> The reason I saw linear curves all over the place was because it was a rough approximation to gamma correction! The reason linear lighting looks good in a 2D game is because its actually an approximation to a <em>gamma-corrected inverse-square law!</em> <strong>Holy shit!</strong> Why didn&rsquo;t anyone ever explain this?!<sup>3</sup> Now it all makes sense! Just to confirm my findings, I went back to my 3D lighting experiment, and sure enough, after correcting the gamma values, using the inverse square law for the lighting gave correct results! <strong>MUAHAHAHAHAHAHA!</strong></p><p>For those of you using OpenGL, you can implement gamma correction as explained in the article <a href=http://www.arcsynthesis.org/gltut/Texturing/Tutorial%2016.html>mentioned above</a>. For those of you using DirectX9 (not 10), you can simply enable <code>D3DSAMP_SRGBTEXTURE</code> on whichever texture stages are using sRGB textures (usually only the diffuse map), and then enable <code>D3DRS_SRGBWRITEENABLE</code> during your drawing calls (a gamma-correction stateblock containing both of those works nicely). For things like GUI, you&rsquo;ll probably want to bypass the sRGB part. Like OpenGL, you can also skip <code>D3DRS_SRGBWRITEENABLE</code> and simply gamma-correct the entire blended scene using <code>D3DCAPS3_LINEAR_TO_SRGB_PRESENTATION</code> in the <code>Present()</code> call, but this has a lot of caveats attached. In DirectX10, you no longer use <code>D3DSAMP_SRGBTEXTURE</code>. Instead, you use an sRGB texture format (see <a href=http://download.microsoft.com/download/b/5/5/b55d67ff-f1cb-4174-836a-bbf8f84fb7e1/Picture%20Perfect%20-%20Gamma%20Through%20the%20Rendering%20Pipeline.zip>this presentation</a> for details).</p><span style=font-size:80%><br><sup>1</sup> or at least much closer, depending on your monitors true gamma response<br><sup>2</sup> In reality I'm sweeping a whole bunch of math under the table here. What you really have to do is move the inverse square curve around until it overlaps the gamma curve, then apply it, and you'll get something that is <a href="http://www.wolframalpha.com/input/?i=plot+%281%2F%28x-1.9%29%5E2+-+0.25%29%5E0.45+from+0+to+1">roughly linear</a>.<br><sup>3</sup> If this is actually standard course material in a real graphics course, and I am just *really bad* at finding good tutorials, I apologize for the palm hitting your face right now.</span></div><hr><time itemprop=datePublished pubdate=pubdate datetime=2011-12-01T13:36:00+00:00><i class="fa-regular fa-clock fa-fw"></i>&nbsp;Published on <a href=https://erikmcclure.com/blog/great-mystery-of-linear-gradient/>December 1, 2011 at 1:36pm</a></time><aside><i class="fa-regular fa-comments fa-fw"></i>&nbsp;<a href=/blog/great-mystery-of-linear-gradient/#commento>2 comments</a></aside><aside><i class="fa-regular fa-share-square fa-fw"></i>&nbsp;share:<ul><li><a href="javascript:window.open('https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ferikmcclure.com%2fblog%2fgreat-mystery-of-linear-gradient%2f','popup','width=600,height=400');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" d="M16.75 9H13.5V7a1 1 0 011-1h2V3H14a4 4 0 00-4 4V9H8v3h2v9h3.5V12H16z"/></svg></a><li><a href="javascript:window.open('https://twitter.com/intent/tweet?text=The%20Great%20Mystery%20of%20Linear%20Gradient%20Lighting&url=https%3a%2f%2ferikmcclure.com%2fblog%2fgreat-mystery-of-linear-gradient%2f','popup','width=600,height=256');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" opacity="0" d="M0 0h24v24H0z"/><path class="st0" d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572.0-4.658 2.086-4.658 4.66.0.364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342.0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3.0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376.0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57.0 13.255-7.098 13.255-13.254.0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg></a></li><li><a href="javascript:window.open('https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2ferikmcclure.com%2fblog%2fgreat-mystery-of-linear-gradient%2f','popup','width=700,height=380');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><rect class="st0" height="11" width="4" x="3" y="9"/><circle class="st0" cx="5" cy="5" r="2"/><path class="st0" d="M16.5 8.25A4.47251 4.47251.0 0013 9.95343V9H9V20h4V13a2 2 0 014 0v7h4V12.75a4.5 4.5.0 00-4.5-4.5z"/></svg></a></li></ul></aside></article><article><h4><a href=/blog/signed-integers-considered-stupid-like/>Signed Integers Considered Stupid (Like This Title)</a></h4><hr><div class=padding><p><em>Unrelated note: If you title your article &ldquo;[x] considered harmful&rdquo;, you are a horrible person with no originality. Stop doing it.</em></p><p>Signed integers have always bugged me. I&rsquo;ve seen quite a bit of signed integer overuse in C#, but it is most egregious when dealing with C/C++ libraries that, for some reason, insist on using <code>for(int i = 0; i &lt; 5; ++i)</code>. Why would you <em>ever</em> write that? <code>i</code> cannot possibly be negative and for that matter shouldn&rsquo;t be negative, ever. Use <code>for(unsigned int i = 0; i &lt; 5; ++i)</code>, for crying out loud.</p><p>But really, that&rsquo;s not a fair example. You don&rsquo;t really lose anything using an integer for the i value there because its range isn&rsquo;t large enough. The places where this become stupid are things like using an integer for height and width, or returning a signed integer count. Why on earth would you want to return a negative count? If the count fails, return an unsigned -1, which is just the maximum possible value for your chosen unsigned integral type. Of course, <em>certain people</em> seem to think this is a bad idea because then you will return the largest positive number possible. What if they interpret that as a valid count and try to allocate 4 gigs of memory? Well gee, I don&rsquo;t know, what happens when you try to allocate -1 bytes of memory? In both cases, something is going to explode, and in both cases, its because the person using your code is an idiot. Neither way is more safe than the other. In fact, signed integers cause far more problems then they solve.</p><p>One of the most painfully obvious issues here is that virtually every single architecture in the world uses the <a href="http://en.wikipedia.org/wiki/Two's_complement">two&rsquo;s complement</a> representation of signed integers. When you are using two&rsquo;s complement on an 8-bit signed integer type (a <code>char</code> in C++), the largest positive value is 127, and the largest negative value is -128. That means a signed integer can represent a negative number so large <em>it cannot be represented as a positive number</em>. What happens when you do <code>(char)abs(-128)</code>? It tries to return 128, which overflows back to&mldr; -128. This is the cause of a host of security problems, and what&rsquo;s hilarious is that a lot of people try to use this to fuel their argument that you should use C# or Java or Haskell or some other esoteric language that makes them feel smart. The fact is, any language with fixed size integers has this problem. That means C# has it, Java has it, most languages have it to some degree. This bug doesn&rsquo;t mean you should stop using C++, it means you need to <em>stop using signed integers in places they don&rsquo;t belong</em>. Observe the following code:</p><pre class=language-cpp><code>if (*p == &#39;*&#39;)
  {
    ++p;
    total_width += abs (va_arg (ap, int));
  }</code></pre><p>This is <em>retarded</em>. Why on earth are you interpreting an argument as a signed integer only to then immediately call <code>abs()</code> on it? So a brain damaged programmer can throw in negative values and not blow things up? If it can only possibly be valid when it is a positive number, interpret it as a <em><code>unsigned int</code></em>. Even if someone tries putting in a negative number, they will serve only to make the <code>total_width</code> abnormally large, instead of potentially putting in -128, causing <code>abs()</code> to return -128 and creating a <code>total_width</code> that is far too small, causing a buffer overflow and hacking into your program. And don&rsquo;t go declaring <code>total_width</code> as a signed integer either, because that&rsquo;s just stupid. Using an unsigned integer here closes a potential security hole and makes it even harder for a dumb programmer to screw things up<sup><a href=#foot1>1</a></sup>.</p><p>I can only attribute the vast overuse of <code>int</code> to programmer laziness. <code>unsigned int</code> is just too long to write. Of course, that&rsquo;s what <code>typedef</code>&rsquo;s are for, so that isn&rsquo;t an excuse, so maybe they&rsquo;re worried a programmer won&rsquo;t understand how to put a -1 into an <code>unsigned int</code>? Even if they didn&rsquo;t, you could still cast the <code>int</code> to an <code>unsigned int</code> to serve the same purpose and close the security hole. I am simply at a loss as to why I see <code>int</code>&rsquo;s all over code that could never possibly be negative. If it could never possibly be negative, you are therefore <em>assuming</em> that it won&rsquo;t be negative, so it&rsquo;s a much better idea to just make it <em>impossible</em> for it to be negative instead of giving hackers 200 possible ways to break your program.</p><span style=font-size:80%><sup><a name=foot1>1</a></sup> There's actually another error here in that <code>total_width</code> can overflow even when unsigned, and there is no check for that, but that's beyond the scope of this article.</span></div><hr><time itemprop=datePublished pubdate=pubdate datetime=2011-11-24T16:02:00+00:00><i class="fa-regular fa-clock fa-fw"></i>&nbsp;Published on <a href=https://erikmcclure.com/blog/signed-integers-considered-stupid-like/>November 24, 2011 at 4:02pm</a></time><aside><i class="fa-regular fa-comments fa-fw"></i>&nbsp;<a href=/blog/signed-integers-considered-stupid-like/#commento>13 comments</a></aside><aside><i class="fa-regular fa-share-square fa-fw"></i>&nbsp;share:<ul><li><a href="javascript:window.open('https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ferikmcclure.com%2fblog%2fsigned-integers-considered-stupid-like%2f','popup','width=600,height=400');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" d="M16.75 9H13.5V7a1 1 0 011-1h2V3H14a4 4 0 00-4 4V9H8v3h2v9h3.5V12H16z"/></svg></a><li><a href="javascript:window.open('https://twitter.com/intent/tweet?text=Signed%20Integers%20Considered%20Stupid%20%28Like%20This%20Title%29&url=https%3a%2f%2ferikmcclure.com%2fblog%2fsigned-integers-considered-stupid-like%2f','popup','width=600,height=256');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" opacity="0" d="M0 0h24v24H0z"/><path class="st0" d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572.0-4.658 2.086-4.658 4.66.0.364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342.0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3.0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376.0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57.0 13.255-7.098 13.255-13.254.0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg></a></li><li><a href="javascript:window.open('https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2ferikmcclure.com%2fblog%2fsigned-integers-considered-stupid-like%2f','popup','width=700,height=380');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><rect class="st0" height="11" width="4" x="3" y="9"/><circle class="st0" cx="5" cy="5" r="2"/><path class="st0" d="M16.5 8.25A4.47251 4.47251.0 0013 9.95343V9H9V20h4V13a2 2 0 014 0v7h4V12.75a4.5 4.5.0 00-4.5-4.5z"/></svg></a></li></ul></aside></article><article><h4><a href=/blog/c-to-c-tutorial-part-3-classes-and/>C# to C++ Tutorial - Part 3: Classes and Structs and Inheritance (OH MY!)</a></h4><hr><div class=padding><p>[ <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-1-basics-of-syntax/>1</a> · <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-2-pointers/>2</a> · <strong>3</strong> · <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-4-operator-overload/>4</a> <span style=color:#aaa>&#183; 5 &#183; 6 &#183; 7</span> ]</p><p>Classes in C#, like most object-oriented languages, are very similar to their C++ counterparts. They are declared with <code>class</code>, exist between brackets and inherit classes using a colon <code>':'</code>. Note, however, that all classes in C++ <strong>must end with a semicolon!</strong> You will forget this semicolon, and then <em>all the things will break</em>. You can do pretty much everything you can do with a C# class in a C++ class, except that C++ does not have <code>partial</code> classes, and in C++ classes themselves cannot be declared <code>public</code>, <code>protected</code> or <code>private</code>. Both of these features don&rsquo;t exist because they are made irrelevant with how classes are declared in header files.</p><p>In C# you usually just have one code file with the class declared in it along with all the code for all the functions. You can just magically use this class everywhere else and everything is fun and happy with rainbows. As mentioned before, C++ uses header files, and they are heavily integrated into the class system. We saw before how in order to use a function somewhere else, its prototype must first be declared in the header file. This applies to both classes and pretty much everything else. You need to understand that unlike C#, C++ does not have magic dust in its compiler. In C++, it just goes down the list of .cpp files, does a bit of dependency optimization, and then simply compiles each .cpp file by taking all the content from all the headers that are included (including all the headers included in the headers) and pasting it before the actual code from the .cpp file, and compiling. This process is repeated separately for every single code file, and no order inconsistencies are allowed anywhere in the code, the headers, <em>or even the order that the headers are included in</em>. The compiler literally takes every single #include statement as it is and simply replaces it with the code of the header it points to, wherever this happens to be in the code. This can (and this has happened to me) result in certain configurations of header files working even though one header file is actually missing a dependency. For example:<pre class=language-cpp><code>//Rainbow.h

class Rainbow
{
  Unicorn _unicorns[5]; // 5 unicorns dancing on rainbows
}; // DO NOT FORGET THE SEMICOLON
</code></pre><pre class=language-cpp><code>//Unicorn.h

class Unicorn
{
  int magic;
};
</code></pre><pre class=language-cpp><code>//main.cpp

#include &#34;Unicorn.h&#34;
#include &#34;Rainbow.h&#34;

int main(int argc, char *argv[]) 
{
  Rainbow rainbow;
}
</code></pre>Compiling main.cpp will succeed in this case, even though Rainbow.h is referencing the <code>Unicorn</code> class without it ever being declared. The reason behind this is what happens when the compiler expands all the includes. Right before compiling main.cpp (after the preprocessor has run), main.cpp looks like this:<pre class=language-cpp><code>//main.cpp

//Unicorn.h

class Unicorn
{
  int magic;
};
//Rainbow.h

class Rainbow
{
  Unicorn _unicorns[5]; // 5 unicorns dancing on rainbows
}; // DO NOT FORGET THE SEMICOLON

int main(int argc, char *argv[]) 
{
  Rainbow rainbow;
}
</code></pre>It is now obvious that because Rainbow.h was included after Unicorn.h, the <code>Unicorn</code> reference was resolved since it was declared before <code>Rainbow</code>. However, had we reversed the order of the include files, we would have had an anachronism: an inconsistency in our chronological arrangement. It is very bad practice to construct headers that are dependent on the order in which they are included, so we usually resolve something like this by having Rainbow.h simply include Unicorn.h, and then it won&rsquo;t matter what order they are included in.<pre class=language-cpp><code>//Rainbow.h

#include &#34;Unicorn.h&#34;

class Rainbow
{
  Unicorn _unicorns[5]; // 5 unicorns dancing on rainbows
};
</code></pre>Left as is, however, and we run into a problem. Lets try compiling main.cpp:<pre class=language-cpp><code>//main.cpp

#include &#34;Rainbow.h&#34;
#include &#34;Unicorn.h&#34;

int main(int argc, char *argv[]) 
{
  Rainbow rainbow;
}
</code></pre><pre class=language-cpp><code>//main.cpp

//Rainbow.h

#include &#34;Unicorn.h&#34;

class Rainbow
{
  Unicorn _unicorns[5]; // 5 unicorns dancing on rainbows
};
//Unicorn.h

class Unicorn
{
  int magic;
};

int main(int argc, char *argv[]) 
{
  Rainbow rainbow;
}
</code></pre><pre class=language-cpp><code>//main.cpp

//Rainbow.h

//Unicorn.h

class Unicorn
{
  int magic;
};

class Rainbow
{
  Unicorn _unicorns[5]; // 5 unicorns dancing on rainbows
};
//Unicorn.h

class Unicorn
{
  int magic;
};

int main(int argc, char *argv[]) 
{
  Rainbow rainbow;
}
</code></pre>We&rsquo;ve just declared <code>Unicorn</code> twice! Obviously one way to solve this in our very, very simplistic example is to just remove the spurious <code>#include</code> statement, but this violates the unwritten rule of header files - any header file should be able to be included anywhere in any order regardless of what other header files have been included. This means that, first, any header file should include all the header files that it needs to resolve its dependencies. However, as we see here, that simply makes it extremely likely that a header file will get included 2 or 3 or maybe hundreds of times. What we need is an <strong>include guard</strong>.<pre class=language-cpp><code>//Unicorn.h

#ifndef __UNICORN_H__
#define __UNICORN_H__

class Unicorn
{
  int magic;
};

#endif
</code></pre>Understanding this requires knowledge of the <strong>C Preprocessor</strong>, which is what goes through and <em>processes</em> your code before its compiled. It is very powerful, but right now we only need to know the basics. Any statement starting with <code>#</code> is a preprocessor command. You will notice that <code>#include</code> is itself a preprocessor command, which makes sense, since the preprocessor was replacing those <code>#include</code>&rsquo;s with the code they contained. <code>#define</code> lets you <em>define</em> a constant (or if you want to be technical, an <em>object-like macro</em>). It can be equal to a number or a word or just not be equal to anything and simply be in a <em>defined state</em>. <code>#ifdef</code> and <code>#endif</code> are just an if statement that allows the code inside of it to exist if the given constant is <em>defined</em>. <code>#ifndef</code> simply does the opposite - the code inside only exists if the given constant <em>doesn&rsquo;t</em> exist.</p><p>So, what we do is pick a constant name that probably will never be used in anything else, like <code>__UNICORN_H__</code>, and put in a check to see if it is defined. The first time the header is reached, it won&rsquo;t be defined, so the code inside <code>#ifndef</code> will exist. The next line tells the preprocessor to define<code> __UNICORN_H__</code>, the constant we just checked for. That means that the next time this header is included, <code>__UNICORN_H__</code> will have been defined, and so the code will be skipped over. Observe:<pre class=language-cpp><code>//main.cpp

#include &#34;Rainbow.h&#34;
#include &#34;Unicorn.h&#34;

int main(int argc, char *argv[]) 
{
  Rainbow rainbow;
}
</code></pre><pre class=language-cpp><code>//main.cpp

//Rainbow.h

#include &#34;Unicorn.h&#34;

class Rainbow
{
  Unicorn _unicorns[5]; // 5 unicorns dancing on rainbows
};
//Unicorn.h

#ifndef __UNICORN_H__
#define __UNICORN_H__

class Unicorn
{
  int magic;
};

#endif

int main(int argc, char *argv[]) 
{
  Rainbow rainbow;
}
</code></pre><pre class=language-cpp><code>//main.cpp

//Rainbow.h

//Unicorn.h

#ifndef __UNICORN_H__
#define __UNICORN_H__

class Unicorn
{
  int magic;
};

#endif

class Rainbow
{
  Unicorn _unicorns[5]; // 5 unicorns dancing on rainbows
};
//Unicorn.h

#ifndef __UNICORN_H__
#define __UNICORN_H__

class Unicorn
{
  int magic;
};

#endif

int main(int argc, char *argv[]) 
{
  Rainbow rainbow;
}
</code></pre><pre class=language-cpp><code>//main.cpp

//Rainbow.h

//Unicorn.h

#ifndef __UNICORN_H__
#define __UNICORN_H__

class Unicorn
{
  int magic;
};

#endif

class Rainbow
{
  Unicorn _unicorns[5]; // 5 unicorns dancing on rainbows
};
//Unicorn.h

#ifndef __UNICORN_H__
#endif

int main(int argc, char *argv[]) 
{
  Rainbow rainbow;
}
</code></pre><pre class=language-cpp><code>//main.cpp

//Rainbow.h

//Unicorn.h


class Unicorn
{
  int magic;
};


class Rainbow
{
  Unicorn _unicorns[5]; // 5 unicorns dancing on rainbows
};
//Unicorn.h


int main(int argc, char *argv[]) 
{
  Rainbow rainbow;
}
</code></pre>Our problem is solved! However, note that <code>//Unicorn.h</code> was left in, because it was outside the include guard. It is <strong>absolutely critical</strong> that you put <em>everything</em> inside your include guard (ignoring comments), or it will either not work properly or be extremely inefficient.<pre class=language-cpp><code>//Rainbow.h

#include &#34;Unicorn.h&#34;

#ifndef __RAINBOW_H__ //WRONG WRONG WRONG WRONG WRONG
#define __RAINBOW_H__

class Rainbow
{
  Unicorn _unicorns[5]; // 5 unicorns dancing on rainbows
};

#endif
</code></pre>In this case, the code still <em>compiles</em>, because the include guards prevent duplicate definitions, but its very taxing on the preprocessor that will repeatedly attempt to include <code>Unicorn.h</code> only to discover that it must be skipped over anyway. The preprocessor may be powerful, but it is also <strong>very dumb</strong> and is easily crippled. The thing is slow enough as it is, so try to keep its workload to a minimum by putting your <code>#include</code>&rsquo;s inside the include guard. Also, don&rsquo;t put semicolons on preprocessor directives. Even though almost everything else in the entire language wants semicolons, semicolons in preprocessor directives will either be redundant or considered a syntax error.<pre class=language-cpp><code>//Rainbow.h

#ifndef __RAINBOW_H__
#define __RAINBOW_H__

#include &#34;Unicorn.h&#34; // SMILES EVERYWHERE!

class Rainbow
{
  Unicorn _unicorns[5]; // 5 unicorns dancing on rainbows
};

#endif
</code></pre>Ok, so now we know how to properly use header files, but not how they are used to declare classes. Let&rsquo;s take a class declared in C#, and then transform it into an equivalent prototype in C++.<pre class=language-csharp><code>public class Pegasus : IComparable&lt;Pegasus&gt;
{
  private Rainbow rainbow;
  protected int magic;
  protected bool flying;

  const int ID=10;
  static int total=0;
  const string NAME=&#34;Pegasus&#34;;

  public Pegasus()
  {
    flying=false;
    magic=1;
    IncrementTotal();
  }
  ~Pegasus()
  {
    magic=0;
  }
  public void Fly()
  {
    flying=true;
  }
  private void Land()
  {
    flying=false;
  }
  public static string GetName()
  {
    return NAME;
  }
  private static void IncrementTotal()
  {
    ++total;
  }
  public int CompareTo(Pegasus other)
  {
    return 0;
  }
}
</code></pre><pre class=language-cpp><code>class Pegasus : public IComparable&lt;Pegasus&gt;
{
public:
  Pegasus();
  ~Pegasus();
  void Fly();
  virtual int CompareTo(Pegasus&amp; other);
  
  static const int ID=10;
  static int total;
  static const char* NAME;

  inline static void IncrementTotal() { ++total; }

protected:
  int magic;
  bool flying;

private:
  void Land();
  
  Rainbow rainbow;
};
</code></pre>Immediately, we are introduced to C++&rsquo;s method of dealing with <code>public</code>, <code>protected</code> and <code>private</code>. Instead of specifying it for each item, they are done in groups. The inheritance syntax is identical, and we&rsquo;ve kept the static variables, but now only one of them is being initialized in the class. In C++, you cannot initialize a static variable inside a class unless it is a <code>static const int</code> (or any other integral type). Instead, we will have to initialize <code>total</code> and <code>NAME</code> when we get around to implementing the code for this class. In addition, while most of the functions do not have code, as expected, <code>IncrementTotal</code> does. As an aside, C# does not have <code>static const</code> because it considers it redundant - all constant values are static. C++, however, allows you to declare a <code>const</code> variable that isn&rsquo;t static. While this would be useless in C#, there are certain situations where it is useful in C++.</p><p>If a given function&rsquo;s code doesn&rsquo;t have any dependencies unavailable in the header file the class is declared in, you can define that method in the class prototype itself. However, <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-1-basics-of-syntax/#header-code>as I mentioned before</a>, code in header files runs the danger of being compiled twice. While the compiler is usually good about properly instancing the class, it is usually a good idea to <code>inline</code> any functions defined in the header. Functions that are <code>inline</code>&rsquo;d are embedded inside code that calls them instead of being explicitly called. That means instead of pushing arguments on to the stack and returning, the compiler simply embeds the function inside of the code that called it, like so:<pre class=language-cpp><code>#include &#34;Pegasus.h&#34;

// Before compilation
int main(int argc, char *argv[]) 
{
  Pegasus::IncrementTotal()
}

// After compilation
int main(int argc, char *argv[]) 
{
  ++Pegasus::total;
}
</code></pre>The consequence of this means that the function itself is never actually instantiated. In fact the function might as well not exist - you won&rsquo;t be able to call it from a DLL because the function was simply embedded everywhere that it was used, kind of like a fancy macro. This neatly solves our issue with code in header files, and will be important later on. This also demonstrates how one accesses static variables and functions in a class. Just like before, the C# method of using <code>.</code> no longer works, you must use the Scope Resolution Operator (<code>::</code>) to access static members and functions of a class. This same operator is what allows us to declare the code elsewhere without confusing the compiler.<pre class=language-cpp><code>//Pegasus.cpp

#include &#34;Pegasus.h&#34;

int Pegasus::total = 0;
const char* Pegasus::NAME = &#34;Pegasus&#34;;

Pegasus::Pegasus() : IComparable&lt;Pegasus&gt;(), magic(1), flying(false)
{
  IncrementTotal();
}

Pegasus::~Pegasus()
{
  magic=0;
}

void Pegasus::Fly()
{
  flying=true;
}

void Pegasus::Land()
{
  flying=false;
}

string Pegasus::GetName()
{
  return NAME;
}

int Pegasus::CompareTo(Pegasus other)
{
  return 0;
}
</code></pre>This looks similar to what our C# class looked like, except the functions aren&rsquo;t in the class anymore. <code>Pegasus::</code> tells the compiler what class the function you are defining belongs in, which allows it to assign the class function prototype to the correct implementation, just like it did with normal functions before. Notice that <code>static</code> is not used when defining <code>GetName()</code> - All function decorations (<code>inline</code>, <code>static</code>, <code>virtual</code>, <code>explicit</code>, etc.) are <strong>only allowed on the function prototype</strong>. Note that all these rules apply to static variable initialization as well; both <code>total</code> and <code>NAME</code> are resolved using <code>Pegasus::</code> and <strong>don&rsquo;t</strong> have the <code>static</code> decorator, only their type. Even though we&rsquo;re using <code>const char*</code> instead of <code>string</code>, you can still initialize a constant value using <code>= "string"</code>.</p><p>The biggest difference here is in the constructor. In C#, the only things you bother with in the constructor after the colon is either initializing a subclass or calling another constructor. In C++, you can initialize any subclasses you have along with any variables you have, including passing arguments to whatever constructors your variables might have. Most notably is the ability to initialize constant values, which means you can have a constant integer that is set to a value passed through the constructor, or based off a function call from somewhere else. Unfortunately, C++ traditionally does not allow initializing any variables in any sub-classes, nor does it allow calling any of your own constructors. C++0x <a href=http://en.wikipedia.org/wiki/C%2B%2B0x#Object_construction_improvement>partially resolves this problem</a>, but it is not fully implemented in VC++ or other modern compilers. This blow, however, is mitigated by default arguments in functions (and by extension, constructors), which allows you to do more with fewer functions.</p><p>The order in which variables are constructed is occasionally important if there is an inter-dependency between them. While having such inter-dependencies are generally considered a bad idea, they are sometimes unavoidable, and you can take advantage of a compiler&rsquo;s default behavior of initializing the values in a left to right order. While this behavior isn&rsquo;t technically guaranteed, it is sufficiently reliable for you to take use of it in the occasional exceptional case, but always double-check that the compiler hasn&rsquo;t done crazy optimization in the release version (usually, though, this will just blow the entire program up, so it&rsquo;s pretty obvious).</p><p>Now, C# has another datatype, the <code>struct</code>. This is a limited datatype that cannot have a constructor and is restricted to value-types. It is also passed by-value through functions by default, unlike classes. This is very similar to how structs behaved in C, but have no relation to C++&rsquo;s <code>struct</code> type. In C++, a <code>struct</code> is <em>completely identical</em> to a <code>class</code> in every way, save for one minor detail: all members of a <code>class</code> are <code>private</code> by default, while all members of a <code>struct</code> are <code>public</code> by default. That&rsquo;s it. You can take <em>any</em> <code>class</code> and replace it with <code>struct</code> and the only thing that will change is the default access modifier.</p><p>Even though there is no direct analogue to C#&rsquo;s <code>struct</code>, there is an implicit equivalent. If a <code>class</code> or <code>struct</code> (C++ really doesn&rsquo;t care) meets the requirements of a traditional C <code>struct</code> (no constructor, only basic data types), then it&rsquo;s treated as Plain Old Data, and you are then allowed to skip the constructor and initialize its contents using the special bracket initialization that was <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-2-pointers/#struct-init>touched on before</a>. Yes, you can initialize constant variables using that syntax too.</p><p>One thing I&rsquo;ve skipped over is the <code>virtual</code> code decorator in the C++ prototype of <code>Pegasus</code>, which is not actually necessary, because the function is already attempting to override another virtual function declared in <code>IComparable</code>, which implicitly makes it virtual. However, in C#, <code>IComparable</code> is implemented as an <code>interface</code>, which is not present in C++. Of course, if you really think about it, an <code>interface</code> is kind of like a normal class, just with all <code>abstract</code> methods (ignore the inheritance issues with this for now). So, we could rewrite the C# implementation of <code>IComparable</code> as a class with abstract methods:<pre class=language-csharp><code>public class IComparable&lt;T&gt;
{
  public abstract int CompareTo(T other);
}
</code></pre>As it turns out, this has a direct C++ analogue:<br><pre class=language-csharp><code>template&lt;class T&gt;
class IComparable
{
public:
  virtual int CompareTo(T other)=0;
}
</code></pre>This <code>virtual</code> function, instead of being implemented, has an <code>=0</code> on the end of it. That makes the function <em>pure virtual</em>, which is just another way of saying <code>abstract</code>. So the C++ version of <code>abstract</code> is a pure virtual function, and a C++ version of interfaces is just a class made entirely out of pure virtual functions. Just as C# prevents you from instantiating an <code>abstract class</code> or <code>interface</code>, C++ considers any class that either declares or inherits pure virtual functions without giving them code as an <code>abstract class</code> that cannot be instantiated. Unfortunately C++ does not have anything like <code>sealed</code>, <code>override</code>, etc., so you are on your own there. Keep in mind that <code>public IComparable&lt;T></code> could easily be replaced with <code>protected</code> or <code>private</code> for more control.</p><p>The reason C# has interfaces at all is because C# only allows you to inherit a single class, regardless of whether or not its abstract. If its got code, you can only inherit it once. Interfaces, however, have no code, and so C# lets you pile them on like candy. This isn&rsquo;t done in C++, because C++ supports multiple inheritance. In C++ you can have any class inherit any other class, no matter what, but you can only instantiate a class if it provides implementations for all pure virtual functions somewhere along its inheritance line. Unfortunately, there are a lot of caveats about multiple inheritance, the most notorious being <a href=http://en.wikipedia.org/wiki/Diamond_problem>the Diamond Problem</a>.</p><p>Let&rsquo;s say you have a graphics engine that has an <code>Image</code> class, and that image class inherits from an <code>abstract class</code> that holds its position. Obviously, any image on the screen is going to have a position. Then, let&rsquo;s take a physics engine, with a basic object that also inherits from an abstract class that holds its position. Obviously any physics object must have a position. So, what happens when you have a game object that is both an image and a physics object? Since the image and the physics object are in fact the same thing, both of them must have the same position at all times, but both inherit the abstract class storing position separately, resulting in two positions. Which one is the right position? When you call SetPosition, which position are you talking about?</p><p>Virtual inheritance was introduced as an attempt to solve this problem. It works by creating a single instance of a derived class for the entire inheritance change, such that both the physics object and the image share the same position, as they are supposed to. Unfortunately, it can&rsquo;t resolve all the ambiguities, and it introduces a whole truckload of new problems. It has a nasty habit of being unable to resolve its own virtual functions properly and introducing all sorts of horrible weirdness. Most incredibly bizarre is a virtually inherited class&rsquo;s constructor - it must be initialized in the last class in the inheritance chain, and is one of the first classes to get its constructor called, regardless of where it might be in the hierarchy. It&rsquo;s destructor order is equally as bizarre. Virtual inheritance is sometimes useful for certain small utility classes that must be shared through a wide variety of situations, like a flag class. As a rule of thumb, you should only use virtual inheritance in a class that either relies on the default constructor or only offers a constructor that takes no arguments, and has no superclasses. This allows you to just slap the <code>virtual</code> keyword on and forget about all the wonky constructor details.<pre class=language-cpp><code>class Pegasus : virtual IComparable&lt;Pegasus&gt;</code></pre>If you ever think you need to use virtual inheritance on something more complicated, your code is broken and you need to rethink your program&rsquo;s architecture (and the compiler probably won&rsquo;t be able to do it properly anyway). On a side-note, the constructors for any given object are called from the top down. That is, when your object&rsquo;s constructor is called, it immediately calls all the constructors for all it&rsquo;s superclasses, usually before even doing any variable initialization, and then those object constructors immediately call all <em>their</em> superclass constructors, and so on until the first line of code executed in your program is whatever the topmost class was. This then filters down until control is finally returned to your original constructor, such that any constructor code is only executed <em>after</em> all of its base classes have been constructed. The exact reverse happens for destructors, with the lowest class destructor being executed first, and after its finished, the destructors for all its base classes are called, such that a class destructor is always called while all of its base classes still exist.</p><p>Hopefully you are familiar with C#&rsquo;s <code>enum</code> keyword. While it used to be far more limited, it has now been extended to such a degree it is <em>identical</em> to C++, even the syntax is the same. The only difference between the two is that the C++ version can&rsquo;t be declared <code>public</code>, <code>protected</code> or <code>private</code> and needs to have a semicolon on the end (like everything else). Like in C#, enums, classes and structs can be embedded in classes, except in C++ they can also be embedded in structs (because structs are basically classes with a different name). Also, C++ allows you to declare an <code>enum</code>/<code>class</code>/etc. and a variable inside the class at the same time using the following syntax:<pre class=language-cpp><code>class Pegasus
{
  enum Count { Uno=2, Dos, Tres, Quatro, Cinco } variable;
  enum { Uno=2, Dos, Tres, Quatro, Cinco } var2; //When used to immediately declare a variable, enums can be anonymous
}

//Same as above
class Pegasus
{
  enum Count { Uno=2, Dos, Tres, Quatro, Cinco }; //cannot be anonymous

  Count variable;
  Count var2;
}
</code></pre>Unions are exclusive to C++, and are a special kind of data structure where each element occupies the same address. To understand what that means, let&rsquo;s look at an example:<pre class=language-cpp><code>union //Unions are usually anonymous, but can be named
{
  struct { // The anonymity of this struct exposes its internal members.
    __int32 low;
    __int32 high;
  }
  __int64 full;
}
</code></pre>union<br><code>__int32</code> and <code>__int64</code> are simply explicitly declaring 32-bit and 64-bit integers. This <code>union</code> allows us to either set an entire 64-bit integer, or to only set its low or high portion. This happens because the data structure is laid out as follows:</p><a href=http://img705.imageshack.us/img705/2389/p3union1.png target=_blank><img src=http://img705.imageshack.us/img705/2389/p3union1.png alt="Integer Union Layout"></a><p>Both <code>low</code> and <code>full</code> are mapped to the <em>exact same place in memory</em>. The only difference is that <code>low</code> is a 32-bit integer, so when you set that to 0, only the first four bytes are set to zero. <code>high</code> is pointing to a location in memory that is exactly 4 bytes in front of <code>low</code> and <code>full</code>. So, if <code>low</code> and <code>full</code> were located at <code>0x000F810</code>, <code>high</code> would be located at <code>0x000F814</code>. Setting <code>high</code> to zero sets the last four bytes to zero, but doesn&rsquo;t touch the first four. Consequently, if you set <code>high</code> to 0, reading <code>full</code> would always return the same value as <code>low</code>, since it would essentially be constrained to a 32-bit integer. Unions, however, do not have to have matching memory layouts:<pre class=language-cpp><code>union //Unions are usually anonymous, but can be named
{
  char pink[5]
  __int32 fluffy;
  __int64 unicorns;
}
</code></pre>The layout of this union is:</p><a href=http://img851.imageshack.us/img851/1847/p3union2.png target=_blank><img src=http://img851.imageshack.us/img851/1847/p3union2.png alt="Jagged Union Layout"></a><p>Any unused space is simply ignored. This same rule would apply for any structs being used to group data. The size of the <code>union</code> is simply the size of its largest member. Setting all 5 elements of <code>pink</code> here would result in <code>fluffy</code> being equal to zero, and only the last 24-bits (or last 3 bytes) of <code>unicorns</code> be untouched. Likewise, setting <code>fluffy</code> to zero would zero out the first 4 elements in <code>pink</code> (indexes 0-3), leaving the 5<sup>th</sup> untouched. These unions are often used in performance critical areas where a single function must be able to recieve many kinds of data, but will only ever recieve a single group of data at a time, and so it would be more efficient to map all the possible memory configurations to a single data structure that is large enough to hold the largest group. Here is a real world example:<pre class=language-cpp><code>struct __declspec(dllexport) cGUIEvent
{
  cGUIEvent() { memset(this,0,sizeof(cGUIEvent)); }
  cGUIEvent(unsigned char _evt, const cVecT&lt;int&gt;* mousecoords, unsigned char _button, bool _pressed) : evt(_evt), subevt(0), mousecoords(mousecoords), button(_button), pressed(_pressed) {}
  cGUIEvent(unsigned char _evt, const cVecT&lt;int&gt;* mousecoords, unsigned short _scrolldelta) : evt(_evt), subevt(0), mousecoords(mousecoords), scrolldelta(_scrolldelta) {}
  union
 {
  struct
  {
   unsigned char evt;
   unsigned char subevt;
  };
  unsigned short realevt;
 };

  union
  {
    struct { const cVecT&lt;int&gt;* mousecoords; unsigned char button; bool pressed; };
    struct { const cVecT&lt;int&gt;* mousecoords; short scrolldelta; };
    struct { //the three ctrl/shift/alt bools (plus a held bool) here are compressed into a single byte
      bool down;
      unsigned char keycode; //only used by KEYDOWN/KEYUP
      char ascii; //Only used by KEYCHAR
      wchar_t unicode; //Only used by KEYCHAR
      char sigkeys;
    };
    struct { float value; short joyaxis; }; //JOYAXIS
    struct { bool down; short joybutton; }; //JOYBUTTON*
  };
};
</code></pre>Here, the GUI event is mapped to memory according to the needs of the event that it is representing, without the need for complex inheritance or wasteful memory usage. Unions are indispensable in such scenarios, and as a result are very common in any sort of message handling system.</p><p>One strange decorator that has gone unexplained in the above example is the <code>__declspec(dllexport)</code> class decorator. When creating a windows DLL, if you want anything to be usable by something inheriting the DLL, you have to export it. In VC++, this can be done with a <a href="http://msdn.microsoft.com/en-us/library/28d6s79h(v=vs.80).aspx">module definition file (.def)</a>, which is useful if you&rsquo;ll be using GetProcAddress manually, but if you are explicitly linking to a DLL, <code>__declspec(dllexport)</code> automatically exports the function for you when placed on a function. When placed on a class, it automatically exports the entire class. However, for anyone to utilize it, they have to have the header file. This arises to DLLs being distributed as DLLs, linker libraries (.lib), and sets of header files, usually in an &ldquo;include&rdquo; directory. In certain cases, only some portions of your DLL will be accessible to the outside, and so you&rsquo;ll want two collections of header files - outside header files and internal ones that no one needs to know about. Consequently, utilizing a large number of C++ DLLs usually involves substantial organization of a whole lot of header files.</p><p>Due to the compiler-specific nature of DLL management, they will be covered in <a href=#>Part 6</a>. For now, its on to operator overloading, copy semantics and move semantics!</p><p><a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-4-operator-overload/>Part 4: Operator Overload</a></p><iframe width=640 height=390 src="http://www.youtube-nocookie.com/embed/eWM2joNb9NE?rel=0&hd=1" frameborder=0 allowfullscreen></iframe></div><hr><time itemprop=datePublished pubdate=pubdate datetime=2011-09-09T18:07:00+00:00><i class="fa-regular fa-clock fa-fw"></i>&nbsp;Published on <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-3-classes-and/>September 9, 2011 at 6:07pm</a></time><aside><i class="fa-regular fa-comments fa-fw"></i>&nbsp;<a href=/blog/c-to-c-tutorial-part-3-classes-and/#commento> comments</a></aside><aside><i class="fa-regular fa-share-square fa-fw"></i>&nbsp;share:<ul><li><a href="javascript:window.open('https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ferikmcclure.com%2fblog%2fc-to-c-tutorial-part-3-classes-and%2f','popup','width=600,height=400');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" d="M16.75 9H13.5V7a1 1 0 011-1h2V3H14a4 4 0 00-4 4V9H8v3h2v9h3.5V12H16z"/></svg></a><li><a href="javascript:window.open('https://twitter.com/intent/tweet?text=C%23%20to%20C%2b%2b%20Tutorial%20-%20Part%203%3a%20Classes%20and%20Structs%20and%20Inheritance%20%28OH%20MY%21%29&url=https%3a%2f%2ferikmcclure.com%2fblog%2fc-to-c-tutorial-part-3-classes-and%2f','popup','width=600,height=256');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" opacity="0" d="M0 0h24v24H0z"/><path class="st0" d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572.0-4.658 2.086-4.658 4.66.0.364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342.0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3.0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376.0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57.0 13.255-7.098 13.255-13.254.0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg></a></li><li><a href="javascript:window.open('https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2ferikmcclure.com%2fblog%2fc-to-c-tutorial-part-3-classes-and%2f','popup','width=700,height=380');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><rect class="st0" height="11" width="4" x="3" y="9"/><circle class="st0" cx="5" cy="5" r="2"/><path class="st0" d="M16.5 8.25A4.47251 4.47251.0 0013 9.95343V9H9V20h4V13a2 2 0 014 0v7h4V12.75a4.5 4.5.0 00-4.5-4.5z"/></svg></a></li></ul></aside></article><article><h4><a href=/blog/problem-of-vsync/>The Problem of Vsync</a></h4><hr><div class=padding><p>If you were to write directly to the screen when drawing a bouncing circle, you would run into some problems. Because you don&rsquo;t do any buffering, your user might end up with a quarter circle drawn for a frame. This can be solved through Double Buffering, which means you draw the circle on to a backbuffer, then &ldquo;flip&rdquo; (or copy) the completed image on to the screen. This means you will only ever send a completely drawn scene to the monitor, but you will still have tearing issues. These are caused by trying to update the monitor outside of its refresh rate, meaning you will have only finished drawing half of your new scene over the old scene in the monitor&rsquo;s video buffer when it updates itself, resulting in half the scanlines on the screen having the new scene and half still having the old scene, which gives the impression of tearing.</p><p>This can be solved with Vsync, which only flips the backbuffer right before the screen refreshes, effectively locking your frames per second to the refresh rate (usually 60 Hz or 60 FPS). Unfortunately, Vsync with double buffering is implemented by simply locking up the entire program until the next refresh cycle. In DirectX, this problem is made even worse because the API locks up the program with a 100% CPU polling thread, sucking up an entire CPU core just waiting for the screen to enter a refresh cycle, often for almost 13 milliseconds. So your program sucks up an entire CPU core when 90% of the CPU isn&rsquo;t actually doing anything but waiting around for the monitor.</p><p>This waiting introduces another issue - Input lag. By definition any input given during the current frame can only come up when the next frame is displayed. However, if you are using vsync and double buffering, the current frame on the screen was the LAST frame, and the CPU is now twiddling its thumbs until the monitor is ready to display the frame that you have <em>already finished rendering</em>. Because you already rendered the frame, the input now has to wait until the end of the frame being displayed on the screen, at which point the frame that was already rendered is flipped on to the screen and your program finally realizes that the mouse moved. It now renders yet another frame taking into account this movement, but because of Vsync that frame is blocked until the next refresh cycle. This means, if you were to press a key just as a frame was put up on the monitor, you would have <em>two full frames of input lag</em>, which at 60 FPS is <strong>33 ms</strong>. I can ping a server 20 miles away with a ping of 21 ms. You might as well be in the next city with that much latency.</p><p>There is a solution to this - Triple Buffering. The idea is a standard flip mechanism commonly used in dual-thread lockless synchronization scenarios. With two backbuffers, the application can write to one and once its finished, tell the API and it will mark it for flipping to the front-buffer. Then the application starts drawing on the second, after waiting for any flipping operation to finish, and once its done, marks that for flipping to the front-buffer and starts drawing on the first again. This way, the application can draw 2000 frames a second, but only 60 of those frames actually get flipped on to the monitor using what is essentially a lockless flipping mechanism. Because the application is now effectively rendering 2000 frames per second, there is no more input lag. Problem Solved.</p><p>Except not, because DirectX implements Triple Buffering in the most useless manner possible. DirectX just treats the extra buffer as a chain, and rotates through the buffers as necessary. The only advantage this has is that it avoids waiting for the backbuffer copy operation to finish before writing again, which is completely useless in an era where said copy operation would have to be measured in microseconds. Instead, it simply ensures that vsync blocks the program, which doesn&rsquo;t solve the input issue at all.</p><p>However, there is a flag, <code>D3DPRESENT_DONOTWAIT</code>, that forces vsync to simply return an error if the refresh cycle isn&rsquo;t available. This would allow us to implement a hack resembling what triple buffering should be like by simply rolling our own polling loop and re-rendering things in the background on the second backbuffer. Problem solved!</p><p><strong>Except not</strong>. It turns out the Nvidia and Intel don&rsquo;t bother implementing this flag, forcing Vsync to block no matter what you do, and to make matters worse, this feature doesn&rsquo;t have an entry in D3DCAPS9, meaning the DirectX9 API just assumes that it exists, and <em>there is no way to check if it is supported</em>. Of course, don&rsquo;t complain about this to anyone, because of the 50% of people who asked about this who weren&rsquo;t simply ignored, almost all of them were immediately accused of bad profiling, and that the <code>Present()</code> function couldn&rsquo;t possibly be blocking with the flag on. I question the wisdom of people who ignore the fact that the code executed its main loop 2000 times with vsync off and 60 times with it on and somehow come to the conclusion that <code>Present()</code> isn&rsquo;t blocking the code.</p><p>Either way, we&rsquo;re kind of screwed now. Absolutely no feature in DirectX actually does what its supposed to do, so there doesn&rsquo;t seem to be a way past this input lag.</p><p>There is, however, another option. Clever developers would note that to get around vsync&rsquo;s tendency to eat up CPU cycles like a pig, one could introduce a <code>Sleep()</code> call. So long as you left enough time to render the frame, you could recover a large portion of the wasted CPU. A reliable way of doing this is figuring out how long the last frame took to render, then subtracting that from the FPS you want to enforce and sleep in the remaining time. By enforcing an FPS of something like 80, you give yourself a bit of breathing room, but end up finishing rendering the frame around the same time it would have been presented anyway.</p><p>By timing your updates very carefully, you can execute a <code>Sleep()</code> call, <em>then</em> update all the inputs, <em>then</em> render the scene. This allows you to cut down the additional lag time by nearly 50% in ideal conditions, almost <em>completely eliminating</em> excess input lag. Unfortunately, if your game is already rendering at or below 100 FPS, it takes you 10 milliseconds to render a frame, allowing you only 2.5 milliseconds of extra time to look for input, which is of limited usefulness. This illustrates why Intel and Nvidia are unlikely to care about <code>D3DPRESENT_DONOTWAIT</code> - modern games will never render fast enough for substantial input lag reduction.</p><p>Remember when implementing the Yield that the amount of time it takes to render the frame should be the time difference between the two render calls, minus the amount of time spent sleeping, minus the amount of time <code>Present()</code> was blocking.</p></div><hr><time itemprop=datePublished pubdate=pubdate datetime=2011-09-05T04:43:00+00:00><i class="fa-regular fa-clock fa-fw"></i>&nbsp;Published on <a href=https://erikmcclure.com/blog/problem-of-vsync/>September 5, 2011 at 4:43am</a></time><aside><i class="fa-regular fa-comments fa-fw"></i>&nbsp;<a href=/blog/problem-of-vsync/#commento>5 comments</a></aside><aside><i class="fa-regular fa-share-square fa-fw"></i>&nbsp;share:<ul><li><a href="javascript:window.open('https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ferikmcclure.com%2fblog%2fproblem-of-vsync%2f','popup','width=600,height=400');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" d="M16.75 9H13.5V7a1 1 0 011-1h2V3H14a4 4 0 00-4 4V9H8v3h2v9h3.5V12H16z"/></svg></a><li><a href="javascript:window.open('https://twitter.com/intent/tweet?text=The%20Problem%20of%20Vsync&url=https%3a%2f%2ferikmcclure.com%2fblog%2fproblem-of-vsync%2f','popup','width=600,height=256');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" opacity="0" d="M0 0h24v24H0z"/><path class="st0" d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572.0-4.658 2.086-4.658 4.66.0.364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342.0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3.0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376.0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57.0 13.255-7.098 13.255-13.254.0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg></a></li><li><a href="javascript:window.open('https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2ferikmcclure.com%2fblog%2fproblem-of-vsync%2f','popup','width=700,height=380');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><rect class="st0" height="11" width="4" x="3" y="9"/><circle class="st0" cx="5" cy="5" r="2"/><path class="st0" d="M16.5 8.25A4.47251 4.47251.0 0013 9.95343V9H9V20h4V13a2 2 0 014 0v7h4V12.75a4.5 4.5.0 00-4.5-4.5z"/></svg></a></li></ul></aside></article><article><h4><a href=/blog/c-to-c-tutorial-part-2-pointers/>C# to C++ Tutorial - Part 2: Pointers Everywhere!</a></h4><hr><div class=padding><p>[ <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-1-basics-of-syntax/>1</a> · <strong>2</strong> · <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-3-classes-and/>3</a> · <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-4-operator-overload/>4</a> <span style=color:#aaa>· 5 · 6 · 7</span> ]</p><p>We still have a lot of ground to cover on pointers, but before we do, we need to address certain conceptual frameworks missing from C# that one must be intimately familiar with when moving to C++.</p><p>Specifically, in C# you mostly work with the <strong>Heap</strong>. The heap is not difficult to understand - its a giant lump of memory that you take chunks out of to allocate space for your classes. Anything using the <code>new</code> keyword is allocated on the heap, which ends up being almost everything in a C# program. However, the heap isn&rsquo;t the only source of memory - there is also the <strong>Stack</strong>. The Stack is best described as what your program lives inside of. I&rsquo;ve said before that everything takes up memory, and yes, that includes your program. The thing is that the Heap is inherently dynamic, while the Stack is inherently <em>fixed</em>. Both can be re-purposed to do the opposite, but trying to get the Stack to do dynamic allocation is extremely dangerous and is almost guaranteed to open up a mile-wide security hole.</p><p>I&rsquo;m going to assume that a C# programmer knows what a <a href=http://en.wikipedia.org/wiki/Stack_(data_structure)>stack</a> is. All you need to understand is that absolutely every single piece of data that isn&rsquo;t allocated on the heap is pushed or popped off your program&rsquo;s stack. That&rsquo;s why most debuggers have a &ldquo;stack&rdquo; of functions that you can go up and down. Understanding the stack in terms of how many functions you&rsquo;re inside of is ok, but in reality, there are also variables declared on the stack, including every single parameter passed to a function. It is important that you understand how variable scope works so you can take advantage of declaring things on the stack, and know when your stack variables will simply vanish into nothingness. This is where <code>{</code> and <code>}</code> come in.</p><p><pre class=language-cpp><code>int main(int argc, char *argv[])
{
  int bunny = 1;
  
  {
    int carrot=3;
    int lettuce=8;
    bunny = 2; // Legal
  }

  //carrot=2; //Compiler error: carrot does not exist
  int carrot = 3; //Legal, since the other carrot no longer exists
  
  {
    int lettuce = 0;

    { 
       //int carrot = 1; //Compiler error: carrot already defined
       int grass = 9;
       
       bunny = grass; //Still legal
       bunny = carrot; // Also legal
    }
    
    //bunny = grass; //Illegal
    bunny = lettuce; //Legal
  }
  
  //bunny = lettuce; //Illegal
}
</code></pre><code>{</code> and <code>}</code> define <strong>scope</strong>. Anything declared inside of them ceases to exist outside, but is still accessible to any additional layers of scope declared inside of them. This is a way to see your program&rsquo;s stack in action. When <code>bunny</code> is declared, its pushed on to the stack. Then we enter our first scope area, where we push <code>carrot</code> and <code>lettuce</code> on to the stack and set <code>bunny</code> to 2, which is legal because <code>bunny</code> is still on the stack. When the scope is then closed, however, anything declared inside the scope is popped from the stack <em>in the exact opposite order it was pushed on</em>. Unfortunately, compiler optimization might change that order behind the scenes, so <strong>don&rsquo;t rely on it</strong>, but it should be fairly consistent in debug builds. First <code>lettuce</code> is de-allocated (and its destructor called, if it has one), then <code>carrot</code> is de-allocated. Consequently, trying to set <code>carrot</code> to 2 outside of the scope will result in a compiler error, because it doesn&rsquo;t exist anymore. This means we can now declare an entirely new integer variable that is also called <code>carrot</code>, without causing an error. If we visualize this as a stack, that means <code>carrot</code> is now directly above <code>bunny</code>. As we enter a new scope area, <code>lettuce</code> is then put on top of <code>carrot</code>, and then <code>grass</code> is put on top of <code>lettuce</code>. We can still assign either <code>lettuce</code> or <code>carrot</code> to <code>bunny</code>, since they are all on the stack, but once we leave this inner scope, <code>grass</code> is popped off the stack and no longer exists, so any attempt to use it causes an error. <code>lettuce</code>, however, is still there, so we can assign <code>lettuce</code> to <code>bunny</code> before the scope closes, which pops <code>lettuce</code> off the stack.</p><p>Now the only things on the stack are <code>bunny</code> and <code>carrot</code>, in that order (if the compiler hasn&rsquo;t moved things around). We are about to leave the function, and the function is also surrounded by <code>{</code> and <code>}</code>. This is because a function is, itself, a scope, so that means all variables declared inside of that scope are also destroyed in the order they were declared in. First <code>carrot</code> is destroyed, then <code>bunny</code> is destroyed, and then the function&rsquo;s parameters <code>argc</code> and <code>argv</code> are destroyed (however the compiler can push those on to the stack in whatever order it wants, so we don&rsquo;t know the order they get popped off), until finally the <em>function itself</em> is popped off the stack, which returns program flow to whatever called it. In this case, the function was <code>main</code>, so program flow is returned to the parent operating system, which does cleanup and terminates the process.</p><p>You can declare anything that has a size determined at compile time on the stack. This means if you have an array that has a constant size, you can declare it on the stack:</p><p><pre class=language-cpp><code>int array[5]; //Array elements are not initialized and therefore are undefined!
int array[5] = {0,0,0,0,0}; //Elements all initialized to 0
//int array[5] = {0}; // Compiler error - your initialization must match the array size
</code></pre>You can also let the compiler infer the size of the array:</p><p><pre class=language-cpp><code>int array[] = {1,2,3,4}; //Declares an array of 4 ints on the stack initialized to 1,2,3,4
</code></pre>Not only that, but you can declare class instances and other objects on the stack.</p><p><pre class=language-cpp><code>Class instance(arg1, arg2); //Calls a constructor with 2 arguments
Class instance; //Used if there are no arguments for the constructor
//Class instance(); //Causes a compiler error! The compiler will think its a function.
</code></pre><a id=struct-init>In fact</a>, if you have a very simple data structure that uses only default constructors, you can use a shortcut for initializing its members. I haven&rsquo;t gone over classes and structs in C++ yet (See <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-3-classes-and/>Part 3</a>), but here is the syntax anyway:</p><p><pre class=language-cpp><code>struct Simple
{
  int a;
  int b;
  const char* str;
};

Simple instance = { 4, 5, &#34;Sparkles&#34; };
//instance.a is now 4
//instance.b is now 5
//instance.str is now &#34;Sparkles&#34;
</code></pre>All of these declare variables on the stack. C# actually does this with trivial datatypes like <code>int</code> and <code>double</code> that don&rsquo;t require a <code>new</code> statement to allocate, but otherwise forces you to use the Heap so its garbage collector can do the work.</p><p>Wait a minute, stack variables automatically destroy themselves when they go out-of-scope, but how do you delete variables allocated from the Heap? In C#, you didn&rsquo;t need to worry about this because of Garbage Collection, which everyone likes because it reduces memory leaks (but even I have still managed to cause a memory leak in C#). In C++, you must explicitly delete all your variables declared with the <code>new</code> keyword, and you must keep in mind which variables were declared as arrays and which ones weren&rsquo;t. In both C# and C++, there are two uses of the <code>new</code> keyword - instantiating a single object, and instantiating an array. In C++, there are also two uses of the <code>delete</code> keyword - deleting a single object and deleting an array. <strong>You cannot mix up <code>delete</code> statements!</strong></p><p><pre class=language-cpp><code>int* Fluffershy = new int();
int* ponies = new int[10];

delete Fluffershy; // Correct
//delete ponies; // WRONG, we should be using delete [] for ponies
delete [] ponies; // Just like this
//delete [] Fluffershy; // WRONG, we can&#39;t use delete [] on Fluffershy because we didn&#39;t
                        // allocate it as an array.

int* one = new int[1];

//delete one; // WRONG, just because an array only has one element doesn&#39;t mean you can
              // use the normal delete!
delete [] one; // You still must use delete [] because you used new [] to allocate it.
</code></pre>As you can see, it is much easier to deal with stack allocations, because they are automatically deallocated, even when the function terminates unexpectedly. <code>[std::auto_ptr](http://www.cplusplus.com/reference/std/memory/auto_ptr/)</code> takes advantage of this by taking ownership of a pointer and automatically deleting it when it is destroyed, so you can allocate the <code>auto_ptr</code> on the stack and benefit from the automatic destruction. However, in <code>C++0x</code>, this has been superseded by <code>[std::unique_ptr](http://msdn.microsoft.com/en-us/library/ee410601.aspx)</code>, which operates in a similar manner but uses some complex move semantics introduced in the new standard. I won&rsquo;t go into detail about how to use these here as its out of the scope of this tutorial. Har har har.</p><p>For those of you who like throwing exceptions, I should point out common causes of memory leaks. The most common is obviously just flat out forgetting to delete something, which is usually easily fixed. However, consider the following scenario:</p><p><pre class=language-cpp><code>void Kenny()
{
  int* kenny = new int();
  throw &#34;BLARG&#34;;
  delete kenny; // Even if the above exception is caught, this line of code is never reached.
}

int main(int argc, char* argv[])
{
  try {
  Kenny();
  } catch(char * str) { 
    //Gotta catch&#39;em all.
  }
  return 0; //We&#39;re leaking Kenny! o.O
}
</code></pre>Even this is fairly common:</p><p><pre class=language-cpp><code>int main(int argc, char* argv[])
{
  int* kitty = new int();

  *kitty=rand();
  if(*kitty==0)
    return 0; //LEAK
  
  delete kitty;
  return 0;
}
</code></pre>These situations <em>seem</em> obvious, but they will happen to you once the code becomes enormous. This is one reason you have to be careful when inside functions that are very large, because losing track of <code>if</code> statements may result in you forgetting what to delete. A good rule of thumb is to make sure you delete everything whenever you have a return statement. However, the opposite can also happen. If you are too vigilant about deleting everything, you might delete something you never allocated, which is just as bad:</p><p><pre class=language-cpp><code>int main(int argc, char* argv[])
{
  int* rarity = new int();
  int* spike;

  if(rarity==NULL)
  {
    spike=new int();
  }
  else
  {
    delete rarity;
    delete spike; // Suddenly, in an alternate dimension, earth ceased to exist
    return 0;
  }
  
  delete rarity; // Since this only happens if the allocation failed and returned a NULL
                 // pointer, this will also blow up.
  delete spike;
  return 0;
}
</code></pre>Clearly, one must be careful when dealing with allocating and destroying memory in C++. Its usually best to encapsulate as much as possible in classes that automate such things. But wait, what about that <code>NULL</code> pointer up there? Now that we&rsquo;re familiar with memory management, we&rsquo;re going to dig into pointers again, starting with the <code>NULL</code> pointer.</p><p>Since a pointer points to a piece of memory that&rsquo;s somewhere between 0 and 4294967295, what happens if its pointing at 0? Any pointer to memory location 0 <strong>is always invalid</strong>. All you need to know is that the operating system does some magic voodoo to ensure that any attempted access of memory location 0 will always throw an error, no matter what. 1, 2, 3, and any other double or single digit low numbers are also always invalid. <code>0xfdfdfdfd</code> is what the VC++ debugger sets uninitialized memory to, so that pointer location is also always invalid. A pointer set to 0 is called a <strong>Null Pointer</strong>, and is usually used to signify that a pointer is empty. Consequently if an allocation function fails, it tends to return a null pointer. Null pointers are returned when the operation failed and a valid pointer cannot be returned. Consequently, you may see this:</p><p><pre class=language-cpp><code>int main(int argc, char* argv[])
{
  int* blink = new int();
  if(blink!=0) delete blink;
  blink=0;
  return 0;
}
</code></pre>This is known as a <strong>safe deletion</strong>. It ensures that you only delete a pointer if it is valid, and once you delete the pointer you set the pointer to 0 to signify that it is invalid. Note that <code>NULL</code> is defined as 0 in the standard library, so you could also say <code>blink = NULL</code>.</p><p>Since pointers are just integers, we can do <strong>pointer arithmetic</strong>. What happens if you add 1 to a pointer? If you think of pointers as just integers, one would assume it would simply move the pointer forward a single byte.</p><div class=imgwrap style=max-width:486px><a href=/img/tut2.png target=_blank><img src=/img/tut2.png alt="Moving a Pointer 1 byte" width=100%></a></div><p>This isn&rsquo;t what happens. Adding 1 to a pointer of type <code>integer</code> results in the pointer moving forward 4 bytes.</p><div class=imgwrap style=max-width:486px><a href=/img/tut3.png target=_blank><img src=/img/tut3.png alt="Moving a Pointer 4 bytes" width=100%></a></div><p><strong>Adding or subtracting an integer $i$ from a pointer moves that pointer $i\cdot n$ bytes, where $n$ is the size, in bytes, of the pointer&rsquo;s type</strong>. This results in an interesting parallel - adding or subtracting from a pointer is the same as treating the pointer as an array and accessing it via an index.</p><p><pre class=language-cpp><code>int main(int argc, char* argv[])
{
  int* kitties = new int[14];
  int* a = &amp;kitties[7];
  int* b = kitties+7; //b is now the same as a
  int* c = &amp;a[4];
  int* d = b+4; //d is now the same as c
  int* e = &amp;kitties[11];
  int* f = kitties+11; 
  //c,d,e, and f now all point to the same location
}
</code></pre>So pointer arithmetic is identical to accessing a given index and taking the address. But what happens when you try to add two pointers together? Adding two pointers together is undefined because it tends to produce total nonsense. <em>Subtracting</em> two pointers, however, is defined, provided you subtract a smaller pointer from a larger one. The reason this is allowed is so you can do this:</p><p><pre class=language-cpp><code>int main(int argc, char* argv[])
{
  int* eggplants = new int[14];
  int* a = &amp;eggplants[7];
  int* b = eggplants+10;
  int diff = b-a; // Diff is now equal to 3
  a += (diff*2); // adds 6 to a, making it point to eggplants[13]
  diff = a-b; // diff is again equal to 3
  diff = a-eggplants; //diff is now 13
  ++a; //The increment operator is valid on pointers, and operates the same way a += 1 would
  // So now a points to eggplants[14], which is not a valid location, but this is still
  // where the &#34;end&#34; of the array technically is.
  diff = a-eggplants; // Diff now equals 14, the size of the array
  --b; // Decrement works too
  diff = a-b; // a is pointing to index 14, b is pointing to 9, so 14-9 = 5. Diff is now 5.
  return 0;
}
</code></pre>There is a mistake in the code above, can you spot it? I used a <em>signed</em> <code>integer</code> to store the difference between the two pointers. What if one pointer was above 2147483647 and the other was at 0? The difference would overflow! Had I used an unsigned integer to store the difference, I&rsquo;d have to be really damn sure that the left pointer was larger than the right pointer, or the negative value would <em>also</em> overflow. This complexity is why you have to goad windows into letting your program deal with pointer sizes over 2147483647.</p><p>In addition to arithmetic, one can compare two pointers. We already know we can use <code>==</code> and <code>!=</code>, but we can also use <code>&lt; > &lt;=</code> and <code>>=</code>. While you can get away with comparing two completely unrelated pointers, these comparison operators are usually used in a context like the following:</p><p><pre class=language-cpp><code>int main(int argc, char* argv[])
{
  int* teapots = new int[15];
  int* end = teapots+15;
  for(int* s = teapots; s&lt;end; ++s)
    *s = 0;
  return 0;
}
</code></pre>Here the for loop increments the pointer itself rather than an index, until the pointer reaches the end, at which point it terminates. But, what if you had a pointer that didn&rsquo;t have any type at all? <code>void*</code> is a legal pointer type, that any pointer type can be implicitly converted to. You can also explicitly cast <code>void*</code> to any pointer type you want, which is why you are allowed to explicitly cast any pointer type to another pointer type (<code>int* p; short* q = (short*)p;</code> is entirely legal). Doing so, however, is obviously dangerous. <code>void*</code> has its own problems, namely, how big is it? The answer is, you don&rsquo;t know. <strong>Any attempt to use any kind of pointer arithmetic with a <code>void*</code> pointer will cause a compiler error</strong>. It is most often used when copying generic chunks of memory that only care about size in bytes, and not what is actually contained in the memory, like <code>memcpy()</code>.</p><p><pre class=language-cpp><code>int main(int argc, char* argv[])
{
  int* teapots = new int[15];
  void* p = (void*)teapots;
  p++; // compiler error
  unsigned short* d = (unsigned short*)p;
  d++; // No compiler error, but you end up pointing to half an integer
  d = (unsigned short*)teapots; // Still valid
  return 0;
}
</code></pre>Now that we know all about pointer manipulation, we need to look at pointers to pointers, and to anchor this in a context that actually makes sense, we need to look at how C++ does <strong>multidimensional arrays</strong>. In C#, <a href="http://msdn.microsoft.com/en-us/library/2yd9wwz4(v=vs.71).aspx">multidimensional arrays</a> look like this:</p><p><pre class=language-csharp><code>int[,] table = new int[4,5];
</code></pre>C++ has a different, but fairly reasonable stack-based syntax. When you want to declare a multidimensional array <em>on the heap</em>, however, things start getting <em>weird</em>:</p><p><pre class=language-cpp><code>int unicorns[5][3]; // Well this seems perfectly reasonable, I wonder what-
  int (*cthulu)[50] = new int[10][50]; // OH GOD GET IT AWAY GET IT AWAAAAAY...!
  int c=5;
  int (*cthulu)[50] = new int[c][50]; // legal
  //int (*cthulu)[] = new int[10][c]; // Not legal. Only the leftmost parameter
                                      // can be variable
  //int (*cthulu)[] = new int[10][50]; // This is also illegal, the compiler is not allowed
                                       // to infer the constant length of the array.
</code></pre>Why isn&rsquo;t the multidimensional array here just an <code>int**</code>? Clearly if <code>int* x</code> is equivalent to <code>int x[]</code>, shouldn&rsquo;t <code>int** x</code> be equivalent to <code>int x[][]</code>? Well, it <em>is</em> - just look at the <code>main()</code> function, its got a multidimensional array in there that can be declared as just <code>char** argv</code>. The problem is that there are two kinds of multidimensional arrays - <strong>square</strong> and <strong>jagged</strong>. While both are accessed in identical ways, how they work is fundamentally different.</p><p>Let&rsquo;s look at how one would go about allocating a 3x5 square array. We can&rsquo;t allocate a 3x5 chunk out of our computer&rsquo;s memory, because memory isn&rsquo;t 2-dimensional, its 1-dimensional. Its just freaking huge line of bytes. Here is how you squeeze a 2-dimensional array into a 1-dimensional line:</p><div class=imgwrap style=max-width:727px><a href=/img/tut4.png target=_blank><img src=/img/tut4.png alt="Allocating a 3x5 array" width=100%></a></div><p>As you can see, we just allocate each row right after the other to create a 15-element array ($5\cdot 3 = 15$). But then, how do we access it? Well, if it has a width of 5, to access another &ldquo;row&rdquo; we&rsquo;d just skip forward by 5. In general, if we have an $n$ by $m$ multidimensional array being represented as a one-dimensional array, the proper index for a coordinate $(x,y)$ is given by: <code>array[x + (y*n)]</code>. This can be extended to 3D and beyond but it gets a little messy. This is all the compiler is really doing with multidimensional array syntax - just automating this for you.</p><p>Now, if this is a <strong>square</strong> array (as evidenced by it being a square in 2D or a cube in 3D), a jagged array is one where each array is a different size, resulting in a &ldquo;jagged&rdquo; appearance:</p><div class=imgwrap style=max-width:320px><a href=/img/tut5.png target=_blank><img src=/img/tut5.png alt="Jagged array visualization" width=100%></a></div><p>We can&rsquo;t possibly allocate this in a single block of memory unless we did a lot of crazy ridiculous stuff that is totally unnecessary. However, given that arrays in C++ are just pointers to a block of memory, what if you had a pointer to a block of memory that was an array of pointers to more blocks of memory?</p><div class=imgwrap style=max-width:400px><a href=/img/tut6.png target=_blank><img src=/img/tut6.png alt="Jagged array pointers" width=100%></a></div><p>Suddenly we have our jagged array that can be accessed just like our previous arrays. It should be pointed out that with this format, each inner-array can be in a totally random chunk of memory, so the last element could be at position 200 and the first at position 5 billion. Consequently, pointer arithmetic only makes sense within each column. Because this is an array of arrays, we declare it by creating an array of pointers. This, however, does <strong>not</strong> initialize the entire array; all we have now is an array of <em>illegal pointers</em>. Since each array could be a different size than the other arrays (this being the entire point of having a jagged array in the first place), the only possible way of initializing these arrays is individually, often by using a <code>for loop</code>. Luckily, the syntax for accessing jagged arrays is the exact same as with square arrays.</p><p><pre class=language-cpp><code>int main(int argc, char* argv[])
{
  int** jagged = new int*[5]; //Creates an array of 5 pointers to integers.
  for(int i = 0; i &lt; 5; ++i)
  {
    jagged[i] = new int[3+i]; //Assigns each pointer to a new array of a unique size
  }
  jagged[4][1]=0; //Now we can assign values directly, or...
  int* second = jagged[2]; //Pull out one column, and
  second[0]=0; //manipulate it as a single array

  // The double-access works because of the order of operations. Since [] is just an
  // operator, it is evaluated from left to right, like any other operator. Here it is
  // again, but with the respective types that each operator resolves to in parenthesis.
  ( (int&amp;) ( (int*&amp;) jagged[4] ) [1] ) = 0;
}
</code></pre>As you can see above, just like we can have pointers to pointers, we can also have references to pointers, since pointers are just another data type. This allows you to re-assign pointer values inside jagged arrays, like so: <code>jagged[2] = (int*)kitty</code>. However, until <code>C++0x</code>, those references didn&rsquo;t have any meaningful data type, so even though the compiler was using <code>int*&</code>, using that in your code will throw a compiler error in older compilers. If you need to make your code work in non-<code>C++0x</code> compilers, you can simply avoid using references to pointers and instead use a pointer to a pointer.<pre class=language-cpp><code>int* bunny;
int* value = new int[5];

int*&amp; bunnyref = bunny; // Throws an error in old compilers
int** pbunny = &amp;bunny; // Will always work
bunnyref = value; // This does the same exact thing as below.
*pbunny = value;

// bunny is now equal to value
</code></pre>This also demonstrates the other use of a pointer-to-pointer data type, allowing you to remotely manipulate a pointer just like a pointer allows you to remotely manipulate an integer or other value type. So obviously you can do pointers to pointers to pointers to pointers to an absurd degree of lunacy, but this is <em>exceedingly rare</em> so you shouldn&rsquo;t need to worry about it. Now you should be strong in the art of pointer-fu, so our next tutorial will finally get into object-oriented techniques in C++ in comparison to C#. <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-3-classes-and/>Part 3: Classes and Structs and Inheritance OH MY!</a></p></div><hr><time itemprop=datePublished pubdate=pubdate datetime=2011-07-21T19:35:00+00:00><i class="fa-regular fa-clock fa-fw"></i>&nbsp;Published on <a href=https://erikmcclure.com/blog/c-to-c-tutorial-part-2-pointers/>July 21, 2011 at 7:35pm</a></time><aside><i class="fa-regular fa-comments fa-fw"></i>&nbsp;<a href=/blog/c-to-c-tutorial-part-2-pointers/#commento>7 comments</a></aside><aside><i class="fa-regular fa-share-square fa-fw"></i>&nbsp;share:<ul><li><a href="javascript:window.open('https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ferikmcclure.com%2fblog%2fc-to-c-tutorial-part-2-pointers%2f','popup','width=600,height=400');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" d="M16.75 9H13.5V7a1 1 0 011-1h2V3H14a4 4 0 00-4 4V9H8v3h2v9h3.5V12H16z"/></svg></a><li><a href="javascript:window.open('https://twitter.com/intent/tweet?text=C%23%20to%20C%2b%2b%20Tutorial%20-%20Part%202%3a%20Pointers%20Everywhere%21&url=https%3a%2f%2ferikmcclure.com%2fblog%2fc-to-c-tutorial-part-2-pointers%2f','popup','width=600,height=256');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><path class="st0" opacity="0" d="M0 0h24v24H0z"/><path class="st0" d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572.0-4.658 2.086-4.658 4.66.0.364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342.0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3.0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376.0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57.0 13.255-7.098 13.255-13.254.0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg></a></li><li><a href="javascript:window.open('https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2ferikmcclure.com%2fblog%2fc-to-c-tutorial-part-2-pointers%2f','popup','width=700,height=380');"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#666}</style><rect class="st0" height="11" width="4" x="3" y="9"/><circle class="st0" cx="5" cy="5" r="2"/><path class="st0" d="M16.5 8.25A4.47251 4.47251.0 0013 9.95343V9H9V20h4V13a2 2 0 014 0v7h4V12.75a4.5 4.5.0 00-4.5-4.5z"/></svg></a></li></ul></aside></article><div class=pager><ul><li><a href=/blog/page/12>Newer</a></li><li style=text-align:center><a href=/blog/>Home</a></li><li style=text-align:right><a href=/blog/page/14>Older</a></li></ul></div></section><section class=archive><article><img src=https://erikmcclure.com/img/avatar.th.png alt=Avatar width=180 height=180><h2>Archive</h2><ol><li><details><summary>2025</summary><ul><li><a href=/blog/do-you-really-think-we-have-gender-in-the-future/>Do You Really Think We'll Have Genders In The Future?</a></li></ul></details></li><li><details><summary>2024</summary><ul><li><a href=/blog/stop-making-me-memorize-borrow-checker/>Stop Making Me Memorize The Borrow Checker</a></li><li><a href=/blog/rust-async-makes-me-want-to-gouge-my-eyes-out/>Rust Async Makes Me Want To Gouge My Eyes Out</a></li><li><a href=/blog/engineers-only-get-paid-something-broken/>Engineers Only Get Paid If Something Is Broken</a></li><li><a href=/blog/measuring-competence-is-epistemic-hell/>Measuring Competence Is Epistemic Hell</a></li><li><a href=/blog/we-could-fix-everything-we-just-dont/>We Could Fix Everything, We Just Don't</a></li></ul></details></li><li><details><summary>2023</summary><ul><li><a href=/blog/people-cant-care-about-everything/>People Can't Care About Everything</a></li><li><a href=/blog/discord-should-remove-usernames/>Discord Should Remove Usernames Entirely</a></li></ul></details></li><li><details><summary>2022</summary><ul><li><a href=/blog/money-is-fake/>Money Is Fake. It's Not Real. It's Made Up.</a></li><li><a href=/blog/we-need-new-motherboards/>We Need New Motherboards Before GPUs Collapse Under Their Own Gravity</a></li></ul></details></li><li><details><summary>2021</summary><ul><li><a href=/blog/cpp-constructors-memory-and-lifetimes/>C++ Constructors, Memory, and Lifetimes</a></li><li><a href=/blog/factorio-is-best-interview-we-have/>Factorio Is The Best Technical Interview We Have</a></li></ul></details></li><li><details><summary>2020</summary><ul><li><a href=/blog/why-you-cant-use-prebuilt-llvm-with-cpp17/>Why You Can't Use Prebuilt LLVM 10.0 with C++17</a></li><li><a href=/blog/pressure-based-anti-spam-for-discord-bots/>Pressure Based Anti-Spam for Discord Bots</a></li></ul></details></li><li><details><summary>2019</summary><ul><li><a href=/blog/name-shadowing-should-be-an-operator/>Name Shadowing Should Be An Operator</a></li><li><a href=/blog/a-rant-on-terra/>A Rant On Terra</a></li><li><a href=/blog/risc-is-fundamentally-unscalable/>RISC Is Fundamentally Unscalable</a></li></ul></details></li><li><details><summary>2018</summary><ul><li><a href=/blog/migrating-to-static-blog/>Migrating To A Static Blog</a></li><li><a href=/blog/how-to-avoid-memorizing-times-tables/>How To Avoid Memorizing Times Tables</a></li></ul></details></li><li><details><summary>2017</summary><ul><li><a href=/blog/ignoring-outliers-creates-racist/>Ignoring Outliers Creates Racist Algorithms</a></li><li><a href=/blog/i-used-to-want-to-work-for-google/>I Used To Want To Work For Google</a></li><li><a href=/blog/integrating-luajit-and-autogenerating-c/>Integrating LuaJIT and Autogenerating C Bindings In Visual Studio</a></li><li><a href=/blog/discord-rise-of-bot-wars/>Discord: Rise Of The Bot Wars</a></li><li><a href=/blog/companies-cant-be-apolitical/>Companies Can't Be Apolitical</a></li><li><a href=/blog/windows-wont-let-my-program-crash/>Windows Won't Let My Program Crash</a></li><li><a href=/blog/directx-is-terrifying/>DirectX Is Terrifying</a></li></ul></details></li><li><details><summary>2016</summary><ul><li><a href=/blog/everyone-does-srgb-wrong-because/>Everyone Does sRGB Wrong Because Everyone Else Does sRGB Wrong</a></li><li><a href=/blog/mathematical-notation-is-awful/>Mathematical Notation Is Awful</a></li></ul></details></li><li><details><summary>2015</summary><ul><li><a href=/blog/i-tried-to-install-linux-and-now-i/>I Tried To Install Linux And Now I Regret Everything</a></li><li><a href=/blog/you-arent-designing-software-for-robots/>We Aren't Designing Software For Robots</a></li><li><a href=/blog/using-data-to-balance-your-game-pony/>Using Data To Balance Your Game: Pony Clicker Analysis</a></li><li><a href=/blog/does-anyone-actually-want-good-software/>Does Anyone Actually Want Good Software?</a></li></ul></details></li><li><details><summary>2014</summary><ul><li><a href=/blog/how-not-to-sell-software/>How Not To Install Software</a></li><li><a href=/blog/can-we-choose-what-we-enjoy/>Can We Choose What We Enjoy?</a></li><li><a href=/blog/how-to-make-your-profiler-10x-faster/>How To Make Your Profiler 10x Faster</a></li><li><a href=/blog/the-problem-with-photorealism/>The Problem With Photorealism</a></li></ul></details></li><li><details><summary>2013</summary><ul><li><a href=/blog/googles-decline-really-bugs-me/>Google's Decline Really Bugs Me</a></li><li><a href=/blog/the-educational-imbroglio/>The Educational Imbroglio</a></li><li><a href=/blog/write-less-code/>Write Less Code</a></li><li><a href=/blog/most-people-have-shitty-computers/>Most People Have Shitty Computers</a></li><li><a href=/blog/leap-motion-impressions-input/>Leap Motion Impressions, Input Sanitation, and 3D Gesture Ideas</a></li><li><a href=/blog/aurora-theory-released/>Aurora Theory Released!</a></li><li><a href=/blog/what-i-learned-in-college/>What I Learned In College</a></li><li><a href=/blog/course-notes/>Course Notes</a></li><li><a href=/blog/contact/>Contact</a></li><li><a href=/blog/the-dark-side-of-htmlcss/>The Dark Side of Web Development</a></li><li><a href=/blog/windows-breaks-assert-inside/>Windows Breaks assert() Inside WM_CANCELMODE</a></li><li><a href=/blog/the-productivity-fallacy/>The Productivity Fallacy</a></li></ul></details></li><li><details><summary>2012</summary><ul><li><a href=/blog/c-to-c-tutorial-part-4-operator-overload/>C# to C++ Tutorial - Part 4: Operator Overload</a></li><li><a href=/blog/7-problems-raytracing-doesnt-solve/>7 Problems Raytracing Doesn't Solve</a></li><li><a href=/blog/analyzing-xkcd-click-and-drag/>Analyzing XKCD: Click and Drag</a></li><li><a href=/blog/coordinate-systems-and-cascading/>Coordinate Systems And Cascading Stupidity</a></li><li><a href=/blog/how-joysticks-ruined-my-graphics-engine/>How Joysticks Ruined My Graphics Engine</a></li><li><a href=/blog/multithreading-problems-in-game-design/>Multithreading Problems In Game Design</a></li><li><a href=/blog/stop-following-rules/>Stop Following The Rules</a></li><li><a href=/blog/why-windows-8-does-right-thing-wrong/>Why Windows 8 Does The Right Thing The Wrong Way</a></li><li><a href=/blog/visual-studio-broke-my-computer/>Visual Studio Broke My Computer</a></li><li><a href=/blog/implicit-ui-design/>Implicit UI Design</a></li><li><a href=/blog/linux-mint-12-kde/>Linux Mint 12 KDE</a></li><li><a href=/blog/new-post/>'Programmer' is an Overgeneralization</a></li></ul></details></li><li><details><summary>2011</summary><ul><li><a href=/blog/great-mystery-of-linear-gradient/>The Great Mystery of Linear Gradient Lighting</a></li><li><a href=/blog/signed-integers-considered-stupid-like/>Signed Integers Considered Stupid (Like This Title)</a></li><li><a href=/blog/c-to-c-tutorial-part-3-classes-and/>C# to C++ Tutorial - Part 3: Classes and Structs and Inheritance (OH MY!)</a></li><li><a href=/blog/problem-of-vsync/>The Problem of Vsync</a></li><li><a href=/blog/c-to-c-tutorial-part-2-pointers/>C# to C++ Tutorial - Part 2: Pointers Everywhere!</a></li><li><a href=/blog/c-to-c-tutorial-part-1-basics-of-syntax/>C# to C++ Tutorial - Part 1: Basics of Syntax</a></li><li><a href=/blog/ninth-circle-of-bugs/>The Ninth Circle of Bugs</a></li><li><a href=/blog/investigating-low-level-cpu-performance/>Investigating Low-level CPU Performance</a></li></ul></details></li><li><details><summary>2010</summary><ul><li><a href=/blog/im-failure/>The IM Failure</a></li><li><a href=/blog/album-for-sale-renascent/>Album For Sale! [Renascent]</a></li><li><a href=/blog/wavsaver/>WavSaver</a></li><li><a href=/blog/pixel-perfect-hit-testing/>Pixel Perfect Hit Testing</a></li><li><a href=/blog/8-bit-color-cycling/>8-bit color cycling</a></li><li><a href=/blog/physics-networking/>Physics Networking</a></li><li><a href=/blog/assembly-cas-implementation/>Assembly CAS implementation</a></li><li><a href=/blog/function-pointer-speed/>Function Pointer Speed</a></li><li><a href=/blog/most-bizarre-error-ever/>Most Bizarre Error Ever</a></li></ul></details></li><li><details><summary>2009</summary><ul><li><a href=/blog/physics-oriented-network-interpolation/>Physics-oriented Network Interpolation</a></li></ul></details></li></ol></article></section></main><footer><p><span>Copyright &copy;2025 Erik McClure</span> <a href=https://erikmcclure.com/sitemap.xml>Sitemap</a> | <a href=https://erikmcclure.com/blog/index.xml>RSS Feed</a></p></footer></div><script>"use strict";window.onload=function(){e=document.getElementsByClassName("math");for(var e,t=0,n=e.length;t<n;t++)renderMathInElement(e[t],{delimiters:[{left:"$$",right:"$$",display:!1},{left:"\\[",right:"\\]",display:!0}]})}</script></body></html>