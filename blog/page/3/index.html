<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=Edge"><meta http-equiv=Permissions-Policy content="interest-cohort=()"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#2b7bb5"><meta name=copyright content="Copyright (c)2025 map[name:Erik McClure twitter:erikmcclure0173 uri:https://plus.google.com/104896885003230920472]"><meta name=keywords content="games,music,code,erik mcclure,erikmcclure,aurora theory,sweetie bot,discord,feathergui,fading light,tinyoal,cloud hop"><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"><meta name=google-site-verification content="Oxb2ia8HjcHLXlvstA8xPpQO3BO_y15Ds2Ia-feq1MQ"><meta name=generator content="Hugo 0.152.2"><link rel=me href=https://equestria.social/@cloudhop><link rel=canonical href=https://erikmcclure.com/blog/><link rel=apple-touch-icon href=https://erikmcclure.com/favicon.ico><link rel="shortcut icon" type=image/x-icon href=https://erikmcclure.com/favicon.ico><link rel=stylesheet href=https://erikmcclure.com/css/main.css><link rel=stylesheet href=https://erikmcclure.com/css/prism.css rel=stylesheet><link rel=stylesheet href=https://erikmcclure.com/css/katex.min.css rel=stylesheet><link rel=stylesheet href=https://erikmcclure.com/css/fontawesome.min.css><link rel=stylesheet href=https://erikmcclure.com/css/regular.min.css><link rel=stylesheet href=https://erikmcclure.com/css/brands.min.css><link rel=stylesheet href=https://erikmcclure.com/css/solid.min.css><link rel=alternate type=application/rss+xml title="Erik McClure - RSS" href=https://erikmcclure.com/blog/index.xml><meta property="og:type" content="website"><title>Blogs - Erik McClure</title><meta property='og:title' content="Blogs - Erik McClure"><meta name=twitter:title content="Blogs - Erik McClure"><meta itemprop=name content="Blogs - Erik McClure"><meta name=description content="Applied mathematician and software architect who occasionally writes music."><meta property="og:description" content="Applied mathematician and software architect who occasionally writes music."><meta name=twitter:description content="Applied mathematician and software architect who occasionally writes music."><meta itemprop=description content="Applied mathematician and software architect who occasionally writes music."><meta property="og:url" content="https://erikmcclure.com/"><meta property="og:site_name" content="Erik McClure"><meta property="og:image" content="https://erikmcclure.com/img/avatar.png"><meta property="og:locale" content="en-US"><meta property="article:author" content="Erik McClure"><meta name=twitter:card content="summary"><meta name=twitter:site content="@erikmcclure0173"><meta name=twitter:creator content="@erikmcclure0173"><meta name=twitter:image content="https://erikmcclure.com/img/avatar.png"><meta name=twitter:dnt content="on"><link href=https://plus.google.com/104896885003230920472 rel=publisher><meta itemprop=image content="https://erikmcclure.com/img/avatar.png"><meta name=last-updated content="20251122-22:40:00.000"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-63026815-3"></script><script defer src=https://erikmcclure.com/syntax-prism.js></script><script defer src=https://erikmcclure.com/katex.min.js></script><script defer src=https://erikmcclure.com/mathtex-script-type.min.js></script><script defer src=https://erikmcclure.com/auto-render.min.js></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-63026815-3")</script></head><body><div id=container><header><nav><ul><li><a href=/blog/ title=Blog><i class="fa-solid fa-book fa-fw fa-lg"></i>&nbsp;<p>Blog</p></a></li><li><a href=/projects/ title=Projects><i class="fa-solid fa-briefcase fa-fw fa-lg"></i>&nbsp;<p>Projects</p></a></li><li><a href=https://erikmcclure.bandcamp.com title=Bandcamp><i class="fa-brands fa-bandcamp fa-fw fa-lg"></i>&nbsp;<p>Bandcamp</p></a></li><li><a href=https://github.com/erikmcclure title=Github><i class="fa-brands fa-github fa-fw fa-lg"></i>&nbsp;<p>Github</p></a></li><li><a href=/web/ title=Websites><i class="fa-solid fa-globe fa-fw fa-lg"></i>&nbsp;<p>Websites</p></a></li></ul></nav><div class=dim><h1>Erik McClure</h1></div></header><main class=blog><section><article><h4><a href=/blog/discord-should-remove-usernames/>Discord Should Remove Usernames Entirely</a></h4><hr><div class=padding><p><a href=https://discord.com/blog/usernames>Discord&rsquo;s Recent Announcement</a> made a lot of people mad, mostly because of <a href=https://www.hyrumslaw.com/>Hyrum&rsquo;s Law</a> - users were relying on unintended observable behavior in the original username system, and are mad that their use-cases are being broken despite very good evidence that the current system is problematic. I think the major issue here is that Discord didn&rsquo;t go far enough, and as a result, it&rsquo;s confusing users who are unaware of the technical and practical reasons for the username change, or what a username is even for.</p><p><a href=https://twitter.com/TeqieLemon/status/1654014041373790208>There are several issues</a> being brought up with the username change. One is that users are very upset about usernames being ascii-only alphanumeric, presumably because they do not realize that Discord is only ever going to show their usernames for the purposes of adding friends. Their <em>Display Name</em> is what everyone will normally see, which can be any arbitrary unicode. Discord only spent a single sentence mentioning the problem with someone&rsquo;s username being written in ùï®ùïöùïïùïñ ùï•ùïñùï©ùï• and I think a lot of users missed just how big of a problem this is. Any kind of strange character in a username would be liable to render it completely unsearchable, could easily get corrupted when sent over ascii-only text mediums, and essentially had to be copy+pasted verbatim or it wouldn&rsquo;t work.</p><p>However, some users <em>wanted</em> to be unsearchable, because they had stalkers or were very popular and didn&rsquo;t want random people finding their discord account. Discriminators and case-sensitivity essentially created a searchability problem which users were utilizing on purpose to make it harder for people to search them. The solution to this is extremely simple, and was in fact a feature of many early chat apps: let the user turn off the ability for people to search for their username. That&rsquo;s what people <em>actually want</em>.</p><p>What discord is trying to do, and communicating incredibly poorly, is <strong>transform usernames into friend codes</strong>. They say this in a very roundabout way for some reason, and they are also allowing people to essentially <em>reserve custom friend codes</em>. This is silly. Discord should instead <strong>replace usernames with friend codes</strong>, and provide an opt-in fuzzy search mechanism that tries to find someone based on their Display Name, if users want to be discoverable that way. Discord should let you either regenerate or completely disable your own friend code, if users don&rsquo;t want random people trying to friend them.</p><p>What makes this so silly is that nothing is preventing discord from doing this, because <em>you log in with your e-mail anyway!</em> By replacing usernames with display names, Discord has removed all functionality from them aside from friend codes, so they should just turn usernames into friend codes and stop confusing everyone so much. There is absolutely no reason a user should have to keep track of their username, display name, and server specific nicknames, and letting users reserve custom friend codes is never going to work, because everyone is going to fight over common friend codes. Force the friend codes to be random 10-digit alphanumeric strings. Stop pretending they should be anything else. Stop letting people reserve specific ones.</p><p>There is <em>one exception</em> to this that I would tolerate: a custom profile URL. If you wanted to allow people with nitro to, for whatever reason, pay to have a special URL that linked to their profile, this could be done on a first-come first-serve basis, and it would be pretty obvious to everyone why it had to be unique and an ascii-compatible URL.</p><p>I&rsquo;m really tired of companies making a decision for good engineering reasons, and then implementing that decision in the most confusing way possible and blaming anyone who complains as luddites who hate change. There are better ways to communicate these kinds of changes. If your users are confused and angry about it, then it&rsquo;s <em>your fault</em>, not theirs.</p></div><hr><time itemprop=datePublished pubdate=pubdate datetime=2023-05-05T13:02:00+00:00><i class="fa-regular fa-clock fa-fw"></i>&nbsp;Published on <a href=https://erikmcclure.com/blog/discord-should-remove-usernames/>May 5, 2023 at 1:02pm</a></time><aside><a href=/blog/discord-should-remove-usernames/#comments><i class="fa-regular fa-comments fa-fw"></i>&nbsp;0 comments</a></aside><aside><i class="fa-regular fa-share-square fa-fw"></i>&nbsp;share:<ul><li><a href="javascript:window.open('https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ferikmcclure.com%2fblog%2fdiscord-should-remove-usernames%2f','popup','width=600,height=400');"><svg width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#888}</style><path class="st0" d="M16.75 9H13.5V7a1 1 0 011-1h2V3H14a4 4 0 00-4 4V9H8v3h2v9h3.5V12H16z"/></svg></a><li><a href="javascript:window.open('https://twitter.com/intent/tweet?text=Discord%20Should%20Remove%20Usernames%20Entirely&url=https%3a%2f%2ferikmcclure.com%2fblog%2fdiscord-should-remove-usernames%2f','popup','width=600,height=256');"><svg width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#888}</style><path class="st0" opacity="0" d="M0 0h24v24H0z"/><path class="st0" d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572.0-4.658 2.086-4.658 4.66.0.364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342.0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3.0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376.0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57.0 13.255-7.098 13.255-13.254.0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg></a></li><li><a href="javascript:window.open('https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2ferikmcclure.com%2fblog%2fdiscord-should-remove-usernames%2f','popup','width=700,height=380');"><svg width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#888}</style><rect class="st0" height="11" width="4" x="3" y="9"/><circle class="st0" cx="5" cy="5" r="2"/><path class="st0" d="M16.5 8.25A4.47251 4.47251.0 0013 9.95343V9H9V20h4V13a2 2 0 014 0v7h4V12.75a4.5 4.5.0 00-4.5-4.5z"/></svg></a></li></ul></aside></article><article><h4><a href=/blog/money-is-fake/>Money Is Fake. It's Not Real. It's Made Up.</a></h4><hr><div class=padding><blockquote><b>Death</b>: No. Humans need fantasy to be human. To be the place where the falling angel meets the rising ape.<br><b>Susan</b>: With tooth fairies? Hogfathers?<br><b>Death</b>: Yes. As practice, you have to start out learning to believe the little lies.<br><b>Susan</b>: So we can believe the big ones?<br><b>Death</b>: Yes. Justice, mercy, duty. That sort of thing.</blockquote><p>I want to start this by saying that I am in favor of a wealth tax. We should be increasing taxes on the wealthy and raising minimum wage, because we know that steadily increasing the relative buying power of the poor is the best way to improve an economy. However, none of this happens in a vacuum. When we talk about income equality, I have become distressed at the amount of ignorance on display about the economy, systemic societal problems, and even what money actually is.</p><p><a href=https://mkorostoff.github.io/1-pixel-wealth/>One Pixel Wealth</a> is a webpage from 2021 that helps visualize how truly insane the amount of wealth that the richest people have actually is. While the visualization is great at putting in perspective just how much Jeff Bezos&rsquo; wealth is <em>on paper</em>, it links to a refutation of the Paper Billionaire Argument to dispute the idea that Jeff Bezos doesn&rsquo;t <em>really</em> have that much money in liquid assets. The paper billionaire argument is that, because <a href=https://www.cnbc.com/2018/02/07/where-the-super-rich-keep-their-money.html>most wealth is in stocks or bonds</a>, selling it all at once would flood the market and crater the total value of those assets.</p><p><a href=https://github.com/MKorostoff/1-pixel-wealth/blob/master/THE_PAPER_BILLIONAIRE.md>The proposed counter-argument</a> is <strong>incredibly bad</strong>. It demonstrates a total lack of understanding about macro-economic forces. Ironically, this is because it cannot appreciate the scale of its own arguments, the exact issue that One Pixel Wealth is trying to address. Let me paraphrase the key points in this counter-argument:</p><ol><li>The Paper Billionaire argument doesn&rsquo;t work, because you can liquidate the wealth over time in a <a href=https://corpgov.law.harvard.edu/2016/03/24/a-guide-to-rule-10b5-1-plans/>controlled sell-off</a>, which <a href=https://www.cnbc.com/2020/02/11/jeff-bezos-sold-4point1-billion-worth-of-amazon-shares-in-past-week.html>executives do regularly</a>.</li><li>Given that <a href="https://www.nasdaqtrader.com/trader.aspx?id=FullVolumeSummary#">$122 trillion worth of stock</a> changes hands in the US every year, you could liquidate a trillion dollars over five years and only constitute 0.16% of all the trading.</li><li>Because 50% of all US households own stock, you will always be able find people to buy the stock the billionaires are selling, it&rsquo;s not just other billionaires that will buy it.</li><li>Even if the paper bilionaire argument was true, if selling all the stock would lose 80% of it&rsquo;s value, that would leave behind $700 billion.</li></ol><p>To start, #1 and #2 don&rsquo;t work for a very simple reason: A stock&rsquo;s value represents the market&rsquo;s <em>confidence</em> in the stock producing future value. Owning stock, in some circumstances, is interpreted as having confidence in that future value. If the market loses confidence in your company, it doesn&rsquo;t matter what assets you have, your stock price will crater if the market thinks you&rsquo;ll start losing money. If the <em><strong>CEO</strong></em> starts liquidating their position (which they must state their intention to sell stock ahead of time, years before it completes), the market will panic and the stock price will implode at the mere <em>announcement</em> of the liquidation, let alone actually selling any stock. Elon Musk right now should make it painfully obvious that he was only ever the richest man in the world on paper, because he just lost <a href="https://www.cbsnews.com/news/elon-musk-wealth-bernard-arnault-richest-person-forbes-bloomberg-gdp/#:~:text=Arnault%2C%2073%2C%20owns%2048%25,billion%20loss%20on%20the%20year">$107 billion dollars</a> this year! He only bought Twitter for $44 billion! You simply cannot make the combined GDPs of Bulgaria, Croatia, Iceland and Uruguay <em>evaporate</em> if that money was actually real in any sense.</p><p><strong>Money does not represent physical assets.</strong> Money is supposed to represent human labor, and there is a fixed amount of human labor available on the planet. When someone dies or is incapacitated, it goes down. When someone graduates into the labor force, or becomes more skilled, it goes up. In ancient times, &ldquo;human labor&rdquo; was heavily correlated to how much physical activity someone could do, like lifting things or harvesting food. However, our modern economy is dominated by specialist jobs done by highly skilled laborers. So for the sake of analysis, we can say that the GDP of the entire planet should <em>ideally</em> represent the maximum amount of labor the entire human race could do, if we assigned everyone to the job they are most qualified for. We could then increase the total amount of labor we can do by either building machines or improving our skills.</p><p>This leads into why point #3 is complete nonsense. It reminds me of when Ben Shapiro, when talking about climate change, asked &ldquo;you think that people aren&rsquo;t going to just sell their homes and move?&rdquo;</p><iframe width=560 height=315 src=https://www.youtube.com/embed/X9FGRkqUdf8 title="YouTube video player" frameborder=0 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>The <strong>entire point of wealth inequality</strong> is that the top 1% <a href="https://www.bloomberg.com/news/articles/2021-10-08/top-1-earners-hold-more-wealth-than-the-u-s-middle-class?leadSource=uverify+wall">holds more money than the <strong>entire middle-class</strong></a>. That&rsquo;s <em>literally</em> <em><strong>the problem!</strong></em> How can everyone else possibly buy all the stock the billionaires are selling if it would require all of their savings? Who are you selling the stocks to?! <strong>This isn&rsquo;t how money works!</strong> One Pixel Wealth even tries to claim that if we just gave all the poor people in america a bunch of money it would fix poverty, while <a href=https://www.givedirectly.org/research-on-cash-transfers/>linking to a study</a> that only applies to <strong>local</strong> economies. The <em>world&rsquo;s largest economy</em> is <strong>NOT</strong> a local economy! These measures only work when the global economy can absorb the difference, which means making changes gradually or in small, localized areas.</p><p>Of course, even if you somehow magically liquidated all your assets and acquired $700 billion dollars in real, liquid cash, it&rsquo;s not actually $700 billion dollars. It&rsquo;s like saying that there are gold asteroids worth <a href=https://tech.hindustantimes.com/photos/this-asteroid-is-worth-10-000-quadrillion-71659963582639.html>$10000 quadrillion dollars</a> - the value would plummet if you actually had that much gold. Since money represents human labor, which is a limited resource, simply having more money does not let you do more things. $700 billion dollars is enough to hire 12 billion people for 1 day working at minimum wage ($7.25), but you can&rsquo;t actually do that, because there&rsquo;s only 7.8 billion people in the entire world. Having $700 billion in liquid assets would decrease the value <em>of money itself</em>. That&rsquo;s what inflation <em>is</em>. People claim that some billions of dollars will be enough to eradicate malaria or provide drinking water to everyone, but it&rsquo;s <em>never that simple</em> because these are always <em>geopolitical issues</em>. Bill Gates has donated <a href=https://fortune.com/2018/04/18/bill-gates-foundation-malaria/>billions of dollars</a> since <a href=https://www.gatesfoundation.org/ideas/media-center/press-releases/2005/10/gates-foundation-commits-2583-million-for-malaria-research>2005</a> towards fighting malaria and we only got a vaccine <a href=https://www.aljazeera.com/news/2021/10/6/who-reccomends-rollout-of-malaria-vaccine-for-african-children>16 years later</a>. We&rsquo;re surrounded by so many dumb problems we can solve with more money that we&rsquo;ve forgetten that some problems are really, truly, fundamentally difficult problems that cannot be solved by throwing money at them. At some point there are just too many cooks in the kitchen.</p><p>Note that this labor distribution problem applies to <em>liquid assets</em>, which is one theory on why inflation had (until 2021), remained fairly low despite the amount of wealth increasing to ridiculous amounts. Wealthy people are acting as gigantic money sinks - by absorbing all of the &ldquo;money&rdquo;, the actual amount of real, liquid cash in the economy increased at a modest rate, so inflation remained stable. Now, inflation has started to skyrocket in 2022, and some people blame the stimulus payments, but the reality is that the low interest rates during the pandemic, combined with other complex macroeconomic forces, likely caused it, although nobody knows for sure. If wealthy people started actually spending all their money at once, as people seem to want them to do, the amount of liquid assets would skyrocket and so would inflation.</p><p>I keep saying that money is <em>supposed</em> to represent human labor, because it&rsquo;s really an approximation. Someone can be more productive at one job than another, so the amount of human labor is not a knowable value in the first place. Instead, it helps to think of money as representing <em>percieved power imbalance</em> (conservatives often make the mistake of thinking it represents <em>actual</em> power imbalance, which it does not). This power imbalance can come from economic, diplomatic, or military factors. Basically, money is just the current state of global geopolitics. You cannot fight wealth inequality by just redistributing money. Simply taking money from rich people does not fix the systemic issues that created the power imbalance in the first place, because it&rsquo;s not actually <em>wealth</em> inequality, it&rsquo;s <em>power</em> inequality, and that is a political issue, not economic. Money is simply our way of quantifying that imbalance. The government&rsquo;s unwillingness to tax rich people is <em>because</em> of the power imbalance, not the <em>cause</em> of it. If politicians are unwilling to go after rich people, it&rsquo;s because those rich people hold an alarming amount of sway over politicians, which makes them <a href="https://www.youtube.com/watch?v=rStL7niR7gs">keys to power</a>.</p><p>It means that we have allowed power to accumulate in dangerously high concentrations, and we need to deal with this at a political level before we get an economic solution. We must elect leaders that help tackle power inequality (like break up huge corporations) before we can make progress on wealth inequality. Basically, go vote.</p></div><hr><time itemprop=datePublished pubdate=pubdate datetime=2022-12-17T17:16:00+00:00><i class="fa-regular fa-clock fa-fw"></i>&nbsp;Published on <a href=https://erikmcclure.com/blog/money-is-fake/>December 17, 2022 at 5:16pm</a></time><aside><a href=/blog/money-is-fake/#comments><i class="fa-regular fa-comments fa-fw"></i>&nbsp;0 comments</a></aside><aside><i class="fa-regular fa-share-square fa-fw"></i>&nbsp;share:<ul><li><a href="javascript:window.open('https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ferikmcclure.com%2fblog%2fmoney-is-fake%2f','popup','width=600,height=400');"><svg width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#888}</style><path class="st0" d="M16.75 9H13.5V7a1 1 0 011-1h2V3H14a4 4 0 00-4 4V9H8v3h2v9h3.5V12H16z"/></svg></a><li><a href="javascript:window.open('https://twitter.com/intent/tweet?text=Money%20Is%20Fake.%20It%27s%20Not%20Real.%20It%27s%20Made%20Up.&url=https%3a%2f%2ferikmcclure.com%2fblog%2fmoney-is-fake%2f','popup','width=600,height=256');"><svg width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#888}</style><path class="st0" opacity="0" d="M0 0h24v24H0z"/><path class="st0" d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572.0-4.658 2.086-4.658 4.66.0.364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342.0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3.0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376.0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57.0 13.255-7.098 13.255-13.254.0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg></a></li><li><a href="javascript:window.open('https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2ferikmcclure.com%2fblog%2fmoney-is-fake%2f','popup','width=700,height=380');"><svg width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#888}</style><rect class="st0" height="11" width="4" x="3" y="9"/><circle class="st0" cx="5" cy="5" r="2"/><path class="st0" d="M16.5 8.25A4.47251 4.47251.0 0013 9.95343V9H9V20h4V13a2 2 0 014 0v7h4V12.75a4.5 4.5.0 00-4.5-4.5z"/></svg></a></li></ul></aside></article><article><h4><a href=/blog/we-need-new-motherboards/>We Need New Motherboards Before GPUs Collapse Under Their Own Gravity</a></h4><hr><div class=padding><p><strong>You can&rsquo;t have a 4-slot GPU. You just can&rsquo;t.</strong></p><p>We have finally left sanity behind, with nvidia&rsquo;s 4000 series cards yielding a &ldquo;clown car&rdquo; of absurd GPU designs, as <a href="https://www.youtube.com/watch?v=mGARjRBJRX8">GamersNexus put it</a>. These cards are so huge they need &ldquo;GPU Support Sticks&rdquo;, which are an <a href=https://www.pcworld.com/article/1072925/custom-nvidia-geforce-rtx-4090-4080s-graphics-cards-insane.html>actual real thing now</a>. The fact that we insist on relegating the GPU to interfacing with the system while hanging off of a single, increasingly absurd PCIe 6.0 x16 slot that can <a href=https://www.anandtech.com/show/17203/pcie-60-specification-finalized-x16-slots-to-reach-128gbps>push 128 GBps</a> is <strong>completely insane</strong>. There is no real ability to just pick the GPU you want and then pair it with a cooler that is <em>actually attached to the motherboard</em>. The entire cooling solution has to be in the card itself and we are fast reaching the practical limitations here due to gravity and the laws of physics. Top-heavy GPUs are now essentially giant levers pulling on the PCIe slot, with the only possible anchor point that is above the center of mass being the bracket on one side.</p><p>A 4090 series card will demand a whopping 450 W, which dwarfs the Ryzen 9 5900X peak power consumption of only 140 W. That&rsquo;s over 3 times as much power! The graphics card is now drawing more power than the <strong>entire rest of the computer!</strong> We&rsquo;ll have to wait for benchmarks to be sure, but the laws of thermodynamics suggest that the GPU will now also be producing more heat than every other component of the PC, <em>combined</em>. And this is the thing we have hanging off of a PCIe slot that doesn&rsquo;t have any other way of mounting a cooling solution to the motherboard?!</p><p><strong>What the FUCK are we doing?!</strong></p><p>Look, I&rsquo;m not a hardware guy. I just write all the shader code that makes GPUs cry. I don&rsquo;t actually know how we should fix this problem, because I don&rsquo;t know what designs are thermally efficient or not. I do know, however, that something has to change. Maybe we can make motherboards with a GPU slot next to the CPU slot and have a unified massive radiator sitting on top of them - or maybe it&rsquo;s a better idea to put the two processor units on opposite ends of the board. I don&rsquo;t know, <strong>just <em>do</em> something</strong> so I can use a cooling solution that is actually <em>screwed into the fucking motherboard</em> instead of requiring a &ldquo;GPU Support Stick&rdquo; so gravity doesn&rsquo;t rip it out of the PCIe slot.</p><p>As an example of alternative solutions, <a href="https://www.amazon.com/Original-Graphics-Alienware-N14E-GS-A1-Replacement/dp/B081L3KH3T/ref=sr_1_35?keywords=mxm+graphics+card&amp;qid=1663887964&amp;sr=8-35">here is an MXM form-factor</a> for laptops that allow them to provide custom cooling solutions appropriate for the laptop.</p><div class=imgwrap style=max-width:466px><a href=https://m.media-amazon.com/images/I/71QOqoCJ3WL._AC_SX466_.jpg target=_blank><img src=https://m.media-amazon.com/images/I/71QOqoCJ3WL._AC_SX466_.jpg width=100%></a></div><p>In fact, the PCIe spec itself actually contains a rear-bracket mount that, if anyone was paying attention, would help address this problem:</p><div class=imgwrap style=max-width:1440px><a href=/img/pci_standard.png target=_blank><img src=/img/pci_standard.png width=100%></a></div><p>See that funky looking metal thing labeled &ldquo;2&rdquo; on the diagram? That sure looks like a good alternative to a &ldquo;support stick&rdquo; if anyone ever actually paid attention to the spec. Or maybe this second bracket doesn&rsquo;t work very well and we need to rethink how motherboards work entirely. Should we have GPU VRAM slots alongside CPU RAM slots? Is that even possible? (<a href="https://news.ycombinator.com/item?id=32946816">Nope.</a>) Or maybe we can come up with an alternative form factor for GPU cards that you can actually attach to the motherboard with screws?</p><p>I have no idea what is or isn&rsquo;t practical, but please, just do something before the GPUs collapse under their own gravity and create strange new forms of matter inside my PC case.</p></div><hr><time itemprop=datePublished pubdate=pubdate datetime=2022-09-22T16:30:00+00:00><i class="fa-regular fa-clock fa-fw"></i>&nbsp;Published on <a href=https://erikmcclure.com/blog/we-need-new-motherboards/>September 22, 2022 at 4:30pm</a></time><aside><a href=/blog/we-need-new-motherboards/#comments><i class="fa-regular fa-comments fa-fw"></i>&nbsp;0 comments</a></aside><aside><i class="fa-regular fa-share-square fa-fw"></i>&nbsp;share:<ul><li><a href="javascript:window.open('https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ferikmcclure.com%2fblog%2fwe-need-new-motherboards%2f','popup','width=600,height=400');"><svg width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#888}</style><path class="st0" d="M16.75 9H13.5V7a1 1 0 011-1h2V3H14a4 4 0 00-4 4V9H8v3h2v9h3.5V12H16z"/></svg></a><li><a href="javascript:window.open('https://twitter.com/intent/tweet?text=We%20Need%20New%20Motherboards%20Before%20GPUs%20Collapse%20Under%20Their%20Own%20Gravity&url=https%3a%2f%2ferikmcclure.com%2fblog%2fwe-need-new-motherboards%2f','popup','width=600,height=256');"><svg width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#888}</style><path class="st0" opacity="0" d="M0 0h24v24H0z"/><path class="st0" d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572.0-4.658 2.086-4.658 4.66.0.364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342.0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3.0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376.0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57.0 13.255-7.098 13.255-13.254.0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg></a></li><li><a href="javascript:window.open('https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2ferikmcclure.com%2fblog%2fwe-need-new-motherboards%2f','popup','width=700,height=380');"><svg width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#888}</style><rect class="st0" height="11" width="4" x="3" y="9"/><circle class="st0" cx="5" cy="5" r="2"/><path class="st0" d="M16.5 8.25A4.47251 4.47251.0 0013 9.95343V9H9V20h4V13a2 2 0 014 0v7h4V12.75a4.5 4.5.0 00-4.5-4.5z"/></svg></a></li></ul></aside></article><article><h4><a href=/blog/cpp-constructors-memory-and-lifetimes/>C++ Constructors, Memory, and Lifetimes</a></h4><hr><div class=padding><div class=imgwrap style=max-width:400px><a href=/img/cpp_init_forest.gif target=_blank><img src=/img/cpp_init_forest.gif alt="C++ Initialization Hell" width=100%></a></div><p>What exactly happens when you write <code><code>Foo* foo = new Foo();</code></code>? A lot is packed into this one statement, so lets try to break it down. First, this example is allocating new memory on the heap, but in order to understand everything that&rsquo;s going on, we&rsquo;re going to have to explain what it means to declare a variable <em>on the stack</em>. If you already have a good understanding of how the stack works, and how functions do cleanup before returning, feel free to skip to the <a href=#new-statements>new statement</a>.</p><h3 id=stack-lifetimes>Stack Lifetimes</h3><p>Describing the stack is very often glossed over in many other imperative languages, despite the fact that those languages still have one (functional languages are an entirely different level of weird). Let&rsquo;s start with something very simple:<pre class=language-cpp><code>int foobar(int b)
{
  int a;
  a = b;
  return a;
}
</code></pre>Here, we are declaring a function <code>foobar</code> that takes an <code>int</code> and returns an <code>int</code>. The first line of the function declares a variable <code>a</code> of type <code>int</code>. This is all well and good, but <em>where is the integer?</em>. On most modern platforms, <code>int</code> resolves to a 32-bit integer that takes up 4 bytes of space. We haven&rsquo;t allocated any memory yet, because no <code>new</code> statement happened and no <code>malloc()</code> was called. Where is the integer?</p><p>The answer is that the integer was allocated on the <em>stack</em>. If you aren&rsquo;t familiar with the <a href=https://en.wikipedia.org/wiki/Stack_(abstract_data_type)>computer science data structure</a> of the same name, your program is given a chunk of memory by the operating system that is organized into a stack structure, hence the name. It&rsquo;s like a stack of plates - you can push items on top of the stack, or you can remove items from the top of the stack, but you can&rsquo;t remove things from the middle of the stack or all the plates will come crashing down. So if we push something on top of the stack, we&rsquo;re stuck with it until we get rid of everything on top of it.</p><p>When we called our function, the parameter <code>int b</code> was pushed on to the stack. Parameters take up memory, so on to the stack they go. Hence, before we ever reach the statement <code>int a</code>, 4 bytes of memory were already pushed onto our stack. Here&rsquo;s what our stack looks like at the beginning of the function if we call it with the number <code>90</code> (assuming little-endian):</p><div class=imgwrap style=max-width:450px><a href=/img/stack1.svg target=_blank><img src=/img/stack1.svg alt="Stack for b" width=100%></a></div><p><code>int a</code> tells the compiler to push another 4 bytes of memory on to the stack, but it has no initial value, so the contents are undefined:</p><div class=imgwrap style=max-width:450px><a href=/img/stack2.svg target=_blank><img src=/img/stack2.svg alt="Stack for a and b" width=100%></a></div><p><code>a = b</code> assigns b to a, so now our stack looks like this:</p><div class=imgwrap style=max-width:450px><a href=/img/stack3.svg target=_blank><img src=/img/stack3.svg alt="Stack for initialized a and b" width=100%></a></div><p>Finally, <code>return a</code> tells the compiler to evaluate the return expression (which in our case is just <code>a</code> so there&rsquo;s nothing to evaluate), then copy the result into a chunk of memory we reserved ahead of time for the return value. Some programmers may assume the function returns <em>immediately</em> once the <code>return</code> statement is executed - after all, that&rsquo;s what <code>return</code> means, right? However, the reality is that the function still has to clean things up before it can actually return. Specifically, we need to return our stack to the state it was before the function was called by removing everything we pushed on top of it <strong>in reverse order</strong>. So, after copying our return value <code>a</code>, our function pops the top of the stack off, which is the last thing we pushed. In our case, that&rsquo;s <code>int a</code>, so we pop it off the stack. Our stack now looks like this:</p><div class=imgwrap style=max-width:450px><a href=/img/stack1.svg target=_blank><img src=/img/stack1.svg alt="Stack without a" width=100%></a></div><p>The moment from which <code>int a</code> was pushed onto the stack to the moment it was popped off the stack is called the <strong>lifetime</strong> of <code>int a</code>. In this case, <code>int a</code> has a lifetime of the entire function. After the function returns, our caller has to pop off <code>int b</code>, the parameter we called the function with. Now our stack is empty, and the <strong>lifetime</strong> of <code>int b</code> is longer than the <strong>lifetime</strong> of <code>int a</code>, because it was pushed first (before the function was called) and popped afterwards (after the function returned). C++ builds it&rsquo;s entire concept of constructors and destructors on this concept of lifetimes, and they can get very complicated, but for now, we&rsquo;ll focus only on stack lifetimes.</p><p>Let&rsquo;s take a look at a more complex example:<pre class=language-cpp><code>int foobar(int b)
{
  int a;
  
  {
    int x;
    x = 3;
    
    {
      int z;
      int max;
      
      max = 999;
      z = x + b;
      
      if(z &gt; max)
      {
        return z - max;
      }
      
      x = x + z;
    }
    
    // a = z; // COMPILER ERROR!
    
    {
      int ten = 10;
      a = x + ten;
    }
  } 
  
  return a;
}
</code></pre>Let&rsquo;s look at the lifetimes of all our parameters and variables in this function. First, before calling the function, we push <code>int b</code> on to the stack with the value of whatever we&rsquo;re calling the function with - say, <code>900</code>. Then, we call the function, which immediately pushes <code>int a</code> on to the stack. Then, we <em>enter a new block</em> using the character <code>{</code>, which does not consume any memory, but instead acts as a marker for the compiler - we&rsquo;ll see what it&rsquo;s used for later. Then, we push <code>int x</code> on to the stack. We now have 3 integers on the stack. We set <code>int x</code> to <code>3</code>, but <code>int a</code> is still undefined. Then, we <em>enter another new block</em>. Nothing interesting has happened yet. We then push both <code>int z</code> and <code>int max</code> on to the stack. Then we assign <code>999</code> to <code>int max</code> and assign <code>int z</code> the value <code>x + b</code> - if we passed in <code>900</code>, this means <code>z</code> is now equal to <code>903</code>, which is less than the value of <code>int max</code> (<code>999</code>), so we skip the if statement for now. Then we assign <code>x</code> to <code>x + z</code>, which will be <code>906</code>.</p><p>Now things get interesting. Our topmost block <strong>ends</strong> with a <code>}</code> character. This tells the compiler to <em>pop all variables declared inside that block</em>. We pushed <code>int z</code> on to the stack inside this block, so it&rsquo;s gone now. We cannot refer to <code>int z</code> anymore, and doing so will be a compiler error. <code>int z</code> is said to have <em>gone out of scope</em>. However, we also pushed <code>int max</code> on to the stack, and we pushed it after <code>int z</code>. This means that the compiler will <strong>first pop <code>int max</code> off the stack</strong>, and only afterwards will it then pop <code>int z</code> off the stack. The order in which this happens will be critical for understanding how lifetimes work with constructors and destructors, so keep it in mind.</p><p>Then, we enter another new scope. This new scope is still inside the first scope we created that contains <code>int x</code>, so we can still access <code>x</code>. We define <code>int ten</code> and initialize it with <code>10</code>. Then we set <code>int a</code> equal to <code>x + ten</code>, which will be <code>916</code>. Then, our scope ends, and <code>int ten</code> goes out of scope, being popped off the stack. Immediately afterwards, we reach the end of our first scope, and <code>int x</code> is popped off the stack.</p><p>Finally, we reach <code>return a</code>, which copies <code>a</code> to our return value memory segment, pops <code>int a</code>, and returns to our caller, who then pops <code>int b</code>. That&rsquo;s what happens when we pass in <code>900</code>, but what happens if we pass in <code>9000</code>?</p><p>Everything is the same until we reach the <code>if</code> statement, whose condition is now satisfied, which results in the function terminating early and returning <code>z - max</code>. What happens to the stack?</p><p>When we reach <code>return z - max</code>, the compiler evaluates the statement and copies the result (<code>8004</code>) out. Then it starts popping everything off the stack (once again, in the reverse order that things were pushed). The last thing we pushed on to the stack was <code>int max</code>, so it gets popped first. Then <code>int z</code> is popped. Then <code>int x</code> is popped. Then <code>int a</code> is popped, the function returns, and finally <code>int b</code> is popped by the caller. This behavior is critical to how C++ uses lifetimes to implement things like smart pointers and automatic memory management. Rust actually uses a similar concept, but it uses it for a lot more than C++ does.</p><h3 id=new-statements><code>new</code> Statements</h3><p>Okay, now we know how lifetimes work and where variables live when they aren&rsquo;t allocated, but what happens when you <em>do</em> allocate memory? What&rsquo;s going on with the <code>new</code> statement? To look at this, let&rsquo;s use a simplified example:<pre class=language-cpp><code>int* foo = new int();
</code></pre>Here we have allocated a pointer to an integer on the stack (which will be 8 bytes if you&rsquo;re on a 64-bit system), and assigned the result of <code>new int()</code> to it. What happens when we call <code>new int()</code>? In C++, the <code>new</code> operator is an extension of <code>malloc()</code> from C. This means it allocates memory from the <em>heap</em>. When you allocate memory on the heap, it never goes out of scope. This is what most programmers are familiar with in other languages, except that most other languages handle figuring out when to deallocate it and C++ forces you to delete it yourself. Memory allocated on the heap is just there, floating around, forever, or until you deallocate it. So this function has a memory leak:<pre class=language-cpp><code>int bar(int b)
{
  int* a = new int();
  *a = b;
  return *a;
}
</code></pre>This is the same as our <a href=#stack-lifetimes>first example</a>, except now we allocate <code>a</code> on the heap instead of the stack. So, it never goes out of scope. It&rsquo;s just there, sitting in memory, forever, until the process is terminated. The <code>new</code> operator looks at the type we passed it (which is <code>int</code> in this case) and calls <code>malloc</code> for us with the appropriate number of bytes. Because <code>int</code> has no constructors or destructors, it&rsquo;s actually equivelent to this:<pre class=language-cpp><code>int bar(int b)
{
  int* a = (int*)malloc(sizeof(int));
  *a = b;
  return *a;
}
</code></pre>Now, people who are familiar with C will recognize that any call to <code>malloc</code> should come with a call to <code>free</code>, so how do we do that in C++? We use <code>delete</code>:<pre class=language-cpp><code>int bar(int b)
{
  int* a = new int();
  *a = b;
  int r = *a;
  delete a;
  return r;
}
</code></pre><strong>IMPORTANT:</strong> Never mix <code>new</code> and <code>free</code> or <code>malloc</code> and <code>delete</code>. The <code>new</code>/<code>delete</code> operators can use a different allocator than <code>malloc</code>/<code>free</code>, so things will violently explode if you treat them as interchangeable. Always <code>free</code> something from <code>malloc</code> and always <code>delete</code> something created with <code>new</code>.</p><p>Now we aren&rsquo;t leaking memory, but we also can&rsquo;t do <code>return *a</code> anymore, because it&rsquo;s impossible for us to do the necessary cleanup. If we were allocating on the stack, C++ would clean up our variable for us after the <code>return</code> statement, but we can&rsquo;t put anything after the return statement, so there&rsquo;s no way to tell C++ to copy the value of <code>*a</code> and <em>then</em> manually delete <code>a</code> without introducing a new variable <code>r</code>. Of course, if we could run arbitrary code when our variable went out of scope, we could solve this problem! This sounds like a job for constructors and destructors!</p><h3 id=constructors-and-delete>Constructors and <code>delete</code></h3><p>Okay, let&rsquo;s put everything together and return to our original statement in a more complete example:<pre class=language-cpp><code>struct Foo
{
  // Constructor for Foo
  Foo(int b)
  {
    a = b;
  }
  // Empty Destructor for Foo
  ~Foo() {}
  
  int a;
};

int bar(int b)
{
  // Create
  Foo* foo = new Foo(b);
  int a = foo-&gt;a;
  // Destroy
  delete foo;
  return a; // Still can&#39;t return foo-&gt;a
}
</code></pre>In this code, we still haven&rsquo;t solved the return problem, but we are now using constructors and destructors, so let&rsquo;s walk through what happens. First, <code>new</code> allocates memory on the heap for your type. <code>Foo</code> contains a 32-bit integer, so that&rsquo;s 4 bytes. Then, <em>after</em> the memory is allocated, <code>new</code> automatically calls the <em>constructor</em> that matches whatever parameters you pass to the type. Your constructor doesn&rsquo;t need to allocate any memory to contain your type, since <code>new</code> already did this for you. Then, this pointer is assigned to <code>foo</code>. Then we delete <code>foo</code>, which <strong>calls the destructor first</strong> (which does nothing), and <em>then</em> deallocates the memory. If you don&rsquo;t pass any parameters when calling <code>new Type()</code>, or you are creating an array, C++ will simply call the default constructor (a constructor that takes no parameters). This is all equivelent to:<pre class=language-cpp><code>int bar(int b)
{
  // Create
  Foo* foo = (Foo*)malloc(sizeof(Foo));
  new (foo) Foo(b); // Special new syntax that ONLY calls the constructor function (this is how you manually call constructors in C++)
  int a = foo-&gt;a; 
  // Destroy
  foo-&gt;~Foo(); // We can, however, call the destructor function directly
  free(foo);
  
  return a; // Still can&#39;t return foo-&gt;a
}
</code></pre>This uses a special new syntax that doesn&rsquo;t allocate anything and simply lets us call the constructor function directly on our already allocated memory. This is what the <code>new</code> operator is doing for you under the hood. We then call the destructor manually (which you <em>can</em> do) and free our memory. Of course, this is all still useless, because we can&rsquo;t return the integer we allocated on the heap!</p><h3 id=destructors-and-lifetimes>Destructors and lifetimes</h3><p>Now, the magical part of C++ is that constructors and destructors are run <em>when things are pushed or popped from the stack</em> <sup><a href=#f1>[1]</a></sup>. The fact that constructors and destructors respect variable lifetimes allows us to solve our problem of cleaning up a heap allocation upon returning from a function. Let&rsquo;s see how that works:<pre class=language-cpp><code>struct Foo
{
  // Default constructor for Foo
  Foo()
  {
    a = new int();
  }
  // Destructor frees memory we allocated using delete
  ~Foo()
  {
    delete a;
  }
  
  int* a;
};

int bar(int b)
{
  Foo foo;
  *foo.a = b;
  return *foo.a; // Doesn&#39;t leak memory!
}
</code></pre>How does this avoid leaking memory? Let&rsquo;s walk through what happens: First, we declare <code>Foo foo</code> on the stack, which pushes 4 bytes on to the stack, and then C++ calls our default constructor. Inside our default constructor, we use <code>new</code> to allocate a new integer and store it in <code>int* a</code>. Returning to our function, we then set our integer pointer <code>foo.a</code> to <code>b</code>. Then, we return the value stored in <code>foo.a</code> from the function<sup><a href=#f2>[2]</a></sup>. This copies the value out of <code>foo.a</code> first by dereferencing the pointer, and <em>then</em> C++ calls our destructor <code>~Foo</code> before <code>Foo foo</code> is popped off the stack. This destructor deletes <code>int* a</code>, ensuring we don&rsquo;t leak any memory. Then we pop off <code>int b</code> from the stack and the function returns. If we could somehow do this without constructors or destructors, it would look like this:<pre class=language-cpp><code>int bar(int b)
{
  Foo foo;
  foo.a = new int();
  *foo.a = b;
  int retval = *foo.b;
  delete a;
  return retval;
}
</code></pre>The ability to run a destructor when something goes out of scope is an incredibly important part of writing good C++ code, becuase when a function returns, <em>all</em> your variables go out of scope when the stack is popped. Thus, all cleanup that is done during destructors is gauranteed to run no matter when you return from a function. Destructors are gauranteed to run <strong>even when you throw an exception!</strong> This means that if you throw an exception that gets caught farther up in the program, you won&rsquo;t leak memory, because C++ ensures that everything on the stack is correctly destroyed when processing exception handling, so all destructors are run in the same order they normally are.</p><p>This is the core idea behind smart pointers - if a pointer is stored inside an object, and that object deletes the pointer in the destructor, then you will never leak the pointer because C++ ensures that the destructor will eventually get called when the object goes out of scope. Now, if implemented naively there is no way to pass the pointer into different functions, so the utility is limited, but C++11 introduced <strong>move semantics</strong> to help solve this issue. We&rsquo;ll talk about those later. For now, let&rsquo;s talk about different kinds of lifetimes and what they mean for when constructors and destructors are called.</p><h3 id=static-lifetimes>Static Lifetimes</h3><p>Because any struct or class in C++ can have constructors or destructors, and you can put structs or classes anywhere in a C++ program, this means that there are rules for how to safely invoke constructors and destructors in all possible cases. These different possible lifetimes have different names. Global variables, or static variables inside classes, have what&rsquo;s called &ldquo;static lifetime&rdquo;, which means their lifetime begins when the program starts and ends once the program exits. The exact order these constructors are called, however, is a bit tricky. Let&rsquo;s look at an example:<pre class=language-cpp><code>struct Foo
{
  // Default constructor for Foo
  Foo()
  {
    a = new int();
  }
  // Destructor frees memory we allocated using delete
  ~Foo()
  {
    delete a;
  }
  
  int* a;
  static Foo instance;
};

static Foo GlobalFoo;

int main()
{
  *GlobalFoo.a = 3;
  *Foo::instance.a = *GlobalFoo.a;
  return *Foo::instance.a;
}
</code></pre>When is <code>instance</code> constructed? When is <code>GlobalFoo</code> constructed? Can we safely assign to <code>GlobalFoo.a</code> immediately? The answer is that all static lifetimes are constructed <strong>before your program even starts</strong>, or more specifically, before <code>main()</code> is called. Thus, by the time your program has reached your entry point (<code>main()</code>), C++ gaurantees that all static lifetime objects have already been constructed. But what <em>order</em> are they constructed in? This gets complicated. Basically, static variables are constructed in the order they are declared in a single <code>.cpp</code> file. However, the order these <code>.cpp</code> files are constructed in is undefined. So, you can have static variables that rely on each other inside a single <code>.cpp</code> file, but never between different files.</p><p>Likewise, all static lifetime objects get deconstructed <em>after</em> your <code>main()</code> function returns, and once again, this order is random, although it <em>should</em> be in the reverse order they were constructed in. Technically this should be respected even if an exception occurs, but because the compiler can assume the process will terminate immediately after an unhandled exception occurs, this is unreliable.</p><p>Static lifetimes still apply for shared libraries, and are constructed the moment the library is loaded into memory - that&rsquo;s <code>LoadLibrary</code> on Windows and <code>dlopen</code> on Linux. Most kernels provide a custom function that fires when the shared library is loaded or unloaded, and these functions fall outside of the C++ standard, so there&rsquo;s no gaurantee about whether the static constructors have actually been called when you&rsquo;re inside the <code>DllLoad</code>, but almost nobody actually needs to worry about those edge cases, so for any normal code, by the time any function in your DLL can be called by another program, you can rest assured all static and global variables have had their constructors called. Likewise, they are destructed when the shared library is unloaded from memory.</p><p>While we&rsquo;re here, there are a few gotchas in the previous example that junior programmers should know about. You&rsquo;ll notice that I did not write <code><code>static Foo* = new GlobalFoo();</code></code> - <strong>this will leak memory!</strong>. In this case, C++ doesn&rsquo;t actually call the destructor because <code>Foo</code> doesn&rsquo;t have a static lifetime, <strong>the pointer it&rsquo;s stored in does!</strong>. So the <em>pointer</em> will get it&rsquo;s constructor called before the program starts (which does nothing, because it&rsquo;s a primitive), and then the pointer will have it&rsquo;s destructor called after <code>main()</code> returns, which also does nothing, which means <code>Foo</code> never actually gets deconstructed or deallocated. Always remember that C++ is <em>extremely</em> picky about what you do. C++ won&rsquo;t magically extend Foo&rsquo;s lifetime to the lifetime of the pointer, it will instead do <em>exactly</em> what you told it to do, which is to declare a global pointer primitive.</p><p>Another thing to avoid is to not accidentally write <code>Foo::instance.a = GlobalFoo.a;</code>, because this doesn&rsquo;t copy the integer, it copies <em>the pointer</em> from <code>GlobalFoo</code> to <code>Foo::instance</code>. This is extremely bad, because now <code>Foo::instance</code> will leak it&rsquo;s pointer and instead try to free <code>GlobalFoo</code>&rsquo;s pointer, which was already deleted by <code>GlobalFoo</code>, so the program will crash, but only AFTER successfully returning 3. In fact, it will crash outside of the <code>main()</code> function completely, which is going to look very weird if you don&rsquo;t know what&rsquo;s going on.</p><h3 id=implicit-constructors-and-temporary-lifetimes>Implicit Constructors and Temporary Lifetimes</h3><p>Lifetimes in C++ can get complicated, because they don&rsquo;t just apply to function blocks, but also function parameters, return values, and expressions. This means that, for example, if we are calling a function, and we construct a new object inside the function call, there is an implicit lifetime that exists for the duration of the function call, which is well-defined but very weird unless you&rsquo;re aware of exactly what&rsquo;s going on. Let&rsquo;s look at a simple example of a function call that constructs an object:<pre class=language-cpp><code>class Foo
{
  // Implicit constructor for Foo
  Foo(int b)
  {
    a = b;
  }
  // Empty Destructor for Foo
  ~Foo() {}
  
  int a;
}

int get(Foo foo)
{
  return foo.a;
}

int main()
{
  return get(3);
}
</code></pre>To understand what&rsquo;s going on here, we need to understand <em>implicit constructors</em>, which are a &ldquo;feature&rdquo; of C++ you never wanted but got anyway. In C++, all constructors that take exactly 1 argument are <em>implicit</em>, which means the compiler will attempt to use call them to satisfy a type transformation. In this case, we are trying to pass <code>3</code> into the <code>get()</code> function. <code>3</code> has the type <code>int</code>, but <code>get()</code> takes an argument of type <code>Foo</code>. Normally, this would just cause an error, because the types don&rsquo;t match. But because we have a constructor for <code>Foo</code> that takes an <code>int</code>, the compiler actually calls it for us, constructing an object of type <code>Foo</code> and passing it into the function! Here&rsquo;s what it looks like if we do this ourselves:<pre class=language-cpp><code>int main()
{
  return get(Foo(3));
}
</code></pre>C++ has &ldquo;helpfully&rdquo; inserted this constructor for us inside the function call. So, now that we know our <code>Foo</code> object is being constructed inside the function call, we can ask a different question: When does the constructor get called, exactly? When is it destructed? The answer is that all the expressions in your function call are evaluated first, from left-to-right. Our expression allocated a new temporary <code>Foo</code> object by pushing it onto the stack and then calling the constructor. However, do be aware that compilers <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51253">aren&rsquo;t always so great about respecting initialization order</a> in function calls or other initialization lists. But, ostensibly, they&rsquo;re <em>supposed</em> to be evaluated from left-to-right.</p><p>So, once all expressions inside the parameteres have been evaluated, we then push the parameters on to the stack and copy the results of the expressions into them, allocate space on the stack for the return value, and then we enter the function. Our function executes, copies a return value into the space we reserved, finishes cleaning up, and returns. Then we do something with the return value and pop our parameters off the stack. Finally, after all the function parameter boilerplate has been finished, our expressions go out of scope in reverse order. This means that destructors are called from right-to-left after the function returns. This is all roughly equivilent to doing this:<pre class=language-cpp><code>int main()
{
  int b;
  {
    Foo a = Foo(3); // Construct Foo
    b = get(a); // Call function and copy result
  } // Deconstruct Foo
  return b;
}
</code></pre>This same logic works for all expressions - if you construct a temporary object inside an expression, it exists for the duration of the expression. However, the exact order that C++ evaluates expressions is <a href=https://en.cppreference.com/w/cpp/language/eval_order>extremely complicated and not always defined</a>, so this is a bit harder to nail down. Generally speaking, an object gets constructed right before it&rsquo;s needed to evaluate the expression, and gets deconstructed afterwards. These are &ldquo;temporary lifetimes&rdquo;, because the object only briefly exists inside the expression, and is deconstructed once the expression is evaluated. Because C++ expressions are not always ordered, you should not attempt to rely on any sort of constructor order for arbitrary expressions. As an example, we can inline our previous <code>get()</code> function:<pre class=language-cpp><code>int main()
{
  return Foo(3).a;
}
</code></pre>This will allocate a temporary object of type <code>Foo</code>, construct it with <code>3</code>, copy out the value from <code>a</code>, and then deconstruct the temporary object before the return statement is evaluated. For the most part, you can just assume your objects get constructed before the expression happens and get destructed after it happens - try not to rely on ordering more specific than that. The specific ordering rules are also changing in C++20 to make it more strict, which means how strict the ordering is will depend on what compiler you&rsquo;re using until everyone implements the standard properly.</p><p>For the record, if you don&rsquo;t want C++ &ldquo;helpfully&rdquo; turning your constructors into implicit ones, you can use the <code>explicit</code> keyword to disable that behavior:<pre class=language-cpp><code>struct Foo
{
  explicit Foo(int b)
  {
    a = b;
  }
  ~Foo() {}
  
  int a;
};
</code></pre></p><h3 id=static-variables-and-thread-local-lifetimes>Static Variables and Thread Local Lifetimes</h3><p>Static variables inside a function (not a struct!) operate by completely different rules, because this is C++ and consistency is for the weak.<pre class=language-cpp><code>struct Foo
{
  explicit Foo(int b)
  {
    a = b;
  }
  ~Foo() {}
  
  int a;
};

int get()
{
  static Foo foo(3);
  
  return foo.a;
}

int main()
{
  return get() + get();
}
</code></pre>When is <code>foo</code> constructed? It&rsquo;s not when the program starts - it&rsquo;s actually only constructed <em>the first time the function gets called</em>. C++ injects some magic code that stores a global flag saying whether or not the static variable has been initialized yet. The first time we call <code>get()</code>, it will be false, so the constructor is called and the flag is set to true. The second time, the flag is true, so the constructor isn&rsquo;t called. So when does it get destructed? After <code>main()</code> returns and the program is exiting, just like global variables!</p><p>Now, this static initialization <em>is</em> gauranteed to be thread-safe, but that&rsquo;s only useful if you intend to share the value through multiple threads, which usually doesn&rsquo;t work very well, because only the initialization is thread-safe, not accessing the variable. C++ has introduced a new lifetime called <code>thread_local</code> which is even weirder. Thread-local static variables only exist for the duration of the <em>thread</em> they belong to. So, if you have a thread-local static variable in a function, it&rsquo;s constructed the first time you call the function <em>on a per-thread basis</em>, and destroyed <em>when each thread exits</em>, not the program. This means you are gauranteed to have a unique instance of that static variable for each thread, which can be useful in certain concurrency situations.</p><p>I&rsquo;m not going to spend any more time on <code>thread_local</code> because to understand it you really need to know how C++ concurrency works, which is out of scope for this blog post. Instead, let&rsquo;s take a brief look at Move Semantics.</p><h3 id=move-semantics>Move Semantics</h3><p>Let&rsquo;s look at C++&rsquo;s smart pointer implementation, <code>unique_ptr&lt;></code>.<pre class=language-cpp><code>int get(int* b)
{
  return *b;
}

int main()
{
  std::unique_ptr&lt;int&gt; p(new int());
  *p = 3;
  int a = get(p.get());
  return a;
}
</code></pre>Here, we allocate a new integer on the heap by calling <code>new</code>, then store it in <code>unique_ptr</code>. This ensures that when our function returns, our integer gets freed and we don&rsquo;t leak memory. However, the lifetime of our pointer is actually excessively long - we don&rsquo;t need our integer pointer after we&rsquo;ve extracted the value inside <code>get()</code>. What if we could change the lifetime of our pointer? The actual lifetime that we want is this:<pre class=language-cpp><code>int get(int* b)
{
  return *b;
  // We want the lifetime to end here
}

int main()
{
  // Lifetime starts here
  std::unique_ptr&lt;int&gt; p(new int());
  *p = 3;
  int a = get(p.get());
  return a;
  // Lifetime ends here
}
</code></pre>We can accomplish this by using <strong>move semantics</strong>:<pre class=language-cpp><code>int get(std::unique_ptr&lt;int&gt;&amp;&amp; b)
{
  return *b;
  // Lifetime of our pointer ends here
}

int main()
{
  // Lifetime of our pointer starts here
  std::unique_ptr&lt;int&gt; p(new int());
  *p                = 3;
  int a             = get(std::move(p));
  return a;
  // Lifetime of p ends here, but p is now empty
}
</code></pre>By using <code>std::move</code>, we <em>transfer ownership</em> of our unique_ptr to the function parameter. Now the <code>get()</code> function owns our integer pointer, so as long as we don&rsquo;t move it around again, it will go out of scope once <code>get()</code> returns, which will delete it. Our previous <code>unique_ptr</code> variable <code>p</code> is now empty, and when it goes out of scope, nothing happens, because it gave up ownership of the pointer it contained. This is how you can implement automatic memory management in C++ without needing to use a garbage collector, and Rust actually uses a more sophisticated version of this built into the compiler.</p><p>Move semantics can get very complex and have a lot of rules surrounding how temporary values work, but we&rsquo;re not going to get into all that right now. I also haven&rsquo;t gone into the many different ways that constructors can be invoked, and how those constructors interact with the <a href=https://blog.tartanllama.xyz/initialization-is-bonkers/>different ways you can initialize objects</a>. Hopefully, however, you now have a grasp of what lifetimes are in C++, which is a good jumping off point for learning about more advanced concepts.</p><hr><p><sup><a name=f1>[1]</a></sup> Pedantic assembly-code analysts will remind us that the stack allocations usually happen exactly once, at the beginning of the function, and then are popped off at the very end of the function, but the standard technically doesn&rsquo;t even require a stack to exist in the first place, so we&rsquo;re really talking about pushing and popping off the abstract stack concept that the language uses, not what the actual compiled assembly code really does.</p><p><sup><a name=f2>[2]</a></sup> We&rsquo;re <em>dereferencing</em> the pointer here because we want to return the <em>value</em> of the pointer, not the pointer itself! If you tried to return the pointer itself from the function, it would point to freed memory and crash after the function returned. Trying to return pointers from functions is a common mistake, so be careful if you find yourself returning a pointer to something. It&rsquo;s better to use <code>unique_ptr</code> to manage lifetimes of pointers for you.</p></div><hr><time itemprop=datePublished pubdate=pubdate datetime=2021-05-01T23:04:00+00:00><i class="fa-regular fa-clock fa-fw"></i>&nbsp;Published on <a href=https://erikmcclure.com/blog/cpp-constructors-memory-and-lifetimes/>May 1, 2021 at 11:04pm</a></time><aside><a href=/blog/cpp-constructors-memory-and-lifetimes/#comments><i class="fa-regular fa-comments fa-fw"></i>&nbsp;0 comments</a></aside><aside><i class="fa-regular fa-share-square fa-fw"></i>&nbsp;share:<ul><li><a href="javascript:window.open('https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ferikmcclure.com%2fblog%2fcpp-constructors-memory-and-lifetimes%2f','popup','width=600,height=400');"><svg width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#888}</style><path class="st0" d="M16.75 9H13.5V7a1 1 0 011-1h2V3H14a4 4 0 00-4 4V9H8v3h2v9h3.5V12H16z"/></svg></a><li><a href="javascript:window.open('https://twitter.com/intent/tweet?text=C%2b%2b%20Constructors%2c%20Memory%2c%20and%20Lifetimes&url=https%3a%2f%2ferikmcclure.com%2fblog%2fcpp-constructors-memory-and-lifetimes%2f','popup','width=600,height=256');"><svg width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#888}</style><path class="st0" opacity="0" d="M0 0h24v24H0z"/><path class="st0" d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572.0-4.658 2.086-4.658 4.66.0.364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342.0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3.0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376.0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57.0 13.255-7.098 13.255-13.254.0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg></a></li><li><a href="javascript:window.open('https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2ferikmcclure.com%2fblog%2fcpp-constructors-memory-and-lifetimes%2f','popup','width=700,height=380');"><svg width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#888}</style><rect class="st0" height="11" width="4" x="3" y="9"/><circle class="st0" cx="5" cy="5" r="2"/><path class="st0" d="M16.5 8.25A4.47251 4.47251.0 0013 9.95343V9H9V20h4V13a2 2 0 014 0v7h4V12.75a4.5 4.5.0 00-4.5-4.5z"/></svg></a></li></ul></aside></article><article><h4><a href=/blog/factorio-is-best-interview-we-have/>Factorio Is The Best Technical Interview We Have</a></h4><hr><div class=padding><p>There&rsquo;s been a lot of hand-wringing over The Technical Interview lately. Many people realize that inverting a binary tree on a whiteboard has basically zero correlation to whether or not someone is actually a good software developer. The most effective programming test anyone&rsquo;s come up with is still <a href=https://www.globalnerdy.com/2012/11/15/fizzbuzz-still-works/>Fizzbuzz</a>. One consequence of this has been an increased emphasis on Open Source Contributions, but it turns out <a href=https://blog.ploeh.dk/2021/03/22/the-dispassionate-developer/>these aren&rsquo;t a very good metric either</a>, because most people don&rsquo;t have that kind of time.</p><p>The most effective programming interview we have now is usually some kind of take-home project, where a candidate is asked to fix a bug or implement a small feature within a few days. This isn&rsquo;t great because it takes up a lot of time, and they could recieve outside help (or, if the feature is sufficiently common, google it). On the other hand, some large companies have instead doubled-down on whiteboard style interviews by subjecting prospective engineers to multiple hour-long online coding assessments, with varying levels of invasive surveillience.</p><p>All these interviewing methods pale in comparison to a very simple metric: <strong>playing Factorio with someone</strong>. Going through an entire run of Factorio is almost the best possible indication of how well someone deals with common technical problems. You can even tweak the playthrough based on the seniority of the position you&rsquo;re hiring for to get a better sense of how they&rsquo;ll function in that role.</p><h3 id=factorio>Factorio?</h3><p>Factorio is a game about automation. The best introduction is probably <a href="https://www.youtube.com/watch?v=KVvXv1Z6EY8">this trailer</a>, but in essence, your job is to build an automated factory capable of launching a rocket into space.</p><p>You begin with nothing. You mine stone manually to craft a smelter that can smelt iron ore you mined into iron plates, which you then use to build a coal-driven automatic miner. You could grab the iron ore from the miner and put it in the smelter yourself, but it&rsquo;s more efficient to use an inserter to do the inserting for you. Then you can use the iron this gives you to make another miner, which automates coal mining. Then you can use belts to take the coal and use an inserter to put it in the iron miner. Then you use the iron plates this tiny factory produces to make a third miner to start gathering copper, which then lets you craft copper wire, which lets you craft a circuit, which lets you build a water pump. Combined with a boiler and a steam engine, you can then build produce power, and use this power to run a research facility to unlock new technology, like assembly machines. Once you&rsquo;ve unlocked assembly machines, you can use your circuits to craft an assembly machine that can craft copper wire for you, and insert this into an assembly machine that crafts circuits for you.</p><p>Eventually you unlock trains and robots and logistic systems which help you deal with the increasing logistic complexity the game demands, until you finally manage to launch a rocket into space.</p><h3 id=self-direction>Self-Direction</h3><p>The beginning of the game starts with no goals and barely any direction. A senior developer should be able to explore the UI and figure out a goal, then establish a plan for accomplishing that goal. A junior developer should be able to perform a task that a senior developer has provided for them. An intern is expected to require quite a bit of mentoring, but a junior developer should be able to troubleshoot basic problems with their own code before requiring assistance from the senior developer. An intermediate developer should be able to operate independently once given a task, but is not expected to do any architecture design.</p><p>In more concrete terms, you might expect the following:</p><ul><li>An <strong>Intern</strong> is generally expected to be able to fill in a pre-placed blueprint, and use belts to hook up their blueprint with something else, like an ore patch.</li><li>A <strong>Junior Developer</strong> should be able to build a production line by themselves, although it probably won&rsquo;t be very optimal. They may need assistance from the senior developer on how to route the belts properly to all of the intermediate assembly machines.</li><li>An <strong>Intermediate Developer</strong> should be capable of designing a near-optimal production line (without beacons) once given direction, with minimal oversight.</li><li>The <strong>Senior Developer</strong> needs no direction, and is capable of determining what goals need to happen and designing a plan of action, then delegating these tasks to other coders.</li></ul><h3 id=teamwork>Teamwork</h3><p>A critical aspect of software development is the ability to work on a team. This means coordinating your efforts with other people, accomadating the needs of other people&rsquo;s designs and cooperating with the team, instead of simply running off on your own and refusing to adjust your design to help integrate it with someone else&rsquo;s work. This, naturally, arises all the time in Factorio, because base layout designs are limited by physical space. As a result, you need to carefully consider what other people are doing, and sometimes adjust your design to fit in size constraints or deal with someone else&rsquo;s design that took more room than anticipated.</p><p>Anyone who simply runs off and starts doing things themselves or fixing problems without telling people is going to quickly earn the ire of their fellow players, for the exact same reasons cowboy programmers do. Luckily, Factorio includes a built-in equivelent to <code>git blame</code>, by showing you the last player that modified any entity. Thus, when people duct tape temporary solutions and don&rsquo;t inform the team about the problem they were fixing, when their temporary solution finally blows up, people will find out. If people want to win they game, they&rsquo;ll have to learn to cooperate well with their teammates.</p><h3 id=debugging>Debugging</h3><p>One of the most important skills for any programmer is their ability to debug problems. This is perhaps the most obvious parallel between Factorio and real software engineering. Something can go wrong very far away from the actual source of the problem. Being able to rapidly hone in on the real problem is a critical skill, and the thinking process is almost identical to tracing the cause of a crash in an actual program. If an assembly machine has stopped working, first you have to see if there are multiple outputs that got backed up. Then you have to check what ingredient it&rsquo;s missing. Then you have to trace the ingredient back through your factory to find out where you&rsquo;re making it, and repeat ad nauseum.</p><p>Factorio&rsquo;s debugging gets fairly complicated quite quickly. As soon as you start working on oil processing you&rsquo;ll be dealing with cracking, where you&rsquo;re dealing with 3 different outputs and if any of them get backed up for any reason, the entire thing stops. There are cases where your entire factory can grind to a halt because you started researching something that doesn&rsquo;t require yellow science, which stopped using up robot frames, which stopped using up electric engines, which stopped using lubricant, which stopped consuming heavy oil, which backed up and stopped oil production, which made you run out of petroleum, which broke plastic, which broke red circuits, which broke the rest of the factory. Seasoned players will anticipate scenarios like this and use circuits to construct self-balancing oil cracking to ensure the system is balanced and will only back up if petroleum backs up. A new player who is a good programmer, when presented with a factory that has collapsed, will usually be able to trace the issue back to the source, realize what&rsquo;s happened, and promptly attempt to figure out a solution. On the other hand, if someone simply plops down a few storage tanks, unless they can provide a good reason (they are very confident we will never stop consuming lubricant in the future), then this is a red flag for how they approach problem solving in their programs.</p><p>Situations like these allow Factorio to closely mimic the complex interdependencies that programmers routinely deal with, and the complexity simply increases the more gameplay concepts are added. This closely follows the increased complexity that additional layers of abstraction introduce when attempting to debug a crash that could have potentially occured deep inside one of the frameworks you use.</p><h3 id=code-reviews>Code Reviews</h3><p>Often, initial designs need to be tweaked for performance or throughput. Good programmers will not only accept critique of their designs, but incorporate that feedback into their future work. If they disagree with a proposed change, they will provide a concrete reason for why they disagree so that the team can more accurately weigh the pros and cons of the proposed change.</p><p>Resisting feedback without providing good reasons is a well-known red flag, but what can also be problematic is a programmer who begrudgingly accepts proposed changes, but refuses to adjust future designs accordingly. They end up requiring constant reminders to adhere to some standard way of solving a problem while giving no reason for why they don&rsquo;t seem to like the way the team is doing things. These can be ticking time-bombs in organizations, because when left unsupervised they can rapidly accumulate technical debt for other team members. This kind of problem is almost impossible to catch in a traditional interview, unless it&rsquo;s an internship.</p><h3 id=code-style-and-frameworks>Code Style and Frameworks</h3><p>Refusing to incorporate feedback is often just a slice of a much larger problem, where someone is unable to integrate properly into an existing framework being used. There are many ways to build a factory in Factorio, and each one requires standard methods of building pieces. Failing to adhere to standards can very quickly jam up an entire factory, often in subtle ways that aren&rsquo;t necessarily obvious to a careless developer.</p><p>In the Main Belt design, a set of 4-8 chunk of belts, divided by 2 spaces to allow for underground belts, are placed in the center of the factory, and all production happens perpendicular to the belt. This design relies on several rules that can wreck havoc if not followed correctly. One, players must always use a splitter to pull items off of a belt, never redirecting the entire belt, otherwise using the empty space for a different belt of items means you&rsquo;ll have permanently lost one entire belt of resources, even after upgrading belts. Two, all factories must be scalable in a direction perpendicular to the main belt. Failing to do this will rapidly result in either a massive waste of space, or a production line that cannot be scaled up because it&rsquo;s surrounded by other production lines.</p><p>There are also different ways of building logistic networks. The simplest method is with passive provider chests, but another method uses a storage chest with a filter, which is used to solve the trashed item problem. Both of these methods require properly setting limiters in the right location. Passive provider chests generally are limited by chest space. Storage chests require hooking the inserter for the chest up to the logistics network and ensuring that less than N of an item exists before inserting it. Forgetting to perform these limiting steps is a massive waste of resources. <em>Consistently</em> forgetting to put limiters on outputs is a red flag for someone who is careless about performance in real-world applications.</p><p>In other cases, the team may be using some pre-designed blueprints, like a nuclear reactor design, or a bot factory. These can be extremely complex, but as long as people are willing to learn how to use them, they can be huge time-savers. Beware of candidates who don&rsquo;t want to learn how to set up a new item in the bot factory simply because they can&rsquo;t debug the complex logic that drives it, or ones that get frustrated learning how to use a bot factory despite the clear and obvious benefits.</p><h3 id=multithreading>Multithreading</h3><p>Trains in Factorio are a direct analogue to multithreading: one train is one thread of execution, and each train intersection or train stop is a place in memory where two threads could potentially write at the same time. Train signals are locks, or mutexes. All bugs in train networks manifest in exactly the same way software race conditions do, because they&rsquo;re literally physical race conditions. All of the tradeoffs apply here as well - if you make a lock too large, it slows down your throughput, because now the intersection is blocked for a longer period of time. Incorrectly signaled tracks routinely cause train deadlocks that are exactly the same as a software deadlock, because you end up with a circular lock dependency. The most common deadlock is when a train is too long and unexpectedly blocks a second intersection while waiting to enter one. This second intersection then prevents another train from leaving, preventing the first intersection from ever being unblocked.</p><p>The number of lanes of track in your network is equivilent to the number of cores available in your CPU. A single rail line is difficult to scale beyond a few threads because the entire system gets throughput limited very quickly, even with wait areas. The most common design is a two-lane design where each lane is a single direction, but this will eventually suffer from throughput issues when you need trains constantly being unloaded. Thus, large bases tend to have at least 4 lanes, with two outer lanes acting as bypasses to avoid the intersection whenever possible.</p><p>Missing signal problems in these systems can take a ridiculous amount of time to actually show up. A single missing signal in one rail network once caused a deadlock after functioning correctly for <em>two weeks</em>. This is remniscient of difficult to pin down race conditions in software that only occur once a month or so when under high contention.</p><h3 id=scaling>Scaling</h3><p>Just like in software, scaling up production in Factorio introduces new problems with initial designs, and often require complete redesigns that can pipe resources into factories as fast as possible, while taking advange of production modules and speed module beacons. Belt limits become problematic even at the fastest belt speed, forcing players to find ways to split designs up so that more belts can be put in later down the line, or split up their factories into modules.</p><p>Handling your logistics network itself becomes a logistics problem in the late game because of how problematic expansive bot networks are. You generally need to start segmenting the logistics network and either using trains to transport items between them, or build a requester chest/provider chest that propagates items across bounderies.</p><p>Managing trains in the late game necessitates switching to a pull architecture from a push architecture, because the push architecture can&rsquo;t function in high throughput. This inevitably requires taking advantage of the Train Limits feature and learning how circuit networks can be used to encode basic logic, such that a station only requests a train when it is actually ready to completely fill the train with resources, instead of the common early game tactic of simply telling a bunch of trains to go to stations named &ldquo;Iron Pickup&rdquo;. This minimizes the number of trains you need while making sure all stops are served on the network.</p><p>Often times, limitations in the number of possible inputs to an assembly machine and inserter speed require redesigning factories around them, just like how high-speed computing requires being aware of subtle bottlenecks in how your CPU works. These bottlenecks are almost never a problem until you reach a certain scale, at which point they begin to dominate your efficiency.</p><h3 id=microservices-and-plugin-architectures>Microservices and Plugin Architectures</h3><p>Eventually, factories get so enormous they must abandon a simple main belt or spaghetti design and use a more scalable framework instead. To reach Megabase-scale, factories generally either use a train system or a module system, which corresponds roughly to microservices or a plugin-architecture.</p><p>A train-based megabase is sometimes referred to a &ldquo;city-block&rdquo; design, where trains surrounded factory blocks and control all input and output. Thus, each individual city-block is isolated from all other city-blocks, since all their input is &ldquo;pure&rdquo; in that it comes from the train network. This is almost identical to a micro-services architecture (over HTTP) or a multi-process design (using IPC), and has similar potential issues with input and output latency, because results cannot be continually provided, they must be emitted in &ldquo;packets&rdquo;, or trains along the network.</p><p>The plugin architecture seeks to maintain some semblence of a main-belt, but instead splits belts off through the factory and uses modular blocks that take standard inputs and standard outputs. Sometimes this can be achieved entirely through bots, but materials usually need to be belted over long distances. This closely resembles a plugin system for a monolithic application, and has similar tradeoffs.</p><p>These megabases mark the extreme upper end of a vanilla Factorio server. However, there are plenty of mods to make things much more complex.</p><h3 id=distributed-systems>Distributed Systems</h3><p><a href=https://mods.factorio.com/mod/space-exploration>Space Exploration</a> is an overhaul of Factorio that adds an entire space segment of the game, and makes planets have limited resources, requiring players to colonize other planets and use rockets to transfer resources between planets. Because of the enormous latency involved with shipping materials between planets, coordinating these different bases winds up having similar problems to a globally distributed database system. Even the circuit network has to contend with latency, because an automatic request system loses track of items that have been launched but haven&rsquo;t yet reached the target planet. Not accounting for this will result in a <em>double-request</em> for all the items you wanted, which is the <em>exact same problem</em> that distributed systems have when trying to ensure consistency.</p><h3 id=conclusion>Conclusion</h3><p>Collectively, the software industry simply has no idea how to hire software developers. Factorio is probably the best technical interview we have right now, and <em>that&rsquo;s embarassing</em>. It is also wildly impractical, taking over 20 hours in an initial multiplayer playthrough, or 8 hours if you have a lot of people and know what you&rsquo;re doing. What&rsquo;s the takeaway from this? I don&rsquo;t know. We certainly can&rsquo;t switch to using Factorio as an interviewing method - you might as well just give a candidate a take-home assignment.</p><p>At the very least, we can do better than whiteboard interviews.</p></div><hr><time itemprop=datePublished pubdate=pubdate datetime=2021-03-12T15:26:00+00:00><i class="fa-regular fa-clock fa-fw"></i>&nbsp;Published on <a href=https://erikmcclure.com/blog/factorio-is-best-interview-we-have/>March 12, 2021 at 3:26pm</a></time><aside><a href=/blog/factorio-is-best-interview-we-have/#comments><i class="fa-regular fa-comments fa-fw"></i>&nbsp;0 comments</a></aside><aside><i class="fa-regular fa-share-square fa-fw"></i>&nbsp;share:<ul><li><a href="javascript:window.open('https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ferikmcclure.com%2fblog%2ffactorio-is-best-interview-we-have%2f','popup','width=600,height=400');"><svg width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#888}</style><path class="st0" d="M16.75 9H13.5V7a1 1 0 011-1h2V3H14a4 4 0 00-4 4V9H8v3h2v9h3.5V12H16z"/></svg></a><li><a href="javascript:window.open('https://twitter.com/intent/tweet?text=Factorio%20Is%20The%20Best%20Technical%20Interview%20We%20Have&url=https%3a%2f%2ferikmcclure.com%2fblog%2ffactorio-is-best-interview-we-have%2f','popup','width=600,height=256');"><svg width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#888}</style><path class="st0" opacity="0" d="M0 0h24v24H0z"/><path class="st0" d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572.0-4.658 2.086-4.658 4.66.0.364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342.0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3.0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376.0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57.0 13.255-7.098 13.255-13.254.0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"/></svg></a></li><li><a href="javascript:window.open('https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2ferikmcclure.com%2fblog%2ffactorio-is-best-interview-we-have%2f','popup','width=700,height=380');"><svg width="24" height="24" viewBox="0 0 24 24" class="twtr-icon twtr-color-fill--blue-dark has-hover"><style>.st0{fill:#888}</style><rect class="st0" height="11" width="4" x="3" y="9"/><circle class="st0" cx="5" cy="5" r="2"/><path class="st0" d="M16.5 8.25A4.47251 4.47251.0 0013 9.95343V9H9V20h4V13a2 2 0 014 0v7h4V12.75a4.5 4.5.0 00-4.5-4.5z"/></svg></a></li></ul></aside></article><div class=pager><ul><li><a href=/blog/page/2>Newer</a></li><li style=text-align:center><a href=/blog/>Home</a></li><li style=text-align:right><a href=/blog/page/4>Older</a></li></ul></div></section><section class=archive><article><img src=https://erikmcclure.com/img/avatar.th.png alt=Avatar width=180 height=180><h2>Archive</h2><ol><li><details><summary>2025</summary><ul><li><a href=/blog/technological-tsunami/>The Technological Tsunami</a></li><li><a href=/blog/purity-spiral/>Leftists Are In A Purity Death Spiral</a></li><li><a href=/blog/discord-overlay-breaks-gsync/>The New Discord Overlay Breaks GSync and Borderless Optimizations</a></li><li><a href=/blog/do-you-really-think-we-have-gender-in-the-future/>Do You Really Think We'll Have Genders In The Future?</a></li></ul></details></li><li><details><summary>2024</summary><ul><li><a href=/blog/stop-making-me-memorize-borrow-checker/>Stop Making Me Memorize The Borrow Checker</a></li><li><a href=/blog/rust-async-makes-me-want-to-gouge-my-eyes-out/>Rust Async Makes Me Want To Gouge My Eyes Out</a></li><li><a href=/blog/engineers-only-get-paid-something-broken/>Engineers Only Get Paid If Something Is Broken</a></li><li><a href=/blog/measuring-competence-is-epistemic-hell/>Measuring Competence Is Epistemic Hell</a></li><li><a href=/blog/we-could-fix-everything-we-just-dont/>We Could Fix Everything, We Just Don't</a></li></ul></details></li><li><details><summary>2023</summary><ul><li><a href=/blog/people-cant-care-about-everything/>People Can't Care About Everything</a></li><li><a href=/blog/discord-should-remove-usernames/>Discord Should Remove Usernames Entirely</a></li></ul></details></li><li><details><summary>2022</summary><ul><li><a href=/blog/money-is-fake/>Money Is Fake. It's Not Real. It's Made Up.</a></li><li><a href=/blog/we-need-new-motherboards/>We Need New Motherboards Before GPUs Collapse Under Their Own Gravity</a></li></ul></details></li><li><details><summary>2021</summary><ul><li><a href=/blog/cpp-constructors-memory-and-lifetimes/>C++ Constructors, Memory, and Lifetimes</a></li><li><a href=/blog/factorio-is-best-interview-we-have/>Factorio Is The Best Technical Interview We Have</a></li></ul></details></li><li><details><summary>2020</summary><ul><li><a href=/blog/why-you-cant-use-prebuilt-llvm-with-cpp17/>Why You Can't Use Prebuilt LLVM 10.0 with C++17</a></li><li><a href=/blog/pressure-based-anti-spam-for-discord-bots/>Pressure Based Anti-Spam for Discord Bots</a></li></ul></details></li><li><details><summary>2019</summary><ul><li><a href=/blog/name-shadowing-should-be-an-operator/>Name Shadowing Should Be An Operator</a></li><li><a href=/blog/a-rant-on-terra/>A Rant On Terra</a></li><li><a href=/blog/risc-is-fundamentally-unscalable/>RISC Is Fundamentally Unscalable</a></li></ul></details></li><li><details><summary>2018</summary><ul><li><a href=/blog/migrating-to-static-blog/>Migrating To A Static Blog</a></li><li><a href=/blog/how-to-avoid-memorizing-times-tables/>How To Avoid Memorizing Times Tables</a></li></ul></details></li><li><details><summary>2017</summary><ul><li><a href=/blog/ignoring-outliers-creates-racist/>Ignoring Outliers Creates Racist Algorithms</a></li><li><a href=/blog/i-used-to-want-to-work-for-google/>I Used To Want To Work For Google</a></li><li><a href=/blog/integrating-luajit-and-autogenerating-c/>Integrating LuaJIT and Autogenerating C Bindings In Visual Studio</a></li><li><a href=/blog/discord-rise-of-bot-wars/>Discord: Rise Of The Bot Wars</a></li><li><a href=/blog/companies-cant-be-apolitical/>Companies Can't Be Apolitical</a></li><li><a href=/blog/i-cant-hear-anything-below-80-hz/>I Can't Hear Anything Below 80 Hz</a></li><li><a href=/blog/windows-wont-let-my-program-crash/>Windows Won't Let My Program Crash</a></li><li><a href=/blog/directx-is-terrifying/>DirectX Is Terrifying</a></li></ul></details></li><li><details><summary>2016</summary><ul><li><a href=/blog/everyone-does-srgb-wrong-because/>Everyone Does sRGB Wrong Because Everyone Else Does sRGB Wrong</a></li><li><a href=/blog/mathematical-notation-is-awful/>Mathematical Notation Is Awful</a></li></ul></details></li><li><details><summary>2015</summary><ul><li><a href=/blog/i-tried-to-install-linux-and-now-i/>I Tried To Install Linux And Now I Regret Everything</a></li><li><a href=/blog/you-arent-designing-software-for-robots/>We Aren't Designing Software For Robots</a></li><li><a href=/blog/using-data-to-balance-your-game-pony/>Using Data To Balance Your Game: Pony Clicker Analysis</a></li><li><a href=/blog/does-anyone-actually-want-good-software/>Does Anyone Actually Want Good Software?</a></li></ul></details></li><li><details><summary>2014</summary><ul><li><a href=/blog/how-not-to-sell-software/>How Not To Install Software</a></li><li><a href=/blog/can-we-choose-what-we-enjoy/>Can We Choose What We Enjoy?</a></li><li><a href=/blog/how-to-make-your-profiler-10x-faster/>How To Make Your Profiler 10x Faster</a></li><li><a href=/blog/the-problem-with-photorealism/>The Problem With Photorealism</a></li></ul></details></li><li><details><summary>2013</summary><ul><li><a href=/blog/googles-decline-really-bugs-me/>Google's Decline Really Bugs Me</a></li><li><a href=/blog/the-educational-imbroglio/>The Educational Imbroglio</a></li><li><a href=/blog/write-less-code/>Write Less Code</a></li><li><a href=/blog/most-people-have-shitty-computers/>Most People Have Shitty Computers</a></li><li><a href=/blog/leap-motion-impressions-input/>Leap Motion Impressions, Input Sanitation, and 3D Gesture Ideas</a></li><li><a href=/blog/aurora-theory-released/>Aurora Theory Released!</a></li><li><a href=/blog/what-i-learned-in-college/>What I Learned In College</a></li><li><a href=/blog/course-notes/>Course Notes</a></li><li><a href=/blog/contact/>Contact</a></li><li><a href=/blog/the-dark-side-of-htmlcss/>The Dark Side of Web Development</a></li><li><a href=/blog/windows-breaks-assert-inside/>Windows Breaks assert() Inside WM_CANCELMODE</a></li><li><a href=/blog/the-productivity-fallacy/>The Productivity Fallacy</a></li></ul></details></li><li><details><summary>2012</summary><ul><li><a href=/blog/c-to-c-tutorial-part-4-operator-overload/>C# to C++ Tutorial - Part 4: Operator Overload</a></li><li><a href=/blog/7-problems-raytracing-doesnt-solve/>7 Problems Raytracing Doesn't Solve</a></li><li><a href=/blog/analyzing-xkcd-click-and-drag/>Analyzing XKCD: Click and Drag</a></li><li><a href=/blog/coordinate-systems-and-cascading/>Coordinate Systems And Cascading Stupidity</a></li><li><a href=/blog/how-joysticks-ruined-my-graphics-engine/>How Joysticks Ruined My Graphics Engine</a></li><li><a href=/blog/multithreading-problems-in-game-design/>Multithreading Problems In Game Design</a></li><li><a href=/blog/stop-following-rules/>Stop Following The Rules</a></li><li><a href=/blog/why-windows-8-does-right-thing-wrong/>Why Windows 8 Does The Right Thing The Wrong Way</a></li><li><a href=/blog/visual-studio-broke-my-computer/>Visual Studio Broke My Computer</a></li><li><a href=/blog/implicit-ui-design/>Implicit UI Design</a></li><li><a href=/blog/linux-mint-12-kde/>Linux Mint 12 KDE</a></li><li><a href=/blog/new-post/>'Programmer' is an Overgeneralization</a></li></ul></details></li><li><details><summary>2011</summary><ul><li><a href=/blog/great-mystery-of-linear-gradient/>The Great Mystery of Linear Gradient Lighting</a></li><li><a href=/blog/signed-integers-considered-stupid-like/>Signed Integers Considered Stupid (Like This Title)</a></li><li><a href=/blog/c-to-c-tutorial-part-3-classes-and/>C# to C++ Tutorial - Part 3: Classes and Structs and Inheritance (OH MY!)</a></li><li><a href=/blog/problem-of-vsync/>The Problem of Vsync</a></li><li><a href=/blog/c-to-c-tutorial-part-2-pointers/>C# to C++ Tutorial - Part 2: Pointers Everywhere!</a></li><li><a href=/blog/c-to-c-tutorial-part-1-basics-of-syntax/>C# to C++ Tutorial - Part 1: Basics of Syntax</a></li><li><a href=/blog/ninth-circle-of-bugs/>The Ninth Circle of Bugs</a></li><li><a href=/blog/investigating-low-level-cpu-performance/>Investigating Low-level CPU Performance</a></li></ul></details></li><li><details><summary>2010</summary><ul><li><a href=/blog/im-failure/>The IM Failure</a></li><li><a href=/blog/album-for-sale-renascent/>Album For Sale! [Renascent]</a></li><li><a href=/blog/wavsaver/>WavSaver</a></li><li><a href=/blog/pixel-perfect-hit-testing/>Pixel Perfect Hit Testing</a></li><li><a href=/blog/8-bit-color-cycling/>8-bit color cycling</a></li><li><a href=/blog/physics-networking/>Physics Networking</a></li><li><a href=/blog/assembly-cas-implementation/>Assembly CAS implementation</a></li><li><a href=/blog/function-pointer-speed/>Function Pointer Speed</a></li><li><a href=/blog/most-bizarre-error-ever/>Most Bizarre Error Ever</a></li><li><a href=/blog/floating-point-performance/>Floating Point Performance</a></li></ul></details></li><li><details><summary>2009</summary><ul><li><a href=/blog/physics-oriented-network-interpolation/>Physics-oriented Network Interpolation</a></li></ul></details></li></ol></article></section></main><footer><p><span>Copyright &copy;2025 Erik McClure</span> <a href=https://erikmcclure.com/sitemap.xml>Sitemap</a> | <a href=https://erikmcclure.com/blog/index.xml>RSS Feed</a></p></footer></div><script>"use strict";window.onload=function(){for(var t=document.getElementsByClassName("math"),e=0,n=t.length;e<n;e++)renderMathInElement(t[e],{delimiters:[{left:"$$",right:"$$",display:!1},{left:"\\[",right:"\\]",display:!0}]})}</script></body></html>