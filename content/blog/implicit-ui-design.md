+++
blogimport = true
categories = ["blog"]
date = "2012-02-24T10:18:00Z"
title = "Implicit UI Design"
updated = "2012-02-25T01:38:07.000+00:00"
comments = [ 3495360871809190844, 7415384556541063364, 8637755950868588592, 3473835130083808153, 3561392233451858513, 2867827262814216771, 129938107544110101, 3641431318452499209, 7218571851082137651, 7814067717559088715, 3672232785080612018, 6098474805059520200, 5292657467663549041 ]
[author]
name = "Erik McClure"
uri = "https://plus.google.com/104896885003230920472"

+++
For a long time, I have been frustrated with the poor UI design that is rampant in the software industry. As a consequence, many Linux enthusiasts have pointed out how productive you can be with Emacs, VIM, and other keyboard-shortcut/terminal oriented software. The UI design has gotten so bad, I have to agree that in comparison to recent user interface designs, keyboard shortcuts are looking rather appealing. This, however, doesn't mean that one approach is inherently better than another, simply that modern user interfaces *suck*. 

In this blog, I'm going to outline several improvements to user interfaces and the generalized alternative design philosophy that is behind many of them. To start, let's look at [this recent article](http://blogs.msdn.com/b/visualstudio/archive/2012/02/23/introducing-the-new-developer-experience.aspx) about Visual Studio 11, which details Microsoft's latest strategy to ruin their products by sucking all the color out of them: 

{{<div style="text-align:center;overflow:hidden;">}}<a href="http://blogs.msdn.com/cfs-file.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-01-29-92-metablogapi/1667.dev10toolbars_5F00_4D41B521.png"><img src="http://blogs.msdn.com/cfs-file.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-01-29-92-metablogapi/1667.dev10toolbars_5F00_4D41B521.png" alt="Visual Studio 2010" /></a><i>Visual Studio 2010</i>{{</div>}}
{{<div style="text-align:center;overflow:hidden;">}}<a href="http://blogs.msdn.com/cfs-file.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-01-29-92-metablogapi/1667.dev10toolbars_5F00_4D41B521.png"><img src="http://blogs.msdn.com/cfs-file.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-01-29-92-metablogapi/8117.dev11toolbars_5F00_2190EB25.png" alt="Visual Studio 11" /></a><i>Visual Studio 11</i>{{</div>}}

See, color is kind of important. Notably, color is *how I find icons in your toolbar*. To me, color is a kind of filter. If I know what color(s) are most prominent in a given icon, I can mentally filter out everything else and only have to browse through a much smaller subset of your icons. Combined with having a vague notion of where a given icon is, this usually reduces the number of icons I have to mentally sift through to only one or two.  

{{<div style="text-align:center;overflow:hidden;">}}<a href="/img/qem4h.png"><img src="/img/qem4h.png" alt="Color Filtering" /></a><i>Mental color and spatial filtering</i>{{</div>}}

If you remove color, I am left to only my spatial elimination, which can make things extremely annoying when there are a bunch of icons right next to each other. Microsoft claims to have done a study that shows that this new style does not harm being able to identify a given icon in terms of speed, but fails to take into account the *mental tax* that goes into finding an icon without color.  {{%blockquote%}}*While we understand that opinions on this new style of iconography may vary, an icon recognition study conducted with 76 participants, 40 existing and 36 new VS users, showed no negative effect in icon recognition rates for either group due to the glyph style transition. In the case of the new VS users they were able to successfully identify the new VS 11 icons faster than the VS 2010 icons (i.e., given a command, users were faster at pointing to the icon representing that command).*{{%/blockquote%}} You may still be able to find the icon, especially after you've been forced to memorize its position just to find it again, and do it reasonably fast, but whether you like it or not, the absence of color will force your brain to process more possible icons before settling down on the one you actually want. When I'm compiling something, I only have a vague notion of where the start button actually is. I don't need to know exactly where it is or even what it looks like; it's extremely easy to find since its practically the only green button on the entire toolbar. Same goes for save and open. The uniform color makes the icons very easy to spot, and all the other icons are immediately discarded. 

That said, there are many poorly design icons in Visual Studio. Take this group of icons: 
{{<img src="/img/mIcIL.png" alt="Bad Icons!">}}

I don't really know what any of those buttons do. One of them is some sort of toolbox and one is probably the properties window, but they have *too many colors*. It becomes, again, mentally taxing when even looking at those icons because there is too much irrelevant information being processed. In this scenario, the colors are detrimental to the identification of the buttons. This is because there is no single dominant color, like on the play button, or the save button. Hence, the best solution is to design icons with principle colors, such that some or all the icon is one color and the rest is greyscale. The brain edits out the greyscale and allows identification by color, followed by location, followed by actual glyph shape. To avoid overloading the user with a rainbow of colors, consider scaling the amount of color to how likely a given button is to be used. Desaturate or shrink the colored area of buttons that are much less important. Color is a tool that can be used correctly or incorrectly - that doesn't mean you should just throw it away the first time you screw up. 

We can make better decisions by taking into account how the user is going to use the GUI. By developing an awareness of how a user interface is normally used, we develop vastly superior interactions that accelerate, rather than impede, workflow. To return to visual studio, let's take a look at a feature in the VS11: pinning a variable preview. 
{{<img src="/img/c6j3X.png" alt="Variable Preview">}}{{<img src="/img/fskyt.png" alt="Pinned Variable Preview">}}

This is a terrible implementation for a number of reasons. First, since the pin button is all the way on the other end, it is a moving target and you'll never really be sure where it is until you need to pin something. Furthermore, you can drag the pinned variable around, and you'll want to after Visual Studio moves it to a seemingly random location that is almost always annoying (but only after the entire IDE locks up for 3 seconds because you haven't done it recently). When would a user be dragging a variable around? Only when its pinned. A better implementation is to make a handle on the left side of any variable preview. If you click the handle (and optionally drag the variable around), it is implicitly converted to a pinned variable without changing anything else, and a close button appears to the left of the handle. 

{{<img src="/img/yXQ12.png" alt="Better Variable Preview" >}}{{<img src="/img/YOXVA.png" alt="Better Pinned Preview" >}}

This is much easier to use, because it eliminates a mouse click and prevents the variable from moving to some random location you must then locate afterwards to move it to your actual desired location. By shifting the close button to the left, it is no longer a moving target. To make this even better, you should make sure previews snap to each other so you can quickly build a list of them, and probably include a menu dropdown by the close button too. 

We have just used *Implicit UI Design*, where instead of forcing the user to explicitly specify what they want to have happen, we can use contextual clues to *imply* a given action. We knew that the user could not possibly move a variable preview without wanting to pin it, so we simply made the act of moving the preview, pin it. Another example is docking windows. Both Adobe and Visual Studio are guilty of trying to make everything dockable everywhere without realizing that this is usually just extremely annoying, not helpful. I mean really, why would I want to *dock* the find window? 

{{<div style="text-align:center;overflow:hidden;">}}<a href="/img/odtyz.png"><img style="height:380px" src="/img/odtyz.png" alt="Bad Find Window!" /></a></br><i>Goddamn it, not again</i>{{</div>}}

Even if I was doing a lot of find and replace, it just isn't useful. You can usually cover up half your code while finding and replacing without too much hassle. The only thing this does is make it really hard to move the damn window anywhere because if you aren't careful you'll accidentally dock it to the toolbar and then you have to pull the damn thing out and hope nothing else blew up, and if your really unlucky you'll have to reconstruct the whole freaking solution window. 

That isn't helpful. The fact that the act of docking and undocking can be excruciatingly slow makes things even worse and is inexcusable. Only a UI that is bloated beyond my ability to comprehend could possibly have such a difficult time docking and undocking things, no doubt made worse by their fetishization of docking windows. Docking windows correctly requires that you account for the extremely common mistake of accidentally undocking or docking a window where you didn't want it. If a mistake is so common and so annoying, you should make it either much harder to do, or make it very easy to undo. In this case, you should remember where the window was docked last (or not docked), and make a space for it to be dropped into, instead of forcing the user to figure out which magic location on the screen actually docks the window to the right position (which sometimes involves differences of 2 or 3 pixels, which is incredibly absurd). 

{{<div style="text-align:center;overflow:hidden">}}<a href="/img/ZKhiJ.png"><img src="/img/ZKhiJ.png" alt="Spot Holding"></a><br/><i>Spot Holding</i>{{</div>}}

Panels are related to docking (usually you can dock something into a collapsible panel), but even these aren't done very efficiently. If you somehow manage to get the window you want docked into a panel, it defaults to pinning *the entire group of panels*, regardless of whether they were pinned before or not. I just wanted to pin one! 

{{<div style="text-align:center;overflow:hidden">}}<a href="/img/A4Q2w.png"><img src="/img/A4Q2w.png"/ alt="Pin Disaster"></a><br/><i>You have to drag the thing out and redock it to pin just that one panel.</i>{{</div>}}

There is a better way to do this. If we click on a collapsible panel, we know the user wants to show it. However, the only reason they even need to click on the panel is because we don't show it immediately after the mouse hovers over the button. This time should be less than a tenth of a second, and it should immediately close if the mouse gets too far away. It should stay open if the mouse is close enough that the user might have temporarily left the window but may want to come back in. Hovering over another panel button *immediately* replaces the current panel (in this case, at least), and dragging the panel title bar or the panel button lets you dock or undock. 

Now the user will never need to click the panel to make it show up, so we can make that operation do something else. Why not make clicking a panel pin it open? And don't do any of that "pin the entire bunch of panels" crap either, just pin that one panel and have it so the other panels can still pop up over it. Then, if you click the panel button again, it's unpinned. This is *so much better* than the clunky UI interfaces we have right now, and we did it by thinking about *Implicit UI Design*. By making the mouse click redundant, we could take that to *imply* that the user wants the panel to be pinned. Moving the mouse far away from the panel *implies* that the panel is no longer useful. To make sure a mistake is easy to correct, pinning a panel should be identical to simply having it be hovered over indefinitely, and should not change the surrounding UI in any way. Then a mistake can simply be undone by clicking the panel button again, which is a much larger target than a tiny little pin icon. Combine this with our improved docking above, so that a mistakenly undocked panel, when clicked and dragged again, has its old spot ready and waiting in case you want to undo your mistake. 

{{<div style="overflow:hidden">}}<a href="/img/1j4kq.png"><img src="/img/1j4kq.png" alt="Panel holding" /></a>{{</div>}}

It's 2012. I think its high time our user interfaces reflected that.
