id = "2554555964538927524"
date = 2012-10-12T05:46:42Z
updated = 2012-10-12T05:46:42Z
title = "You keep referring to the CIV V engine so you prob..."
content = "You keep referring to the CIV V engine so you probably have read a lot about it. Could you refer me to the website/pdf that explains how they have implemented their rendering loop and worker queues? I can&#39;t seem to find it.<br /><br />I am well aware of possible latency issues (and solutions) between client and server, but all those issues can be solved by letting the client&#39;s extrapolate game states and make a prediction of the changes caused by local actions. The difficulty lies in restoring game states on wrongful predictions, which for some games can be solved by sending a complete game state (on conflict only). For non-deterministic game engines this is way more difficult because each client&#39;s game state is by definition almost always wrong. To solve this for non-deterministic game engine you&#39;ll need to send position-information pretty much non-stop to prevent out-of-sync weirdness. So really, I do understand. I&#39;m just saying that latency issues are not a good excuse to drop determinism.<br /><br />The &quot;problem&quot; I tried to &quot;solve&quot; is creating a non blocking multithreaded deterministic game loop. You probably agree with me that this isn&#39;t easy to accomplish, just a couple of hour ago you claimed that determinism is impossible. You keep saying that I &quot;<i>missed the point</i>&quot; or that I &quot;<i>misunderstand</i>&quot; and calling my implementation &quot;<i>horrendous</i>&quot;. Why are you saying such provocative things? Most of them not even true:<br />- the sleep(0) loop<br />- impossibility of non-determinism<br />- floating point errors make it non-determinsitic<br />- network packets arriving in the wrong order<br />- very difficult to integrate external physics module<br /><br />I&#39;ve shown you a different method of applying multithreading and it &#39;does&#39; have advantages, even if you don&#39;t agree with me. This is the pseudo-code of my render loop. The only mutex is used when switching states.<br /><br />while (true) {<br />  RenderState latestUpdatedRenderState = world.GetLatestUpdatedRenderState(); /* Quick thread-safe pointer switch */<br />  Draw(latestUpdatedRenderState);<br />  FlipFrontAndBackBuffer();<br />}<br /><br />I don&#39;t have to wait for physics calculations to complete, I can just render a new frame. No waiting, ever! Can&#39;t get much faster then that right? It is even possible to render at a higher FPS then the update-FPS because all positions are automatically extrapolated and inconsistencies are solved automatically. Not so &quot;horrendous&quot; now, is it? Even if the game is rendering at a meager 10FPS, the game speeds remains steady while still being deterministic.<br /><br />Maybe we just have different goals for or engine. Especially for game-engines, there are seldom situations where a &quot;one solution fits all&quot; can be applied."
reply = 6206156930516113659
[author]
	name = "Alex de Vries"
	uri = "https://www.blogger.com/profile/10014738507379308518"
[author.image]
	source = "//lh3.googleusercontent.com/-uwLhDcc6ze4/AAAAAAAAAAI/AAAAAAAAAAA/40Ra3RcSSfc/s32-c/photo.jpg"
	width = "32"
	height = "32"
