id = "2574570570561152060"
date = 2012-10-12T00:38:54Z
updated = 2012-10-12T00:38:54Z
title = "It is complicated as hell, I&#39;ll give you that...."
content = '''It is complicated as hell, I&#39;ll give you that. But I think you&#39;re misunderstanding what the proposed solution is trying to solve.<br /><br />The render loop is should be as quick as possible, but multithreading adds a lot of overhead. You don&#39;t want to perform a lot of mutex checks in the renderloop. The render loop should be as mutex-free as possible.<br /><br />The game/simulation must be deterministic (one of the goals from <a href="http://blog.slapware.eu/" rel="nofollow">slapware.eu</a>). So &quot;position.X = position.X * elapsedGameTime&quot; is not allowed, because depending on render speed for motion calculation makes it non-deterministic. You might think this is overkill, but determinism is really great for multiplayer games. If you&#39;ll shoot a grenade you often see some sort of latency because the server sends lots and lots of position updates for the grenade. With determinism you don&#39;t need to spam your internet connection with position-updates. Having a multithreaded implementation that allows for FPS-drops (and absurd FPS like over 9000) without slowing down the game and still being deterministic is a difficult problem to solve and hence the difficult solution. If you know of any other solution I really like to know about it, I find this stuff intriguingly interesting!<br /><br />The solution does not spin on Sleep(0), that would be a seriously bad implementation (imho). The site discusses the how thread-switching may cause stuttering and the two proposed solutions are partial thread synchronization and motion extrapolation.<br /><br />If you are using a custom physics engine, you&#39;ll just plug it into the update-thread. It is as easy to integrate as in any other single threaded method.<br /><br />Using a &#39;task-manager&#39; is the obvious way of multithreading and the solution from <a href="http://blog.slapware.eu/" rel="nofollow">http://blog.slapware.eu/</a> still allows for such implementation. Usually you&#39;ll create a producer-consumer queue, and generate tasks that your background threads will handle. If you are adding this to the solution from slapware then the update-thread will be the &#39;producer&#39; and he will spawn a couple of background threads (consumers) to calculate physics, AI and other CPU related stuff.<br /><br />At least you should have a separate producer-consumer queue for GPU-related stuff and CPU related stuff. If you optimally want to use your GPU you need 1 thread for all the drawing (heavy on GPU, light on the bus) and one thread for updating models and textures (light on GPU, heavy on the bus). Assuming you have only one GPU. And not to subtract from the achievements of CIV4, a great game, but it is not one of the most complicated games for an engine to handle. (semi-)top-down is relatively easy especially if the game is semi-2D, even if you support LOD-algorithms for awesome infinite zoom-out.<br /><br />Luckily, the complicated stuff from the proposed solution is only in the engine and not in the game. It is still possible to do everything you want without writing absurdly complicated code when creating a game.'''
reply = 2899917955386844286
[author]
	name = "Alex de Vries"
	uri = "https://www.blogger.com/profile/10014738507379308518"
[author.image]
	source = "//lh3.googleusercontent.com/-uwLhDcc6ze4/AAAAAAAAAAI/AAAAAAAAAAA/40Ra3RcSSfc/s32-c/photo.jpg"
	width = "32"
	height = "32"
