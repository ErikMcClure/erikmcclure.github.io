id = "3095904484010271963"
date = 2012-03-23T06:46:08Z
updated = 2012-03-23T06:46:08Z
title = '''I think there are some interesting posts on your b...'''
content = '''I think there are some interesting posts on your blog, but I disagree with you on this. The conventional wisdom on this matter is as presented in Google&#39;s C++ style guide, and I&#39;ve come to agree that it&#39;s the correct approach.<br /><br />You cannot use unsigned everywhere or restrict signed to special cases. Too many standard APIs return long or int, many more than use unsigned or types such as size_t. Very often you want to be able to pass signed values around, you really need to represent negative values, or you want functions to accept signed simply so that users don&#39;t have be casting unsigned to signed all the time (since the values they&#39;re using very likely have to work together with something using signed at some point).<br />Unsigned, on the other hand, can be restricted to special cases. E.g., cases where you need defined wrapping behaviour, cases where the extra positive range really is useful (e.g. uint8_t image components, file access APIs with only a 32 bit offset), cases where you&#39;re operating on a binary data format that defines unsigned fields, etc.<br />If you do mix up signed and unsigned all through your code base, you need to engage in a lot of inconvenient and error-prone casting between them. I think it&#39;s best to choose to use one or the other in general, and due to the above reasons it has to be signed.<br /><br />You cannot rely on overflow of a signed value by 1 giving a negative value, it could very well just go up to a higher value than you thought possible because the compiler decided that behaviour was more efficient to implement (e.g., scalar int32_t arithmetic on a machine with 64b registers). This is because signed overflow is undefined. Unsigned overflow, on the other hand, is defined. E.g., ensuring standards-compliant wrapping for 32b values on a CPU with 64b registers can potentially incur a cost.<br />There are cases where unsigned can give a performance benefit, but in general they&#39;re more rare. E.g., handling 64b integers on a 32b CPU, dividing by a power of two, absolute value, etc.<br /><br />In general, in terms of detecting bugs quickly for values/arguments expected to be positive, the behaviour of signed types is useful. We can easily assert(a_value &gt;= 0). I suppose potentially you should also assert(a_value &lt;= std::numeric_limits::max()). Even though the behaviour is undefined, and if you&#39;re doing something crazy enough you could wrap right back around to something in the expected range, you can almost always detect an argument that&#39;s gone outside the expected range. The number of times I&#39;ve had such assertions pick up an issue quickly during testing, or pick up precondition violations due to bugs in the code calling my functions, is huge.<br />For an unsigned integer, because it&#39;s guaranteed to wrap back to another valid positive value by the C++ standard, all we can really do is check against a maximum &quot;sensible&quot; value. That&#39;s definitely not self-documenting behaviour, could be unexpected, and defining such a value could be problematic.<br />Considering that we have a choice between picking up many cases of unexpected value bugs with assertions (e.g., due to operations inadvertently wrapping or going negative), and probably not picking up any of them without selecting a maximum value to support, signed is a definite improvement.<br /><br />The other reason that I can think of to prefer signed values is that they&#39;re generally more intuitive to use. I&#39;m sure we&#39;ve all written something like that Google&#39;s example at some stage, ridiculous as it looks. Potentially not that obvious but the ability to go negative is natural in mathematics. In fact, I think the examples of potential bugs you gave in your post seem more unlikely, and the overflow issue you linked to is not something that&#39;s magically fixed by using unsigned types.<br /><br />I would say more, but you&#39;re probably sick of me by now and I&#39;ve hit a character limit :). There are reasons that aren&#39;t completely without sense for using signed integers except in special cases, anyway.'''
[author]
	name = "Scott McMillan"
	uri = "https://www.blogger.com/profile/16103023325518983005"
[author.image]
	source = "//lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35"
	width = "35"
	height = "35"
