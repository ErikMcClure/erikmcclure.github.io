content = "I sense you too have a lot of knowledge about the subject, which makes this an interesting discussion. I&#39;ll try not to make it into some sort of flame-war between two techniques, because I really like to read what you have to say :)<br /><br />1. Mutexes<br />I totally agree with you. Mutexes should be prevented wherever possible.<br /><br />2. Determinism is possible.<br />Floating point errors occur, true, but if the floating point errors are consistent then there isn&#39;t any problem. This is also possible cross-platform because floating-operation are <a href=\"http://en.wikipedia.org/wiki/IEEE_floating_point\" rel=\"nofollow\">standardized</a>. Most compilers even have flags to allow you to change the way that floating point are handled.<br />Network issues are no problem either, unless you use UDP (or some other protocol). For TCP/IP the order of the packets are guaranteed. This does not mean that packets arrive at your computer at the same time, but TCP uses a buffer and automatically asks for re-transmissions if needed. Your application will receive all packets in order. If there are any problems (some packet will never be received, even after asking for re-transmissions) the connection will just be dropped. Packet corruption is handled by check-sums (in both ip-packet-header and tcp-packet-header)<br /><br />The complexity of a solution is never a real issue for me because I enjoy figuring out what the best approach is (for my situation). The technique I used is not as far fetched as you might think. It is a technique called <a href=\"http://vrjuggler.org/docs/vrjuggler/2.0/programmer.guide/programmer.guide/ch10s04.html#section.triple.buffering\" rel=\"nofollow\">triple buffering</a> (not to be confused with triple buffering on the video card). CryENGINE 3 is another one of those great tripple-A game engines. I&#39;m not going to compare these engines, lets just say that most these engines are pretty darn good. I&#39;m certainly not going to compare something I have written in 1~2 weeks with a tripple-A engine. Especially because I have written this implementation in c#, lol. It is very difficult to look at a certain engine and determine what techniques they apply. They often limit themselves to saying things like &quot;<i>we are supporting volumetric clouds</i>&quot; or &quot;<i>we have a taskmanager to optimally use all cores in your CPU</i>&quot; without diving into the specifics of &#39;how&#39; it is implemented. I wouldn&#39;t be surprised if these engines are also able apply a form of tripple buffering on render states.<br /><br />I also agree with you that you&#39;ll need some sort of task manager to optimally use cores in your CPU/GPU. And the technique you describe seems pretty solid. We actually agree on most topics except for the one where I prefer a separation of &#39;task-manager&#39; for GPU and CPU, while you just say that just one task-manager for both is good enough. I also use triple render-state buffering, but I probably wouldn&#39;t have implemented that if I didn&#39;t need determinism.<br /><br />A task-manager with 50 workers for a dual-core CPU is silly as you probably agree with me. There should be some balance between the nr. of cores and the number of threads. The GPU and CPU are intrinsically different. They contain a different number of cores and the are connected through a bus that only allows one &#39;message&#39; to be send to it at a time (protected by mutexes in the video card driver). Since the bus is protected with mutexes it should also seem silly to have more than 1 threat to try and send a message to the video card. Because they are so different it makes more sense to separate the queues so we are able to fine tune these queues (perhaps even setting thread-priorities)."
date = "2012-10-12T03:35:59+00:00"
id = 6206156930516113659
title = "I sense you too have a lot of knowledge about the ..."
updated = "2012-10-12T03:35:59+00:00"
[author]
name = "Alex de Vries"
uri = "https://www.blogger.com/profile/10014738507379308518"
[author.image]
height = 32
source = "//lh3.googleusercontent.com/-uwLhDcc6ze4/AAAAAAAAAAI/AAAAAAAAAAA/40Ra3RcSSfc/s32-c/photo.jpg"
width = 32
